
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000050  00800100  00002d7c  00002e10  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002d7c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000687  00800150  00800150  00002e60  2**0
                  ALLOC
  3 .stab         0000a68c  00000000  00000000  00002e60  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004e79  00000000  00000000  0000d4ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00012365  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00012378  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  000123b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  000129ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  00012f4e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  00012f68  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ec e7       	ldi	r30, 0x7C	; 124
      7c:	fd e2       	ldi	r31, 0x2D	; 45
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 35       	cpi	r26, 0x50	; 80
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a0 e5       	ldi	r26, 0x50	; 80
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a7 3d       	cpi	r26, 0xD7	; 215
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <main>
      9e:	0c 94 bc 16 	jmp	0x2d78	; 0x2d78 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vErrorChecks>:
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
	{
		xErrorHasOccurred = pdTRUE;
      a6:	c1 e0       	ldi	r28, 0x01	; 1

	/* Cycle for ever, delaying then checking all the other tasks are still
	operating without error. */
	for( ;; )
	{
		vTaskDelay( mainCHECK_PERIOD );
      a8:	88 eb       	ldi	r24, 0xB8	; 184
      aa:	9b e0       	ldi	r25, 0x0B	; 11
      ac:	0e 94 d5 06 	call	0xdaa	; 0xdaa <vTaskDelay>

		/* Perform a bit of 32bit maths to ensure the registers used by the
		integer tasks get some exercise. The result here is not important -
		see the demo application documentation for more info. */
		ulDummyVariable *= 3;
      b0:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
      b4:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
      b8:	40 91 02 01 	lds	r20, 0x0102	; 0x800102 <__data_start+0x2>
      bc:	50 91 03 01 	lds	r21, 0x0103	; 0x800103 <__data_start+0x3>
      c0:	a3 e0       	ldi	r26, 0x03	; 3
      c2:	b0 e0       	ldi	r27, 0x00	; 0
      c4:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <__muluhisi3>
      c8:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
      cc:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
      d0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
      d4:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>

static void prvCheckOtherTasksAreStillRunning( void )
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
      d8:	0e 94 39 13 	call	0x2672	; 0x2672 <xAreIntegerMathsTaskStillRunning>
      dc:	81 30       	cpi	r24, 0x01	; 1
      de:	11 f0       	breq	.+4      	; 0xe4 <vErrorChecks+0x3e>
	{
		xErrorHasOccurred = pdTRUE;
      e0:	c0 93 50 01 	sts	0x0150, r28	; 0x800150 <__data_end>
	}

	if( xAreComTestTasksStillRunning() != pdTRUE )
      e4:	0e 94 71 14 	call	0x28e2	; 0x28e2 <xAreComTestTasksStillRunning>
      e8:	81 30       	cpi	r24, 0x01	; 1
      ea:	11 f0       	breq	.+4      	; 0xf0 <vErrorChecks+0x4a>
	{
		xErrorHasOccurred = pdTRUE;
      ec:	c0 93 50 01 	sts	0x0150, r28	; 0x800150 <__data_end>
	}

	if( xArePollingQueuesStillRunning() != pdTRUE )
      f0:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <xArePollingQueuesStillRunning>
      f4:	81 30       	cpi	r24, 0x01	; 1
      f6:	11 f0       	breq	.+4      	; 0xfc <vErrorChecks+0x56>
	{
		xErrorHasOccurred = pdTRUE;
      f8:	c0 93 50 01 	sts	0x0150, r28	; 0x800150 <__data_end>
	}

	if( xAreRegTestTasksStillRunning() != pdTRUE )
      fc:	0e 94 49 03 	call	0x692	; 0x692 <xAreRegTestTasksStillRunning>
     100:	81 30       	cpi	r24, 0x01	; 1
     102:	11 f0       	breq	.+4      	; 0x108 <vErrorChecks+0x62>
	{
		xErrorHasOccurred = pdTRUE;
     104:	c0 93 50 01 	sts	0x0150, r28	; 0x800150 <__data_end>
	}

	if( xErrorHasOccurred == pdFALSE )
     108:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <__data_end>
     10c:	81 11       	cpse	r24, r1
     10e:	cc cf       	rjmp	.-104    	; 0xa8 <vErrorChecks+0x2>
	{
		/* Toggle the LED if everything is okay so we know if an error occurs even if not
		using console IO. */
		vParTestToggleLED(/* mainCHECK_TASK_LED */);
     110:	0e 94 cd 00 	call	0x19a	; 0x19a <vParTestToggleLED>
     114:	c9 cf       	rjmp	.-110    	; 0xa8 <vErrorChecks+0x2>

00000116 <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	vCoRoutineSchedule();
     116:	0c 94 b6 10 	jmp	0x216c	; 0x216c <vCoRoutineSchedule>

0000011a <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     11a:	8f ef       	ldi	r24, 0xFF	; 255
     11c:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <ucCurrentOutputValue>

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstALL_BITS_OUTPUT;
     120:	84 b9       	out	0x04, r24	; 4
	//PORTB = ucCurrentOutputValue;
	        vTaskSuspendAll();
     122:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
        {
                for (;;)
                {
                        PORTB = 0b00100000;
     126:	80 e2       	ldi	r24, 0x20	; 32
     128:	85 b9       	out	0x05, r24	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     12a:	2f ef       	ldi	r18, 0xFF	; 255
     12c:	37 ea       	ldi	r19, 0xA7	; 167
     12e:	91 e6       	ldi	r25, 0x61	; 97
     130:	21 50       	subi	r18, 0x01	; 1
     132:	30 40       	sbci	r19, 0x00	; 0
     134:	90 40       	sbci	r25, 0x00	; 0
     136:	e1 f7       	brne	.-8      	; 0x130 <vParTestInitialise+0x16>
     138:	00 c0       	rjmp	.+0      	; 0x13a <vParTestInitialise+0x20>
     13a:	00 00       	nop
                        _delay_ms(2000);
                        PORTB = 0b00000000;
     13c:	15 b8       	out	0x05, r1	; 5
     13e:	2f ef       	ldi	r18, 0xFF	; 255
     140:	37 ea       	ldi	r19, 0xA7	; 167
     142:	91 e6       	ldi	r25, 0x61	; 97
     144:	21 50       	subi	r18, 0x01	; 1
     146:	30 40       	sbci	r19, 0x00	; 0
     148:	90 40       	sbci	r25, 0x00	; 0
     14a:	e1 f7       	brne	.-8      	; 0x144 <vParTestInitialise+0x2a>
     14c:	00 c0       	rjmp	.+0      	; 0x14e <vParTestInitialise+0x34>
     14e:	00 00       	nop
     150:	eb cf       	rjmp	.-42     	; 0x128 <vParTestInitialise+0xe>

00000152 <vParTestSetLED>:

}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     152:	1f 93       	push	r17
     154:	cf 93       	push	r28
     156:	df 93       	push	r29
unsigned char ucBit = ( unsigned char ) 1;

	if( uxLED <= partstMAX_OUTPUT_LED )
     158:	82 30       	cpi	r24, 0x02	; 2
     15a:	d8 f4       	brcc	.+54     	; 0x192 <vParTestSetLED+0x40>
     15c:	16 2f       	mov	r17, r22
	{
		ucBit <<= uxLED;	
     15e:	c1 e0       	ldi	r28, 0x01	; 1
     160:	d0 e0       	ldi	r29, 0x00	; 0
     162:	01 c0       	rjmp	.+2      	; 0x166 <vParTestSetLED+0x14>
     164:	cc 0f       	add	r28, r28
     166:	8a 95       	dec	r24
     168:	ea f7       	brpl	.-6      	; 0x164 <vParTestSetLED+0x12>

		vTaskSuspendAll();
     16a:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     16e:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <ucCurrentOutputValue>
	{
		ucBit <<= uxLED;	

		vTaskSuspendAll();
		{
			if( xValue == pdTRUE )
     172:	11 30       	cpi	r17, 0x01	; 1
     174:	19 f4       	brne	.+6      	; 0x17c <vParTestSetLED+0x2a>
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     176:	c0 95       	com	r28
     178:	c8 23       	and	r28, r24
     17a:	01 c0       	rjmp	.+2      	; 0x17e <vParTestSetLED+0x2c>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     17c:	c8 2b       	or	r28, r24
     17e:	c0 93 04 01 	sts	0x0104, r28	; 0x800104 <ucCurrentOutputValue>
			}

			PORTB = ucCurrentOutputValue;
     182:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <ucCurrentOutputValue>
     186:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();
	}
}
     188:	df 91       	pop	r29
     18a:	cf 91       	pop	r28
     18c:	1f 91       	pop	r17
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();
     18e:	0c 94 2b 06 	jmp	0xc56	; 0xc56 <xTaskResumeAll>
	}
}
     192:	df 91       	pop	r29
     194:	cf 91       	pop	r28
     196:	1f 91       	pop	r17
     198:	08 95       	ret

0000019a <vParTestToggleLED>:
/*-----------------------------------------------------------*/
void vParTestToggleLED()
{
	vTaskSuspendAll();
     19a:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
	{
		for (;;)
		{
			PORTB = 0b00100000;
     19e:	80 e2       	ldi	r24, 0x20	; 32
     1a0:	85 b9       	out	0x05, r24	; 5
     1a2:	2f ef       	ldi	r18, 0xFF	; 255
     1a4:	39 e6       	ldi	r19, 0x69	; 105
     1a6:	98 e1       	ldi	r25, 0x18	; 24
     1a8:	21 50       	subi	r18, 0x01	; 1
     1aa:	30 40       	sbci	r19, 0x00	; 0
     1ac:	90 40       	sbci	r25, 0x00	; 0
     1ae:	e1 f7       	brne	.-8      	; 0x1a8 <vParTestToggleLED+0xe>
     1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <vParTestToggleLED+0x18>
     1b2:	00 00       	nop
			_delay_ms(500);
			PORTB = 0b00000000;
     1b4:	15 b8       	out	0x05, r1	; 5
     1b6:	2f ef       	ldi	r18, 0xFF	; 255
     1b8:	39 e6       	ldi	r19, 0x69	; 105
     1ba:	98 e1       	ldi	r25, 0x18	; 24
     1bc:	21 50       	subi	r18, 0x01	; 1
     1be:	30 40       	sbci	r19, 0x00	; 0
     1c0:	90 40       	sbci	r25, 0x00	; 0
     1c2:	e1 f7       	brne	.-8      	; 0x1bc <vParTestToggleLED+0x22>
     1c4:	00 c0       	rjmp	.+0      	; 0x1c6 <vParTestToggleLED+0x2c>
     1c6:	00 00       	nop
     1c8:	eb cf       	rjmp	.-42     	; 0x1a0 <vParTestToggleLED+0x6>

000001ca <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
     1ca:	cf 92       	push	r12
     1cc:	df 92       	push	r13
     1ce:	ef 92       	push	r14
     1d0:	ff 92       	push	r15
     1d2:	cf 93       	push	r28
     1d4:	6b 01       	movw	r12, r22
     1d6:	7c 01       	movw	r14, r24
     1d8:	c4 2f       	mov	r28, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     1da:	0f b6       	in	r0, 0x3f	; 63
     1dc:	f8 94       	cli
     1de:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     1e0:	40 e0       	ldi	r20, 0x00	; 0
     1e2:	61 e0       	ldi	r22, 0x01	; 1
     1e4:	8c 2f       	mov	r24, r28
     1e6:	0e 94 75 0b 	call	0x16ea	; 0x16ea <xQueueGenericCreate>
     1ea:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <xRxedChars+0x1>
     1ee:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <xRxedChars>
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	61 e0       	ldi	r22, 0x01	; 1
     1f6:	8c 2f       	mov	r24, r28
     1f8:	0e 94 75 0b 	call	0x16ea	; 0x16ea <xQueueGenericCreate>
     1fc:	90 93 52 01 	sts	0x0152, r25	; 0x800152 <xCharsForTx+0x1>
     200:	80 93 51 01 	sts	0x0151, r24	; 0x800151 <xCharsForTx>

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
     204:	a7 01       	movw	r20, r14
     206:	96 01       	movw	r18, r12
     208:	84 e0       	ldi	r24, 0x04	; 4
     20a:	22 0f       	add	r18, r18
     20c:	33 1f       	adc	r19, r19
     20e:	44 1f       	adc	r20, r20
     210:	55 1f       	adc	r21, r21
     212:	8a 95       	dec	r24
     214:	d1 f7       	brne	.-12     	; 0x20a <xSerialPortInitMinimal+0x40>
     216:	60 e0       	ldi	r22, 0x00	; 0
     218:	7d e2       	ldi	r23, 0x2D	; 45
     21a:	81 e3       	ldi	r24, 0x31	; 49
     21c:	91 e0       	ldi	r25, 0x01	; 1
     21e:	0e 94 32 16 	call	0x2c64	; 0x2c64 <__udivmodsi4>
     222:	da 01       	movw	r26, r20
     224:	c9 01       	movw	r24, r18
     226:	01 97       	sbiw	r24, 0x01	; 1
     228:	a1 09       	sbc	r26, r1
     22a:	b1 09       	sbc	r27, r1

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0L = ucByte;
     22c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>

		ulBaudRateCounter >>= ( unsigned long ) 8;
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
     230:	89 2f       	mov	r24, r25
     232:	9a 2f       	mov	r25, r26
     234:	ab 2f       	mov	r26, r27
     236:	bb 27       	eor	r27, r27
		UBRR0H = ucByte;
     238:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
     23c:	88 e9       	ldi	r24, 0x98	; 152
     23e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

		/* Set the data bits to 8. */
		UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
     242:	86 e8       	ldi	r24, 0x86	; 134
     244:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	}
	portEXIT_CRITICAL();
     248:	0f 90       	pop	r0
     24a:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
     24c:	80 e0       	ldi	r24, 0x00	; 0
     24e:	90 e0       	ldi	r25, 0x00	; 0
     250:	cf 91       	pop	r28
     252:	ff 90       	pop	r15
     254:	ef 90       	pop	r14
     256:	df 90       	pop	r13
     258:	cf 90       	pop	r12
     25a:	08 95       	ret

0000025c <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     25c:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <xRxedChars>
     260:	90 91 54 01 	lds	r25, 0x0154	; 0x800154 <xRxedChars+0x1>
     264:	0e 94 81 0c 	call	0x1902	; 0x1902 <xQueueReceive>
     268:	91 e0       	ldi	r25, 0x01	; 1
     26a:	81 11       	cpse	r24, r1
     26c:	01 c0       	rjmp	.+2      	; 0x270 <xSerialGetChar+0x14>
     26e:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return pdFALSE;
	}
}
     270:	89 2f       	mov	r24, r25
     272:	08 95       	ret

00000274 <xSerialPutChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
     274:	cf 93       	push	r28
     276:	df 93       	push	r29
     278:	1f 92       	push	r1
     27a:	cd b7       	in	r28, 0x3d	; 61
     27c:	de b7       	in	r29, 0x3e	; 62
     27e:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     280:	20 e0       	ldi	r18, 0x00	; 0
     282:	be 01       	movw	r22, r28
     284:	6f 5f       	subi	r22, 0xFF	; 255
     286:	7f 4f       	sbci	r23, 0xFF	; 255
     288:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <xCharsForTx>
     28c:	90 91 52 01 	lds	r25, 0x0152	; 0x800152 <xCharsForTx+0x1>
     290:	0e 94 98 0b 	call	0x1730	; 0x1730 <xQueueGenericSend>
     294:	81 30       	cpi	r24, 0x01	; 1
     296:	31 f4       	brne	.+12     	; 0x2a4 <xSerialPutChar+0x30>
	{
		return pdFAIL;
	}

	vInterruptOn();
     298:	90 91 c1 00 	lds	r25, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     29c:	90 62       	ori	r25, 0x20	; 32
     29e:	90 93 c1 00 	sts	0x00C1, r25	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

	return pdPASS;
     2a2:	01 c0       	rjmp	.+2      	; 0x2a6 <xSerialPutChar+0x32>
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
	{
		return pdFAIL;
     2a4:	80 e0       	ldi	r24, 0x00	; 0
	}

	vInterruptOn();

	return pdPASS;
}
     2a6:	0f 90       	pop	r0
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	08 95       	ret

000002ae <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
     2ae:	0f b6       	in	r0, 0x3f	; 63
     2b0:	f8 94       	cli
     2b2:	0f 92       	push	r0
	{
		vInterruptOff();
     2b4:	e1 ec       	ldi	r30, 0xC1	; 193
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	8f 7d       	andi	r24, 0xDF	; 223
     2bc:	80 83       	st	Z, r24
		ucByte = UCSR0B;
     2be:	80 81       	ld	r24, Z
		ucByte &= ~serRX_INT_ENABLE;
     2c0:	8f 77       	andi	r24, 0x7F	; 127
		UCSR0B = ucByte;
     2c2:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     2c4:	0f 90       	pop	r0
     2c6:	0f be       	out	0x3f, r0	; 63
     2c8:	08 95       	ret

000002ca <SIG_UART_RECV>:
}
/*-----------------------------------------------------------*/

SIGNAL( SIG_UART_RECV )
{
     2ca:	1f 92       	push	r1
     2cc:	0f 92       	push	r0
     2ce:	0f b6       	in	r0, 0x3f	; 63
     2d0:	0f 92       	push	r0
     2d2:	11 24       	eor	r1, r1
     2d4:	2f 93       	push	r18
     2d6:	3f 93       	push	r19
     2d8:	4f 93       	push	r20
     2da:	5f 93       	push	r21
     2dc:	6f 93       	push	r22
     2de:	7f 93       	push	r23
     2e0:	8f 93       	push	r24
     2e2:	9f 93       	push	r25
     2e4:	af 93       	push	r26
     2e6:	bf 93       	push	r27
     2e8:	ef 93       	push	r30
     2ea:	ff 93       	push	r31
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	00 d0       	rcall	.+0      	; 0x2f2 <SIG_UART_RECV+0x28>
     2f2:	cd b7       	in	r28, 0x3d	; 61
     2f4:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     2f6:	19 82       	std	Y+1, r1	; 0x01

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
     2f8:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     2fc:	8a 83       	std	Y+2, r24	; 0x02

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     2fe:	20 e0       	ldi	r18, 0x00	; 0
     300:	ae 01       	movw	r20, r28
     302:	4f 5f       	subi	r20, 0xFF	; 255
     304:	5f 4f       	sbci	r21, 0xFF	; 255
     306:	be 01       	movw	r22, r28
     308:	6e 5f       	subi	r22, 0xFE	; 254
     30a:	7f 4f       	sbci	r23, 0xFF	; 255
     30c:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <xRxedChars>
     310:	90 91 54 01 	lds	r25, 0x0154	; 0x800154 <xRxedChars+0x1>
     314:	0e 94 2e 0c 	call	0x185c	; 0x185c <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     318:	89 81       	ldd	r24, Y+1	; 0x01
     31a:	81 11       	cpse	r24, r1
	{
		taskYIELD();
     31c:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
	}
}
     320:	0f 90       	pop	r0
     322:	0f 90       	pop	r0
     324:	df 91       	pop	r29
     326:	cf 91       	pop	r28
     328:	ff 91       	pop	r31
     32a:	ef 91       	pop	r30
     32c:	bf 91       	pop	r27
     32e:	af 91       	pop	r26
     330:	9f 91       	pop	r25
     332:	8f 91       	pop	r24
     334:	7f 91       	pop	r23
     336:	6f 91       	pop	r22
     338:	5f 91       	pop	r21
     33a:	4f 91       	pop	r20
     33c:	3f 91       	pop	r19
     33e:	2f 91       	pop	r18
     340:	0f 90       	pop	r0
     342:	0f be       	out	0x3f, r0	; 63
     344:	0f 90       	pop	r0
     346:	1f 90       	pop	r1
     348:	18 95       	reti

0000034a <SIG_UART_DATA>:
/*-----------------------------------------------------------*/

SIGNAL( SIG_UART_DATA )
{
     34a:	1f 92       	push	r1
     34c:	0f 92       	push	r0
     34e:	0f b6       	in	r0, 0x3f	; 63
     350:	0f 92       	push	r0
     352:	11 24       	eor	r1, r1
     354:	2f 93       	push	r18
     356:	3f 93       	push	r19
     358:	4f 93       	push	r20
     35a:	5f 93       	push	r21
     35c:	6f 93       	push	r22
     35e:	7f 93       	push	r23
     360:	8f 93       	push	r24
     362:	9f 93       	push	r25
     364:	af 93       	push	r26
     366:	bf 93       	push	r27
     368:	ef 93       	push	r30
     36a:	ff 93       	push	r31
     36c:	cf 93       	push	r28
     36e:	df 93       	push	r29
     370:	00 d0       	rcall	.+0      	; 0x372 <SIG_UART_DATA+0x28>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     376:	ae 01       	movw	r20, r28
     378:	4f 5f       	subi	r20, 0xFF	; 255
     37a:	5f 4f       	sbci	r21, 0xFF	; 255
     37c:	be 01       	movw	r22, r28
     37e:	6e 5f       	subi	r22, 0xFE	; 254
     380:	7f 4f       	sbci	r23, 0xFF	; 255
     382:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <xCharsForTx>
     386:	90 91 52 01 	lds	r25, 0x0152	; 0x800152 <xCharsForTx+0x1>
     38a:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <xQueueReceiveFromISR>
     38e:	81 30       	cpi	r24, 0x01	; 1
     390:	21 f4       	brne	.+8      	; 0x39a <SIG_UART_DATA+0x50>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
     392:	8a 81       	ldd	r24, Y+2	; 0x02
     394:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     398:	05 c0       	rjmp	.+10     	; 0x3a4 <SIG_UART_DATA+0x5a>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     39a:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     39e:	8f 7d       	andi	r24, 0xDF	; 223
     3a0:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	}
}
     3a4:	0f 90       	pop	r0
     3a6:	0f 90       	pop	r0
     3a8:	df 91       	pop	r29
     3aa:	cf 91       	pop	r28
     3ac:	ff 91       	pop	r31
     3ae:	ef 91       	pop	r30
     3b0:	bf 91       	pop	r27
     3b2:	af 91       	pop	r26
     3b4:	9f 91       	pop	r25
     3b6:	8f 91       	pop	r24
     3b8:	7f 91       	pop	r23
     3ba:	6f 91       	pop	r22
     3bc:	5f 91       	pop	r21
     3be:	4f 91       	pop	r20
     3c0:	3f 91       	pop	r19
     3c2:	2f 91       	pop	r18
     3c4:	0f 90       	pop	r0
     3c6:	0f be       	out	0x3f, r0	; 63
     3c8:	0f 90       	pop	r0
     3ca:	1f 90       	pop	r1
     3cc:	18 95       	reti

000003ce <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);
     3ce:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     3d0:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     3d2:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     3d4:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     3d6:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     3d8:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     3da:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     3dc:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     3de:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     3e0:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     3e2:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     3e4:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     3e6:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     3e8:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     3ea:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     3ec:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     3ee:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     3f0:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     3f2:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     3f4:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     3f6:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     3f8:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     3fa:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     3fc:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     3fe:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     400:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     402:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     404:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     406:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     408:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     40a:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     40c:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     40e:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     410:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     412:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     414:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     416:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     418:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     41a:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     41c:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     41e:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     420:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     422:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     424:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     426:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     428:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     42a:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     42c:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	6"			);
     430:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     432:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     434:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	7"			);
     438:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     43a:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     43c:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	8"			);
     440:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     442:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     444:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	9"			);
     448:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     44a:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     44c:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	10"			);
     450:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     452:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     454:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	11"			);
     458:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     45a:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     45c:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	12"			);
     460:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     462:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     464:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	13"			);
     468:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     46a:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     46c:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	14"			);
     470:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     472:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     474:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	15"			);
     478:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     47a:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     47c:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	16"			);
     480:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     482:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     484:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	17"			);
     488:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     48a:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     48c:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	18"			);
     490:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     492:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     494:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	19"			);
     498:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     49a:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     49c:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	20"			);
     4a0:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     4a2:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     4a4:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	21"			);
     4a8:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     4aa:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     4ac:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	22"			);
     4b0:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     4b2:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     4b4:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	23"			);
     4b8:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     4ba:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     4bc:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	24"			);
     4c0:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     4c2:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     4c4:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	25"			);
     4c8:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     4ca:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     4cc:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	26"			);
     4d0:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     4d2:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     4d4:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	27"			);
     4d8:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     4da:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     4dc:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	28"			);
     4e0:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     4e2:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     4e4:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	29"			);
     4e8:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     4ea:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     4ec:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	30"			);
     4f0:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     4f2:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     4f4:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	31"			);
     4f8:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     4fa:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     4fc:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	32"			);
     500:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     502:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     504:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	33"			);
     508:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     50a:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     50c:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
     510:	5e cf       	rjmp	.-324    	; 0x3ce <prvRegisterCheck1>

00000512 <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);
     512:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     514:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     516:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     518:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     51a:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     51c:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     51e:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     520:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     522:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     524:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     526:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     528:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     52a:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     52c:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     52e:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     530:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     532:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     534:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     536:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     538:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     53a:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     53c:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     53e:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     540:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     542:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     544:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     546:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     548:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     54a:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     54c:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     54e:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     550:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     552:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     554:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     556:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     558:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     55a:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     55c:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     55e:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     560:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     562:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     564:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     566:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     568:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     56a:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     56c:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     56e:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     570:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	2"			);
     574:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     576:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     578:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	3"			);
     57c:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     57e:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     580:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	4"			);
     584:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     586:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     588:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	5"			);
     58c:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     58e:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     590:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	6"			);
     594:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     596:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     598:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	7"			);
     59c:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     59e:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     5a0:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	8"			);
     5a4:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     5a6:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     5a8:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	9"			);
     5ac:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     5ae:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     5b0:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	10"			);
     5b4:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     5b6:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     5b8:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	11"			);
     5bc:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     5be:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     5c0:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	12"			);
     5c4:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     5c6:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     5c8:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	13"			);
     5cc:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     5ce:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     5d0:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	14"			);
     5d4:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     5d6:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     5d8:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	15"			);
     5dc:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     5de:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     5e0:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	16"			);
     5e4:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     5e6:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     5e8:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	17"			);
     5ec:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     5ee:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     5f0:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	18"			);
     5f4:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     5f6:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     5f8:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	19"			);
     5fc:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     5fe:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     600:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	20"			);
     604:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     606:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     608:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	21"			);
     60c:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     60e:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     610:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	22"			);
     614:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     616:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     618:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	23"			);
     61c:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     61e:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     620:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	24"			);
     624:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     626:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     628:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	25"			);
     62c:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     62e:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     630:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	26"			);
     634:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     636:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     638:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	27"			);
     63c:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     63e:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     640:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	28"			);
     644:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     646:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     648:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
		asm(	"LDI	r31,	29"			);
     64c:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     64e:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     650:	00 92 55 01 	sts	0x0155, r0	; 0x800155 <xRegTestError>
     654:	5e cf       	rjmp	.-324    	; 0x512 <prvRegisterCheck2>

00000656 <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     656:	ef 92       	push	r14
     658:	ff 92       	push	r15
     65a:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     65c:	e1 2c       	mov	r14, r1
     65e:	f1 2c       	mov	r15, r1
     660:	00 e0       	ldi	r16, 0x00	; 0
     662:	20 e0       	ldi	r18, 0x00	; 0
     664:	30 e0       	ldi	r19, 0x00	; 0
     666:	45 e5       	ldi	r20, 0x55	; 85
     668:	50 e0       	ldi	r21, 0x00	; 0
     66a:	6c e1       	ldi	r22, 0x1C	; 28
     66c:	71 e0       	ldi	r23, 0x01	; 1
     66e:	87 ee       	ldi	r24, 0xE7	; 231
     670:	91 e0       	ldi	r25, 0x01	; 1
     672:	0e 94 db 03 	call	0x7b6	; 0x7b6 <xTaskCreate>
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     676:	20 e0       	ldi	r18, 0x00	; 0
     678:	30 e0       	ldi	r19, 0x00	; 0
     67a:	45 e5       	ldi	r20, 0x55	; 85
     67c:	50 e0       	ldi	r21, 0x00	; 0
     67e:	61 e2       	ldi	r22, 0x21	; 33
     680:	71 e0       	ldi	r23, 0x01	; 1
     682:	89 e8       	ldi	r24, 0x89	; 137
     684:	92 e0       	ldi	r25, 0x02	; 2
     686:	0e 94 db 03 	call	0x7b6	; 0x7b6 <xTaskCreate>
}
     68a:	0f 91       	pop	r16
     68c:	ff 90       	pop	r15
     68e:	ef 90       	pop	r14
     690:	08 95       	ret

00000692 <xAreRegTestTasksStillRunning>:
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
     692:	81 e0       	ldi	r24, 0x01	; 1
     694:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <xRegTestError>
     698:	91 11       	cpse	r25, r1
     69a:	80 e0       	ldi	r24, 0x00	; 0
}
     69c:	08 95       	ret

0000069e <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     69e:	e0 91 7c 01 	lds	r30, 0x017C	; 0x80017c <pxDelayedTaskList>
     6a2:	f0 91 7d 01 	lds	r31, 0x017D	; 0x80017d <pxDelayedTaskList+0x1>
     6a6:	80 81       	ld	r24, Z
     6a8:	81 11       	cpse	r24, r1
     6aa:	03 c0       	rjmp	.+6      	; 0x6b2 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     6ac:	8f ef       	ldi	r24, 0xFF	; 255
     6ae:	9f ef       	ldi	r25, 0xFF	; 255
     6b0:	0c c0       	rjmp	.+24     	; 0x6ca <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     6b2:	e0 91 7c 01 	lds	r30, 0x017C	; 0x80017c <pxDelayedTaskList>
     6b6:	f0 91 7d 01 	lds	r31, 0x017D	; 0x80017d <pxDelayedTaskList+0x1>
     6ba:	05 80       	ldd	r0, Z+5	; 0x05
     6bc:	f6 81       	ldd	r31, Z+6	; 0x06
     6be:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     6c0:	06 80       	ldd	r0, Z+6	; 0x06
     6c2:	f7 81       	ldd	r31, Z+7	; 0x07
     6c4:	e0 2d       	mov	r30, r0
     6c6:	82 81       	ldd	r24, Z+2	; 0x02
     6c8:	93 81       	ldd	r25, Z+3	; 0x03
     6ca:	90 93 5c 01 	sts	0x015C, r25	; 0x80015c <xNextTaskUnblockTime+0x1>
     6ce:	80 93 5b 01 	sts	0x015B, r24	; 0x80015b <xNextTaskUnblockTime>
     6d2:	08 95       	ret

000006d4 <prvAddCurrentTaskToDelayedList.isra.2>:
	}

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
     6d4:	0f 93       	push	r16
     6d6:	1f 93       	push	r17
     6d8:	cf 93       	push	r28
     6da:	df 93       	push	r29
     6dc:	ec 01       	movw	r28, r24
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     6de:	00 91 64 01 	lds	r16, 0x0164	; 0x800164 <xTickCount>
     6e2:	10 91 65 01 	lds	r17, 0x0165	; 0x800165 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     6e6:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <pxCurrentTCB>
     6ea:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     6ee:	02 96       	adiw	r24, 0x02	; 2
     6f0:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
     6f4:	c0 0f       	add	r28, r16
     6f6:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     6f8:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
     6fc:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     700:	d3 83       	std	Z+3, r29	; 0x03
     702:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     704:	60 91 56 01 	lds	r22, 0x0156	; 0x800156 <pxCurrentTCB>
     708:	70 91 57 01 	lds	r23, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
		xTimeToWake = xConstTickCount + xTicksToWait;

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

		if( xTimeToWake < xConstTickCount )
     70c:	c0 17       	cp	r28, r16
     70e:	d1 07       	cpc	r29, r17
     710:	60 f4       	brcc	.+24     	; 0x72a <prvAddCurrentTaskToDelayedList.isra.2+0x56>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     712:	80 91 7a 01 	lds	r24, 0x017A	; 0x80017a <pxOverflowDelayedTaskList>
     716:	90 91 7b 01 	lds	r25, 0x017B	; 0x80017b <pxOverflowDelayedTaskList+0x1>
     71a:	6e 5f       	subi	r22, 0xFE	; 254
     71c:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     71e:	df 91       	pop	r29
     720:	cf 91       	pop	r28
     722:	1f 91       	pop	r17
     724:	0f 91       	pop	r16
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

		if( xTimeToWake < xConstTickCount )
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     726:	0c 94 a6 0f 	jmp	0x1f4c	; 0x1f4c <vListInsert>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     72a:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <pxDelayedTaskList>
     72e:	90 91 7d 01 	lds	r25, 0x017D	; 0x80017d <pxDelayedTaskList+0x1>
     732:	6e 5f       	subi	r22, 0xFE	; 254
     734:	7f 4f       	sbci	r23, 0xFF	; 255
     736:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
     73a:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <xNextTaskUnblockTime>
     73e:	90 91 5c 01 	lds	r25, 0x015C	; 0x80015c <xNextTaskUnblockTime+0x1>
     742:	c8 17       	cp	r28, r24
     744:	d9 07       	cpc	r29, r25
     746:	20 f4       	brcc	.+8      	; 0x750 <prvAddCurrentTaskToDelayedList.isra.2+0x7c>
			{
				xNextTaskUnblockTime = xTimeToWake;
     748:	d0 93 5c 01 	sts	0x015C, r29	; 0x80015c <xNextTaskUnblockTime+0x1>
     74c:	c0 93 5b 01 	sts	0x015B, r28	; 0x80015b <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	1f 91       	pop	r17
     756:	0f 91       	pop	r16
     758:	08 95       	ret

0000075a <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     75a:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <uxDeletedTasksWaitingCleanUp>
     75e:	88 23       	and	r24, r24
     760:	09 f1       	breq	.+66     	; 0x7a4 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     762:	0f b6       	in	r0, 0x3f	; 63
     764:	f8 94       	cli
     766:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     768:	e0 91 6d 01 	lds	r30, 0x016D	; 0x80016d <xTasksWaitingTermination+0x5>
     76c:	f0 91 6e 01 	lds	r31, 0x016E	; 0x80016e <xTasksWaitingTermination+0x6>
     770:	c6 81       	ldd	r28, Z+6	; 0x06
     772:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     774:	ce 01       	movw	r24, r28
     776:	02 96       	adiw	r24, 0x02	; 2
     778:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
				--uxCurrentNumberOfTasks;
     77c:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <uxCurrentNumberOfTasks>
     780:	81 50       	subi	r24, 0x01	; 1
     782:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     786:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <uxDeletedTasksWaitingCleanUp>
     78a:	81 50       	subi	r24, 0x01	; 1
     78c:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     790:	0f 90       	pop	r0
     792:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     794:	8f 89       	ldd	r24, Y+23	; 0x17
     796:	98 8d       	ldd	r25, Y+24	; 0x18
     798:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <vPortFree>
			vPortFree( pxTCB );
     79c:	ce 01       	movw	r24, r28
     79e:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <vPortFree>
     7a2:	db cf       	rjmp	.-74     	; 0x75a <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     7a4:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <pxReadyTasksLists>
     7a8:	82 30       	cpi	r24, 0x02	; 2
     7aa:	10 f0       	brcs	.+4      	; 0x7b0 <prvIdleTask+0x56>
			{
				taskYIELD();
     7ac:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     7b0:	0e 94 8b 00 	call	0x116	; 0x116 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     7b4:	d2 cf       	rjmp	.-92     	; 0x75a <prvIdleTask>

000007b6 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     7b6:	4f 92       	push	r4
     7b8:	5f 92       	push	r5
     7ba:	6f 92       	push	r6
     7bc:	7f 92       	push	r7
     7be:	8f 92       	push	r8
     7c0:	9f 92       	push	r9
     7c2:	af 92       	push	r10
     7c4:	bf 92       	push	r11
     7c6:	cf 92       	push	r12
     7c8:	df 92       	push	r13
     7ca:	ef 92       	push	r14
     7cc:	ff 92       	push	r15
     7ce:	0f 93       	push	r16
     7d0:	cf 93       	push	r28
     7d2:	df 93       	push	r29
     7d4:	4c 01       	movw	r8, r24
     7d6:	6b 01       	movw	r12, r22
     7d8:	5a 01       	movw	r10, r20
     7da:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     7dc:	ca 01       	movw	r24, r20
     7de:	0e 94 c8 11 	call	0x2390	; 0x2390 <pvPortMalloc>
     7e2:	3c 01       	movw	r6, r24

			if( pxStack != NULL )
     7e4:	89 2b       	or	r24, r25
     7e6:	09 f4       	brne	.+2      	; 0x7ea <xTaskCreate+0x34>
     7e8:	d0 c0       	rjmp	.+416    	; 0x98a <__stack+0x8b>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     7ea:	86 e2       	ldi	r24, 0x26	; 38
     7ec:	90 e0       	ldi	r25, 0x00	; 0
     7ee:	0e 94 c8 11 	call	0x2390	; 0x2390 <pvPortMalloc>
     7f2:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     7f4:	00 97       	sbiw	r24, 0x00	; 0
     7f6:	89 f0       	breq	.+34     	; 0x81a <xTaskCreate+0x64>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     7f8:	78 8e       	std	Y+24, r7	; 0x18
     7fa:	6f 8a       	std	Y+23, r6	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     7fc:	21 e0       	ldi	r18, 0x01	; 1
     7fe:	a2 1a       	sub	r10, r18
     800:	b1 08       	sbc	r11, r1
     802:	a6 0c       	add	r10, r6
     804:	b7 1c       	adc	r11, r7
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
     806:	c1 14       	cp	r12, r1
     808:	d1 04       	cpc	r13, r1
     80a:	c9 f0       	breq	.+50     	; 0x83e <xTaskCreate+0x88>
     80c:	bc 01       	movw	r22, r24
     80e:	67 5e       	subi	r22, 0xE7	; 231
     810:	7f 4f       	sbci	r23, 0xFF	; 255
     812:	f6 01       	movw	r30, r12
     814:	c6 01       	movw	r24, r12
     816:	08 96       	adiw	r24, 0x08	; 8
     818:	07 c0       	rjmp	.+14     	; 0x828 <xTaskCreate+0x72>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     81a:	c3 01       	movw	r24, r6
     81c:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <vPortFree>
     820:	b4 c0       	rjmp	.+360    	; 0x98a <__stack+0x8b>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     822:	e8 17       	cp	r30, r24
     824:	f9 07       	cpc	r31, r25
     826:	49 f0       	breq	.+18     	; 0x83a <xTaskCreate+0x84>
     828:	9f 01       	movw	r18, r30
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     82a:	41 91       	ld	r20, Z+
     82c:	db 01       	movw	r26, r22
     82e:	4d 93       	st	X+, r20
     830:	bd 01       	movw	r22, r26

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
     832:	d9 01       	movw	r26, r18
     834:	2c 91       	ld	r18, X
     836:	21 11       	cpse	r18, r1
     838:	f4 cf       	rjmp	.-24     	; 0x822 <xTaskCreate+0x6c>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     83a:	18 a2       	std	Y+32, r1	; 0x20
     83c:	01 c0       	rjmp	.+2      	; 0x840 <xTaskCreate+0x8a>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
     83e:	19 8e       	std	Y+25, r1	; 0x19
     840:	04 30       	cpi	r16, 0x04	; 4
     842:	08 f0       	brcs	.+2      	; 0x846 <xTaskCreate+0x90>
     844:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     846:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     848:	6e 01       	movw	r12, r28
     84a:	b2 e0       	ldi	r27, 0x02	; 2
     84c:	cb 0e       	add	r12, r27
     84e:	d1 1c       	adc	r13, r1
     850:	c6 01       	movw	r24, r12
     852:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     856:	ce 01       	movw	r24, r28
     858:	0c 96       	adiw	r24, 0x0c	; 12
     85a:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     85e:	d9 87       	std	Y+9, r29	; 0x09
     860:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     862:	84 e0       	ldi	r24, 0x04	; 4
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	80 1b       	sub	r24, r16
     868:	91 09       	sbc	r25, r1
     86a:	9d 87       	std	Y+13, r25	; 0x0d
     86c:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     86e:	db 8b       	std	Y+19, r29	; 0x13
     870:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     872:	19 a2       	std	Y+33, r1	; 0x21
     874:	1a a2       	std	Y+34, r1	; 0x22
     876:	1b a2       	std	Y+35, r1	; 0x23
     878:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     87a:	1d a2       	std	Y+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     87c:	a2 01       	movw	r20, r4
     87e:	b4 01       	movw	r22, r8
     880:	c5 01       	movw	r24, r10
     882:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <pxPortInitialiseStack>
     886:	99 83       	std	Y+1, r25	; 0x01
     888:	88 83       	st	Y, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     88a:	e1 14       	cp	r14, r1
     88c:	f1 04       	cpc	r15, r1
     88e:	19 f0       	breq	.+6      	; 0x896 <xTaskCreate+0xe0>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     890:	f7 01       	movw	r30, r14
     892:	d1 83       	std	Z+1, r29	; 0x01
     894:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     896:	0f b6       	in	r0, 0x3f	; 63
     898:	f8 94       	cli
     89a:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     89c:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <uxCurrentNumberOfTasks>
     8a0:	8f 5f       	subi	r24, 0xFF	; 255
     8a2:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     8a6:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <pxCurrentTCB>
     8aa:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     8ae:	89 2b       	or	r24, r25
     8b0:	a9 f5       	brne	.+106    	; 0x91c <__stack+0x1d>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     8b2:	d0 93 57 01 	sts	0x0157, r29	; 0x800157 <pxCurrentTCB+0x1>
     8b6:	c0 93 56 01 	sts	0x0156, r28	; 0x800156 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     8ba:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <uxCurrentNumberOfTasks>
     8be:	81 30       	cpi	r24, 0x01	; 1
     8c0:	e9 f5       	brne	.+122    	; 0x93c <__stack+0x3d>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     8c2:	80 e9       	ldi	r24, 0x90	; 144
     8c4:	91 e0       	ldi	r25, 0x01	; 1
     8c6:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
     8ca:	89 e9       	ldi	r24, 0x99	; 153
     8cc:	91 e0       	ldi	r25, 0x01	; 1
     8ce:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
     8d2:	82 ea       	ldi	r24, 0xA2	; 162
     8d4:	91 e0       	ldi	r25, 0x01	; 1
     8d6:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
     8da:	8b ea       	ldi	r24, 0xAB	; 171
     8dc:	91 e0       	ldi	r25, 0x01	; 1
     8de:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     8e2:	87 e8       	ldi	r24, 0x87	; 135
     8e4:	91 e0       	ldi	r25, 0x01	; 1
     8e6:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     8ea:	8e e7       	ldi	r24, 0x7E	; 126
     8ec:	91 e0       	ldi	r25, 0x01	; 1
     8ee:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     8f2:	81 e7       	ldi	r24, 0x71	; 113
     8f4:	91 e0       	ldi	r25, 0x01	; 1
     8f6:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     8fa:	88 e6       	ldi	r24, 0x68	; 104
     8fc:	91 e0       	ldi	r25, 0x01	; 1
     8fe:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     902:	87 e8       	ldi	r24, 0x87	; 135
     904:	91 e0       	ldi	r25, 0x01	; 1
     906:	90 93 7d 01 	sts	0x017D, r25	; 0x80017d <pxDelayedTaskList+0x1>
     90a:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     90e:	8e e7       	ldi	r24, 0x7E	; 126
     910:	91 e0       	ldi	r25, 0x01	; 1
     912:	90 93 7b 01 	sts	0x017B, r25	; 0x80017b <pxOverflowDelayedTaskList+0x1>
     916:	80 93 7a 01 	sts	0x017A, r24	; 0x80017a <pxOverflowDelayedTaskList>
     91a:	10 c0       	rjmp	.+32     	; 0x93c <__stack+0x3d>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     91c:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <xSchedulerRunning>
     920:	81 11       	cpse	r24, r1
     922:	0c c0       	rjmp	.+24     	; 0x93c <__stack+0x3d>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     924:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
     928:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     92c:	96 89       	ldd	r25, Z+22	; 0x16
     92e:	8e 89       	ldd	r24, Y+22	; 0x16
     930:	89 17       	cp	r24, r25
     932:	20 f0       	brcs	.+8      	; 0x93c <__stack+0x3d>
				{
					pxCurrentTCB = pxNewTCB;
     934:	d0 93 57 01 	sts	0x0157, r29	; 0x800157 <pxCurrentTCB+0x1>
     938:	c0 93 56 01 	sts	0x0156, r28	; 0x800156 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     93c:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <uxTaskNumber>
     940:	8f 5f       	subi	r24, 0xFF	; 255
     942:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     946:	8e 89       	ldd	r24, Y+22	; 0x16
     948:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <uxTopReadyPriority>
     94c:	98 17       	cp	r25, r24
     94e:	10 f4       	brcc	.+4      	; 0x954 <__stack+0x55>
     950:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <uxTopReadyPriority>
     954:	f9 e0       	ldi	r31, 0x09	; 9
     956:	8f 9f       	mul	r24, r31
     958:	c0 01       	movw	r24, r0
     95a:	11 24       	eor	r1, r1
     95c:	b6 01       	movw	r22, r12
     95e:	80 57       	subi	r24, 0x70	; 112
     960:	9e 4f       	sbci	r25, 0xFE	; 254
     962:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     966:	0f 90       	pop	r0
     968:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     96a:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <xSchedulerRunning>
     96e:	88 23       	and	r24, r24
     970:	51 f0       	breq	.+20     	; 0x986 <__stack+0x87>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     972:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
     976:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     97a:	96 89       	ldd	r25, Z+22	; 0x16
     97c:	8e 89       	ldd	r24, Y+22	; 0x16
     97e:	98 17       	cp	r25, r24
     980:	10 f4       	brcc	.+4      	; 0x986 <__stack+0x87>
		{
			taskYIELD_IF_USING_PREEMPTION();
     982:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	01 c0       	rjmp	.+2      	; 0x98c <__stack+0x8d>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     98a:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     98c:	df 91       	pop	r29
     98e:	cf 91       	pop	r28
     990:	0f 91       	pop	r16
     992:	ff 90       	pop	r15
     994:	ef 90       	pop	r14
     996:	df 90       	pop	r13
     998:	cf 90       	pop	r12
     99a:	bf 90       	pop	r11
     99c:	af 90       	pop	r10
     99e:	9f 90       	pop	r9
     9a0:	8f 90       	pop	r8
     9a2:	7f 90       	pop	r7
     9a4:	6f 90       	pop	r6
     9a6:	5f 90       	pop	r5
     9a8:	4f 90       	pop	r4
     9aa:	08 95       	ret

000009ac <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     9ac:	0f 93       	push	r16
     9ae:	1f 93       	push	r17
     9b0:	cf 93       	push	r28
     9b2:	df 93       	push	r29
     9b4:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     9b6:	0f b6       	in	r0, 0x3f	; 63
     9b8:	f8 94       	cli
     9ba:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     9bc:	89 2b       	or	r24, r25
     9be:	21 f4       	brne	.+8      	; 0x9c8 <vTaskDelete+0x1c>
     9c0:	c0 91 56 01 	lds	r28, 0x0156	; 0x800156 <pxCurrentTCB>
     9c4:	d0 91 57 01 	lds	r29, 0x0157	; 0x800157 <pxCurrentTCB+0x1>

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     9c8:	8e 01       	movw	r16, r28
     9ca:	0e 5f       	subi	r16, 0xFE	; 254
     9cc:	1f 4f       	sbci	r17, 0xFF	; 255
     9ce:	c8 01       	movw	r24, r16
     9d0:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     9d4:	8c 89       	ldd	r24, Y+20	; 0x14
     9d6:	9d 89       	ldd	r25, Y+21	; 0x15
     9d8:	89 2b       	or	r24, r25
     9da:	21 f0       	breq	.+8      	; 0x9e4 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     9dc:	ce 01       	movw	r24, r28
     9de:	0c 96       	adiw	r24, 0x0c	; 12
     9e0:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     9e4:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <uxTaskNumber>
     9e8:	8f 5f       	subi	r24, 0xFF	; 255
     9ea:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     9ee:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <pxCurrentTCB>
     9f2:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     9f6:	c8 17       	cp	r28, r24
     9f8:	d9 07       	cpc	r29, r25
     9fa:	59 f4       	brne	.+22     	; 0xa12 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     9fc:	b8 01       	movw	r22, r16
     9fe:	88 e6       	ldi	r24, 0x68	; 104
     a00:	91 e0       	ldi	r25, 0x01	; 1
     a02:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     a06:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <uxDeletedTasksWaitingCleanUp>
     a0a:	8f 5f       	subi	r24, 0xFF	; 255
     a0c:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <uxDeletedTasksWaitingCleanUp>
     a10:	0e c0       	rjmp	.+28     	; 0xa2e <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     a12:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <uxCurrentNumberOfTasks>
     a16:	81 50       	subi	r24, 0x01	; 1
     a18:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     a1c:	8f 89       	ldd	r24, Y+23	; 0x17
     a1e:	98 8d       	ldd	r25, Y+24	; 0x18
     a20:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <vPortFree>
			vPortFree( pxTCB );
     a24:	ce 01       	movw	r24, r28
     a26:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <vPortFree>
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     a2a:	0e 94 4f 03 	call	0x69e	; 0x69e <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
     a2e:	0f 90       	pop	r0
     a30:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     a32:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <xSchedulerRunning>
     a36:	88 23       	and	r24, r24
     a38:	49 f0       	breq	.+18     	; 0xa4c <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     a3a:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <pxCurrentTCB>
     a3e:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     a42:	c8 17       	cp	r28, r24
     a44:	d9 07       	cpc	r29, r25
     a46:	11 f4       	brne	.+4      	; 0xa4c <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     a48:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	1f 91       	pop	r17
     a52:	0f 91       	pop	r16
     a54:	08 95       	ret

00000a56 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     a56:	ef 92       	push	r14
     a58:	ff 92       	push	r15
     a5a:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     a5c:	89 e5       	ldi	r24, 0x59	; 89
     a5e:	e8 2e       	mov	r14, r24
     a60:	81 e0       	ldi	r24, 0x01	; 1
     a62:	f8 2e       	mov	r15, r24
     a64:	00 e0       	ldi	r16, 0x00	; 0
     a66:	20 e0       	ldi	r18, 0x00	; 0
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	45 e5       	ldi	r20, 0x55	; 85
     a6c:	50 e0       	ldi	r21, 0x00	; 0
     a6e:	66 e2       	ldi	r22, 0x26	; 38
     a70:	71 e0       	ldi	r23, 0x01	; 1
     a72:	8d ea       	ldi	r24, 0xAD	; 173
     a74:	93 e0       	ldi	r25, 0x03	; 3
     a76:	0e 94 db 03 	call	0x7b6	; 0x7b6 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     a7a:	81 30       	cpi	r24, 0x01	; 1
     a7c:	91 f4       	brne	.+36     	; 0xaa2 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     a7e:	f8 94       	cli
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     a80:	2f ef       	ldi	r18, 0xFF	; 255
     a82:	3f ef       	ldi	r19, 0xFF	; 255
     a84:	30 93 5c 01 	sts	0x015C, r19	; 0x80015c <xNextTaskUnblockTime+0x1>
     a88:	20 93 5b 01 	sts	0x015B, r18	; 0x80015b <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     a8c:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     a90:	10 92 65 01 	sts	0x0165, r1	; 0x800165 <xTickCount+0x1>
     a94:	10 92 64 01 	sts	0x0164, r1	; 0x800164 <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     a98:	0f 91       	pop	r16
     a9a:	ff 90       	pop	r15
     a9c:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     a9e:	0c 94 e6 14 	jmp	0x29cc	; 0x29cc <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     aa2:	0f 91       	pop	r16
     aa4:	ff 90       	pop	r15
     aa6:	ef 90       	pop	r14
     aa8:	08 95       	ret

00000aaa <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     aaa:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     aac:	10 92 62 01 	sts	0x0162, r1	; 0x800162 <xSchedulerRunning>
	vPortEndScheduler();
     ab0:	0c 94 21 15 	jmp	0x2a42	; 0x2a42 <vPortEndScheduler>

00000ab4 <vTaskSuspendAll>:
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
     ab4:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <uxSchedulerSuspended>
     ab8:	8f 5f       	subi	r24, 0xFF	; 255
     aba:	80 93 58 01 	sts	0x0158, r24	; 0x800158 <uxSchedulerSuspended>
     abe:	08 95       	ret

00000ac0 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     ac0:	0f b6       	in	r0, 0x3f	; 63
     ac2:	f8 94       	cli
     ac4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     ac6:	80 91 64 01 	lds	r24, 0x0164	; 0x800164 <xTickCount>
     aca:	90 91 65 01 	lds	r25, 0x0165	; 0x800165 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     ace:	0f 90       	pop	r0
     ad0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     ad2:	08 95       	ret

00000ad4 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     ad4:	80 91 64 01 	lds	r24, 0x0164	; 0x800164 <xTickCount>
     ad8:	90 91 65 01 	lds	r25, 0x0165	; 0x800165 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     adc:	08 95       	ret

00000ade <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     ade:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <uxCurrentNumberOfTasks>
}
     ae2:	08 95       	ret

00000ae4 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     ae4:	00 97       	sbiw	r24, 0x00	; 0
     ae6:	21 f4       	brne	.+8      	; 0xaf0 <pcTaskGetName+0xc>
     ae8:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <pxCurrentTCB>
     aec:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     af0:	49 96       	adiw	r24, 0x19	; 25
     af2:	08 95       	ret

00000af4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     af4:	cf 92       	push	r12
     af6:	df 92       	push	r13
     af8:	ef 92       	push	r14
     afa:	ff 92       	push	r15
     afc:	0f 93       	push	r16
     afe:	1f 93       	push	r17
     b00:	cf 93       	push	r28
     b02:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     b04:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <uxSchedulerSuspended>
     b08:	81 11       	cpse	r24, r1
     b0a:	91 c0       	rjmp	.+290    	; 0xc2e <xTaskIncrementTick+0x13a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     b0c:	00 91 64 01 	lds	r16, 0x0164	; 0x800164 <xTickCount>
     b10:	10 91 65 01 	lds	r17, 0x0165	; 0x800165 <xTickCount+0x1>
     b14:	0f 5f       	subi	r16, 0xFF	; 255
     b16:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     b18:	10 93 65 01 	sts	0x0165, r17	; 0x800165 <xTickCount+0x1>
     b1c:	00 93 64 01 	sts	0x0164, r16	; 0x800164 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     b20:	01 15       	cp	r16, r1
     b22:	11 05       	cpc	r17, r1
     b24:	b9 f4       	brne	.+46     	; 0xb54 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     b26:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <pxDelayedTaskList>
     b2a:	90 91 7d 01 	lds	r25, 0x017D	; 0x80017d <pxDelayedTaskList+0x1>
     b2e:	20 91 7a 01 	lds	r18, 0x017A	; 0x80017a <pxOverflowDelayedTaskList>
     b32:	30 91 7b 01 	lds	r19, 0x017B	; 0x80017b <pxOverflowDelayedTaskList+0x1>
     b36:	30 93 7d 01 	sts	0x017D, r19	; 0x80017d <pxDelayedTaskList+0x1>
     b3a:	20 93 7c 01 	sts	0x017C, r18	; 0x80017c <pxDelayedTaskList>
     b3e:	90 93 7b 01 	sts	0x017B, r25	; 0x80017b <pxOverflowDelayedTaskList+0x1>
     b42:	80 93 7a 01 	sts	0x017A, r24	; 0x80017a <pxOverflowDelayedTaskList>
     b46:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <xNumOfOverflows>
     b4a:	8f 5f       	subi	r24, 0xFF	; 255
     b4c:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <xNumOfOverflows>
     b50:	0e 94 4f 03 	call	0x69e	; 0x69e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     b54:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <xNextTaskUnblockTime>
     b58:	90 91 5c 01 	lds	r25, 0x015C	; 0x80015c <xNextTaskUnblockTime+0x1>
     b5c:	c0 e0       	ldi	r28, 0x00	; 0
     b5e:	08 17       	cp	r16, r24
     b60:	19 07       	cpc	r17, r25
     b62:	08 f4       	brcc	.+2      	; 0xb66 <xTaskIncrementTick+0x72>
     b64:	4f c0       	rjmp	.+158    	; 0xc04 <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     b66:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b68:	e0 91 7c 01 	lds	r30, 0x017C	; 0x80017c <pxDelayedTaskList>
     b6c:	f0 91 7d 01 	lds	r31, 0x017D	; 0x80017d <pxDelayedTaskList+0x1>
     b70:	80 81       	ld	r24, Z
     b72:	81 11       	cpse	r24, r1
     b74:	03 c0       	rjmp	.+6      	; 0xb7c <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b76:	8f ef       	ldi	r24, 0xFF	; 255
     b78:	9f ef       	ldi	r25, 0xFF	; 255
     b7a:	11 c0       	rjmp	.+34     	; 0xb9e <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     b7c:	e0 91 7c 01 	lds	r30, 0x017C	; 0x80017c <pxDelayedTaskList>
     b80:	f0 91 7d 01 	lds	r31, 0x017D	; 0x80017d <pxDelayedTaskList+0x1>
     b84:	05 80       	ldd	r0, Z+5	; 0x05
     b86:	f6 81       	ldd	r31, Z+6	; 0x06
     b88:	e0 2d       	mov	r30, r0
     b8a:	e6 80       	ldd	r14, Z+6	; 0x06
     b8c:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     b8e:	d7 01       	movw	r26, r14
     b90:	12 96       	adiw	r26, 0x02	; 2
     b92:	8d 91       	ld	r24, X+
     b94:	9c 91       	ld	r25, X
     b96:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     b98:	08 17       	cp	r16, r24
     b9a:	19 07       	cpc	r17, r25
     b9c:	28 f4       	brcc	.+10     	; 0xba8 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     b9e:	90 93 5c 01 	sts	0x015C, r25	; 0x80015c <xNextTaskUnblockTime+0x1>
     ba2:	80 93 5b 01 	sts	0x015B, r24	; 0x80015b <xNextTaskUnblockTime>
     ba6:	2e c0       	rjmp	.+92     	; 0xc04 <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     ba8:	67 01       	movw	r12, r14
     baa:	b2 e0       	ldi	r27, 0x02	; 2
     bac:	cb 0e       	add	r12, r27
     bae:	d1 1c       	adc	r13, r1
     bb0:	c6 01       	movw	r24, r12
     bb2:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     bb6:	f7 01       	movw	r30, r14
     bb8:	84 89       	ldd	r24, Z+20	; 0x14
     bba:	95 89       	ldd	r25, Z+21	; 0x15
     bbc:	89 2b       	or	r24, r25
     bbe:	21 f0       	breq	.+8      	; 0xbc8 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     bc0:	c7 01       	movw	r24, r14
     bc2:	0c 96       	adiw	r24, 0x0c	; 12
     bc4:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     bc8:	d7 01       	movw	r26, r14
     bca:	56 96       	adiw	r26, 0x16	; 22
     bcc:	8c 91       	ld	r24, X
     bce:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <uxTopReadyPriority>
     bd2:	98 17       	cp	r25, r24
     bd4:	10 f4       	brcc	.+4      	; 0xbda <xTaskIncrementTick+0xe6>
     bd6:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <uxTopReadyPriority>
     bda:	d8 9f       	mul	r29, r24
     bdc:	c0 01       	movw	r24, r0
     bde:	11 24       	eor	r1, r1
     be0:	b6 01       	movw	r22, r12
     be2:	80 57       	subi	r24, 0x70	; 112
     be4:	9e 4f       	sbci	r25, 0xFE	; 254
     be6:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bea:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
     bee:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     bf2:	d7 01       	movw	r26, r14
     bf4:	56 96       	adiw	r26, 0x16	; 22
     bf6:	9c 91       	ld	r25, X
     bf8:	86 89       	ldd	r24, Z+22	; 0x16
     bfa:	98 17       	cp	r25, r24
     bfc:	08 f4       	brcc	.+2      	; 0xc00 <xTaskIncrementTick+0x10c>
     bfe:	b4 cf       	rjmp	.-152    	; 0xb68 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     c00:	c1 e0       	ldi	r28, 0x01	; 1
     c02:	b2 cf       	rjmp	.-156    	; 0xb68 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     c04:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
     c08:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     c0c:	e6 89       	ldd	r30, Z+22	; 0x16
     c0e:	b9 e0       	ldi	r27, 0x09	; 9
     c10:	eb 9f       	mul	r30, r27
     c12:	f0 01       	movw	r30, r0
     c14:	11 24       	eor	r1, r1
     c16:	e0 57       	subi	r30, 0x70	; 112
     c18:	fe 4f       	sbci	r31, 0xFE	; 254
     c1a:	80 81       	ld	r24, Z
     c1c:	82 30       	cpi	r24, 0x02	; 2
     c1e:	08 f0       	brcs	.+2      	; 0xc22 <xTaskIncrementTick+0x12e>
			{
				xSwitchRequired = pdTRUE;
     c20:	c1 e0       	ldi	r28, 0x01	; 1
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
     c22:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <xYieldPending>
     c26:	88 23       	and	r24, r24
     c28:	61 f0       	breq	.+24     	; 0xc42 <xTaskIncrementTick+0x14e>
			{
				xSwitchRequired = pdTRUE;
     c2a:	c1 e0       	ldi	r28, 0x01	; 1
     c2c:	0a c0       	rjmp	.+20     	; 0xc42 <xTaskIncrementTick+0x14e>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
     c2e:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <xPendedTicks>
     c32:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <xPendedTicks+0x1>
     c36:	01 96       	adiw	r24, 0x01	; 1
     c38:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <xPendedTicks+0x1>
     c3c:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <xPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     c40:	c0 e0       	ldi	r28, 0x00	; 0
		}
		#endif
	}

	return xSwitchRequired;
}
     c42:	8c 2f       	mov	r24, r28
     c44:	df 91       	pop	r29
     c46:	cf 91       	pop	r28
     c48:	1f 91       	pop	r17
     c4a:	0f 91       	pop	r16
     c4c:	ff 90       	pop	r15
     c4e:	ef 90       	pop	r14
     c50:	df 90       	pop	r13
     c52:	cf 90       	pop	r12
     c54:	08 95       	ret

00000c56 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c56:	ef 92       	push	r14
     c58:	ff 92       	push	r15
     c5a:	0f 93       	push	r16
     c5c:	1f 93       	push	r17
     c5e:	cf 93       	push	r28
     c60:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c62:	0f b6       	in	r0, 0x3f	; 63
     c64:	f8 94       	cli
     c66:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c68:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <uxSchedulerSuspended>
     c6c:	81 50       	subi	r24, 0x01	; 1
     c6e:	80 93 58 01 	sts	0x0158, r24	; 0x800158 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c72:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <uxSchedulerSuspended>
     c76:	88 23       	and	r24, r24
     c78:	11 f0       	breq	.+4      	; 0xc7e <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     c7a:	80 e0       	ldi	r24, 0x00	; 0
     c7c:	56 c0       	rjmp	.+172    	; 0xd2a <xTaskResumeAll+0xd4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     c7e:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <uxCurrentNumberOfTasks>
     c82:	88 23       	and	r24, r24
     c84:	d1 f3       	breq	.-12     	; 0xc7a <xTaskResumeAll+0x24>
     c86:	c0 e0       	ldi	r28, 0x00	; 0
     c88:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     c8a:	89 e0       	ldi	r24, 0x09	; 9
     c8c:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     c8e:	ee 24       	eor	r14, r14
     c90:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     c92:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <xPendingReadyList>
     c96:	88 23       	and	r24, r24
     c98:	51 f1       	breq	.+84     	; 0xcee <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c9a:	e0 91 76 01 	lds	r30, 0x0176	; 0x800176 <xPendingReadyList+0x5>
     c9e:	f0 91 77 01 	lds	r31, 0x0177	; 0x800177 <xPendingReadyList+0x6>
     ca2:	c6 81       	ldd	r28, Z+6	; 0x06
     ca4:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     ca6:	ce 01       	movw	r24, r28
     ca8:	0c 96       	adiw	r24, 0x0c	; 12
     caa:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     cae:	8e 01       	movw	r16, r28
     cb0:	0e 5f       	subi	r16, 0xFE	; 254
     cb2:	1f 4f       	sbci	r17, 0xFF	; 255
     cb4:	c8 01       	movw	r24, r16
     cb6:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     cba:	8e 89       	ldd	r24, Y+22	; 0x16
     cbc:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <uxTopReadyPriority>
     cc0:	98 17       	cp	r25, r24
     cc2:	10 f4       	brcc	.+4      	; 0xcc8 <xTaskResumeAll+0x72>
     cc4:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <uxTopReadyPriority>
     cc8:	f8 9e       	mul	r15, r24
     cca:	c0 01       	movw	r24, r0
     ccc:	11 24       	eor	r1, r1
     cce:	b8 01       	movw	r22, r16
     cd0:	80 57       	subi	r24, 0x70	; 112
     cd2:	9e 4f       	sbci	r25, 0xFE	; 254
     cd4:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     cd8:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
     cdc:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     ce0:	9e 89       	ldd	r25, Y+22	; 0x16
     ce2:	86 89       	ldd	r24, Z+22	; 0x16
     ce4:	98 17       	cp	r25, r24
     ce6:	a8 f2       	brcs	.-86     	; 0xc92 <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     ce8:	e0 92 5f 01 	sts	0x015F, r14	; 0x80015f <xYieldPending>
     cec:	d2 cf       	rjmp	.-92     	; 0xc92 <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     cee:	cd 2b       	or	r28, r29
     cf0:	11 f0       	breq	.+4      	; 0xcf6 <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     cf2:	0e 94 4f 03 	call	0x69e	; 0x69e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
     cf6:	c0 91 60 01 	lds	r28, 0x0160	; 0x800160 <xPendedTicks>
     cfa:	d0 91 61 01 	lds	r29, 0x0161	; 0x800161 <xPendedTicks+0x1>

					if( xPendedCounts > ( TickType_t ) 0U )
     cfe:	20 97       	sbiw	r28, 0x00	; 0
     d00:	61 f0       	breq	.+24     	; 0xd1a <xTaskResumeAll+0xc4>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     d02:	11 e0       	ldi	r17, 0x01	; 1

					if( xPendedCounts > ( TickType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     d04:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <xTaskIncrementTick>
     d08:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     d0a:	10 93 5f 01 	sts	0x015F, r17	; 0x80015f <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
     d0e:	21 97       	sbiw	r28, 0x01	; 1
						} while( xPendedCounts > ( TickType_t ) 0U );
     d10:	c9 f7       	brne	.-14     	; 0xd04 <xTaskResumeAll+0xae>

						xPendedTicks = 0;
     d12:	10 92 61 01 	sts	0x0161, r1	; 0x800161 <xPendedTicks+0x1>
     d16:	10 92 60 01 	sts	0x0160, r1	; 0x800160 <xPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     d1a:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <xYieldPending>
     d1e:	88 23       	and	r24, r24
     d20:	09 f4       	brne	.+2      	; 0xd24 <xTaskResumeAll+0xce>
     d22:	ab cf       	rjmp	.-170    	; 0xc7a <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     d24:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     d28:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     d2a:	0f 90       	pop	r0
     d2c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	ef 90       	pop	r14
     d3a:	08 95       	ret

00000d3c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     d3c:	0f 93       	push	r16
     d3e:	1f 93       	push	r17
     d40:	cf 93       	push	r28
     d42:	df 93       	push	r29
     d44:	8c 01       	movw	r16, r24
     d46:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     d48:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     d4c:	40 91 64 01 	lds	r20, 0x0164	; 0x800164 <xTickCount>
     d50:	50 91 65 01 	lds	r21, 0x0165	; 0x800165 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     d54:	f8 01       	movw	r30, r16
     d56:	20 81       	ld	r18, Z
     d58:	31 81       	ldd	r19, Z+1	; 0x01
     d5a:	c9 01       	movw	r24, r18
     d5c:	8c 0f       	add	r24, r28
     d5e:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     d60:	42 17       	cp	r20, r18
     d62:	53 07       	cpc	r21, r19
     d64:	20 f4       	brcc	.+8      	; 0xd6e <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     d66:	82 17       	cp	r24, r18
     d68:	93 07       	cpc	r25, r19
     d6a:	40 f4       	brcc	.+16     	; 0xd7c <vTaskDelayUntil+0x40>
     d6c:	03 c0       	rjmp	.+6      	; 0xd74 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     d6e:	82 17       	cp	r24, r18
     d70:	93 07       	cpc	r25, r19
     d72:	30 f0       	brcs	.+12     	; 0xd80 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d74:	21 e0       	ldi	r18, 0x01	; 1
     d76:	48 17       	cp	r20, r24
     d78:	59 07       	cpc	r21, r25
     d7a:	18 f0       	brcs	.+6      	; 0xd82 <vTaskDelayUntil+0x46>
     d7c:	20 e0       	ldi	r18, 0x00	; 0
     d7e:	01 c0       	rjmp	.+2      	; 0xd82 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d80:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d82:	f8 01       	movw	r30, r16
     d84:	91 83       	std	Z+1, r25	; 0x01
     d86:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     d88:	22 23       	and	r18, r18
     d8a:	21 f0       	breq	.+8      	; 0xd94 <vTaskDelayUntil+0x58>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     d8c:	84 1b       	sub	r24, r20
     d8e:	95 0b       	sbc	r25, r21
     d90:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <prvAddCurrentTaskToDelayedList.isra.2>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     d94:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d98:	81 11       	cpse	r24, r1
     d9a:	02 c0       	rjmp	.+4      	; 0xda0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
     d9c:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     da0:	df 91       	pop	r29
     da2:	cf 91       	pop	r28
     da4:	1f 91       	pop	r17
     da6:	0f 91       	pop	r16
     da8:	08 95       	ret

00000daa <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     daa:	cf 93       	push	r28
     dac:	df 93       	push	r29
     dae:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     db0:	89 2b       	or	r24, r25
     db2:	19 f4       	brne	.+6      	; 0xdba <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     db4:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
     db8:	09 c0       	rjmp	.+18     	; 0xdcc <vTaskDelay+0x22>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     dba:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     dbe:	ce 01       	movw	r24, r28
     dc0:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <prvAddCurrentTaskToDelayedList.isra.2>
			}
			xAlreadyYielded = xTaskResumeAll();
     dc4:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     dc8:	88 23       	and	r24, r24
     dca:	a1 f3       	breq	.-24     	; 0xdb4 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     dcc:	df 91       	pop	r29
     dce:	cf 91       	pop	r28
     dd0:	08 95       	ret

00000dd2 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
     dd2:	cf 93       	push	r28
     dd4:	df 93       	push	r29
     dd6:	ec 01       	movw	r28, r24
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
     dd8:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
     ddc:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <xPendedTicks>
     de0:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <xPendedTicks+0x1>
     de4:	c8 0f       	add	r28, r24
     de6:	d9 1f       	adc	r29, r25
     de8:	d0 93 61 01 	sts	0x0161, r29	; 0x800161 <xPendedTicks+0x1>
     dec:	c0 93 60 01 	sts	0x0160, r28	; 0x800160 <xPendedTicks>
	xYieldRequired = xTaskResumeAll();

	return xYieldRequired;
}
     df0:	df 91       	pop	r29
     df2:	cf 91       	pop	r28

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
	xPendedTicks += xTicksToCatchUp;
	xYieldRequired = xTaskResumeAll();
     df4:	0c 94 2b 06 	jmp	0xc56	; 0xc56 <xTaskResumeAll>

00000df8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     df8:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <uxSchedulerSuspended>
     dfc:	88 23       	and	r24, r24
     dfe:	21 f0       	breq	.+8      	; 0xe08 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     e00:	81 e0       	ldi	r24, 0x01	; 1
     e02:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <xYieldPending>
     e06:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     e08:	10 92 5f 01 	sts	0x015F, r1	; 0x80015f <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     e0c:	80 91 63 01 	lds	r24, 0x0163	; 0x800163 <uxTopReadyPriority>
     e10:	69 e0       	ldi	r22, 0x09	; 9
     e12:	48 2f       	mov	r20, r24
     e14:	50 e0       	ldi	r21, 0x00	; 0
     e16:	64 9f       	mul	r22, r20
     e18:	90 01       	movw	r18, r0
     e1a:	65 9f       	mul	r22, r21
     e1c:	30 0d       	add	r19, r0
     e1e:	11 24       	eor	r1, r1
     e20:	f9 01       	movw	r30, r18
     e22:	e0 57       	subi	r30, 0x70	; 112
     e24:	fe 4f       	sbci	r31, 0xFE	; 254
     e26:	90 81       	ld	r25, Z
     e28:	91 11       	cpse	r25, r1
     e2a:	02 c0       	rjmp	.+4      	; 0xe30 <vTaskSwitchContext+0x38>
     e2c:	81 50       	subi	r24, 0x01	; 1
     e2e:	f1 cf       	rjmp	.-30     	; 0xe12 <vTaskSwitchContext+0x1a>
     e30:	a1 81       	ldd	r26, Z+1	; 0x01
     e32:	b2 81       	ldd	r27, Z+2	; 0x02
     e34:	12 96       	adiw	r26, 0x02	; 2
     e36:	0d 90       	ld	r0, X+
     e38:	bc 91       	ld	r27, X
     e3a:	a0 2d       	mov	r26, r0
     e3c:	b2 83       	std	Z+2, r27	; 0x02
     e3e:	a1 83       	std	Z+1, r26	; 0x01
     e40:	2d 56       	subi	r18, 0x6D	; 109
     e42:	3e 4f       	sbci	r19, 0xFE	; 254
     e44:	a2 17       	cp	r26, r18
     e46:	b3 07       	cpc	r27, r19
     e48:	31 f4       	brne	.+12     	; 0xe56 <vTaskSwitchContext+0x5e>
     e4a:	12 96       	adiw	r26, 0x02	; 2
     e4c:	2d 91       	ld	r18, X+
     e4e:	3c 91       	ld	r19, X
     e50:	13 97       	sbiw	r26, 0x03	; 3
     e52:	32 83       	std	Z+2, r19	; 0x02
     e54:	21 83       	std	Z+1, r18	; 0x01
     e56:	99 e0       	ldi	r25, 0x09	; 9
     e58:	94 9f       	mul	r25, r20
     e5a:	f0 01       	movw	r30, r0
     e5c:	95 9f       	mul	r25, r21
     e5e:	f0 0d       	add	r31, r0
     e60:	11 24       	eor	r1, r1
     e62:	e0 57       	subi	r30, 0x70	; 112
     e64:	fe 4f       	sbci	r31, 0xFE	; 254
     e66:	01 80       	ldd	r0, Z+1	; 0x01
     e68:	f2 81       	ldd	r31, Z+2	; 0x02
     e6a:	e0 2d       	mov	r30, r0
     e6c:	26 81       	ldd	r18, Z+6	; 0x06
     e6e:	37 81       	ldd	r19, Z+7	; 0x07
     e70:	30 93 57 01 	sts	0x0157, r19	; 0x800157 <pxCurrentTCB+0x1>
     e74:	20 93 56 01 	sts	0x0156, r18	; 0x800156 <pxCurrentTCB>
     e78:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <uxTopReadyPriority>
     e7c:	08 95       	ret

00000e7e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     e7e:	cf 93       	push	r28
     e80:	df 93       	push	r29
     e82:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     e84:	60 91 56 01 	lds	r22, 0x0156	; 0x800156 <pxCurrentTCB>
     e88:	70 91 57 01 	lds	r23, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     e8c:	64 5f       	subi	r22, 0xF4	; 244
     e8e:	7f 4f       	sbci	r23, 0xFF	; 255
     e90:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e94:	ce 01       	movw	r24, r28
}
     e96:	df 91       	pop	r29
     e98:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e9a:	0c 94 6a 03 	jmp	0x6d4	; 0x6d4 <prvAddCurrentTaskToDelayedList.isra.2>

00000e9e <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     e9e:	cf 93       	push	r28
     ea0:	df 93       	push	r29
     ea2:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     ea4:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
     ea8:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     eac:	70 68       	ori	r23, 0x80	; 128
     eae:	75 87       	std	Z+13, r23	; 0x0d
     eb0:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     eb2:	60 91 56 01 	lds	r22, 0x0156	; 0x800156 <pxCurrentTCB>
     eb6:	70 91 57 01 	lds	r23, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     eba:	64 5f       	subi	r22, 0xF4	; 244
     ebc:	7f 4f       	sbci	r23, 0xFF	; 255
     ebe:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     ec2:	ce 01       	movw	r24, r28
}
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     ec8:	0c 94 6a 03 	jmp	0x6d4	; 0x6d4 <prvAddCurrentTaskToDelayedList.isra.2>

00000ecc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     ecc:	0f 93       	push	r16
     ece:	1f 93       	push	r17
     ed0:	cf 93       	push	r28
     ed2:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     ed4:	dc 01       	movw	r26, r24
     ed6:	15 96       	adiw	r26, 0x05	; 5
     ed8:	ed 91       	ld	r30, X+
     eda:	fc 91       	ld	r31, X
     edc:	16 97       	sbiw	r26, 0x06	; 6
     ede:	c6 81       	ldd	r28, Z+6	; 0x06
     ee0:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     ee2:	8e 01       	movw	r16, r28
     ee4:	04 5f       	subi	r16, 0xF4	; 244
     ee6:	1f 4f       	sbci	r17, 0xFF	; 255
     ee8:	c8 01       	movw	r24, r16
     eea:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     eee:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <uxSchedulerSuspended>
     ef2:	81 11       	cpse	r24, r1
     ef4:	14 c0       	rjmp	.+40     	; 0xf1e <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     ef6:	0a 50       	subi	r16, 0x0A	; 10
     ef8:	11 09       	sbc	r17, r1
     efa:	c8 01       	movw	r24, r16
     efc:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     f00:	8e 89       	ldd	r24, Y+22	; 0x16
     f02:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <uxTopReadyPriority>
     f06:	98 17       	cp	r25, r24
     f08:	10 f4       	brcc	.+4      	; 0xf0e <xTaskRemoveFromEventList+0x42>
     f0a:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <uxTopReadyPriority>
     f0e:	b9 e0       	ldi	r27, 0x09	; 9
     f10:	8b 9f       	mul	r24, r27
     f12:	c0 01       	movw	r24, r0
     f14:	11 24       	eor	r1, r1
     f16:	b8 01       	movw	r22, r16
     f18:	80 57       	subi	r24, 0x70	; 112
     f1a:	9e 4f       	sbci	r25, 0xFE	; 254
     f1c:	03 c0       	rjmp	.+6      	; 0xf24 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     f1e:	b8 01       	movw	r22, r16
     f20:	81 e7       	ldi	r24, 0x71	; 113
     f22:	91 e0       	ldi	r25, 0x01	; 1
     f24:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     f28:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
     f2c:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     f30:	9e 89       	ldd	r25, Y+22	; 0x16
     f32:	86 89       	ldd	r24, Z+22	; 0x16
     f34:	89 17       	cp	r24, r25
     f36:	20 f4       	brcc	.+8      	; 0xf40 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <xYieldPending>
     f3e:	01 c0       	rjmp	.+2      	; 0xf42 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     f40:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
     f42:	df 91       	pop	r29
     f44:	cf 91       	pop	r28
     f46:	1f 91       	pop	r17
     f48:	0f 91       	pop	r16
     f4a:	08 95       	ret

00000f4c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     f4c:	0f 93       	push	r16
     f4e:	1f 93       	push	r17
     f50:	cf 93       	push	r28
     f52:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     f54:	70 68       	ori	r23, 0x80	; 128
     f56:	fc 01       	movw	r30, r24
     f58:	71 83       	std	Z+1, r23	; 0x01
     f5a:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     f5c:	c6 81       	ldd	r28, Z+6	; 0x06
     f5e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     f60:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     f64:	8e 01       	movw	r16, r28
     f66:	0e 5f       	subi	r16, 0xFE	; 254
     f68:	1f 4f       	sbci	r17, 0xFF	; 255
     f6a:	c8 01       	movw	r24, r16
     f6c:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     f70:	8e 89       	ldd	r24, Y+22	; 0x16
     f72:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <uxTopReadyPriority>
     f76:	98 17       	cp	r25, r24
     f78:	10 f4       	brcc	.+4      	; 0xf7e <vTaskRemoveFromUnorderedEventList+0x32>
     f7a:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <uxTopReadyPriority>
     f7e:	f9 e0       	ldi	r31, 0x09	; 9
     f80:	8f 9f       	mul	r24, r31
     f82:	c0 01       	movw	r24, r0
     f84:	11 24       	eor	r1, r1
     f86:	b8 01       	movw	r22, r16
     f88:	80 57       	subi	r24, 0x70	; 112
     f8a:	9e 4f       	sbci	r25, 0xFE	; 254
     f8c:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     f90:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
     f94:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
     f98:	9e 89       	ldd	r25, Y+22	; 0x16
     f9a:	86 89       	ldd	r24, Z+22	; 0x16
     f9c:	89 17       	cp	r24, r25
     f9e:	18 f4       	brcc	.+6      	; 0xfa6 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     fa0:	81 e0       	ldi	r24, 0x01	; 1
     fa2:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <xYieldPending>
	}
}
     fa6:	df 91       	pop	r29
     fa8:	cf 91       	pop	r28
     faa:	1f 91       	pop	r17
     fac:	0f 91       	pop	r16
     fae:	08 95       	ret

00000fb0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     fb0:	0f b6       	in	r0, 0x3f	; 63
     fb2:	f8 94       	cli
     fb4:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     fb6:	20 91 5e 01 	lds	r18, 0x015E	; 0x80015e <xNumOfOverflows>
     fba:	fc 01       	movw	r30, r24
     fbc:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     fbe:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <xTickCount>
     fc2:	30 91 65 01 	lds	r19, 0x0165	; 0x800165 <xTickCount+0x1>
     fc6:	32 83       	std	Z+2, r19	; 0x02
     fc8:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     fca:	0f 90       	pop	r0
     fcc:	0f be       	out	0x3f, r0	; 63
     fce:	08 95       	ret

00000fd0 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     fd0:	20 91 5e 01 	lds	r18, 0x015E	; 0x80015e <xNumOfOverflows>
     fd4:	fc 01       	movw	r30, r24
     fd6:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     fd8:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <xTickCount>
     fdc:	30 91 65 01 	lds	r19, 0x0165	; 0x800165 <xTickCount+0x1>
     fe0:	32 83       	std	Z+2, r19	; 0x02
     fe2:	21 83       	std	Z+1, r18	; 0x01
     fe4:	08 95       	ret

00000fe6 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     fe6:	0f b6       	in	r0, 0x3f	; 63
     fe8:	f8 94       	cli
     fea:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     fec:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <xTickCount>
     ff0:	30 91 65 01 	lds	r19, 0x0165	; 0x800165 <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     ff4:	dc 01       	movw	r26, r24
     ff6:	11 96       	adiw	r26, 0x01	; 1
     ff8:	4d 91       	ld	r20, X+
     ffa:	5c 91       	ld	r21, X
     ffc:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     ffe:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <xNumOfOverflows>
    1002:	fc 91       	ld	r31, X
    1004:	fe 17       	cp	r31, r30
    1006:	19 f0       	breq	.+6      	; 0x100e <xTaskCheckForTimeOut+0x28>
    1008:	24 17       	cp	r18, r20
    100a:	35 07       	cpc	r19, r21
    100c:	90 f4       	brcc	.+36     	; 0x1032 <xTaskCheckForTimeOut+0x4c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    100e:	24 1b       	sub	r18, r20
    1010:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1012:	fb 01       	movw	r30, r22
    1014:	40 81       	ld	r20, Z
    1016:	51 81       	ldd	r21, Z+1	; 0x01
    1018:	24 17       	cp	r18, r20
    101a:	35 07       	cpc	r19, r21
    101c:	40 f4       	brcc	.+16     	; 0x102e <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    101e:	42 1b       	sub	r20, r18
    1020:	53 0b       	sbc	r21, r19
    1022:	51 83       	std	Z+1, r21	; 0x01
    1024:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    1026:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    102a:	80 e0       	ldi	r24, 0x00	; 0
    102c:	03 c0       	rjmp	.+6      	; 0x1034 <xTaskCheckForTimeOut+0x4e>
		}
		else
		{
			*pxTicksToWait = 0;
    102e:	11 82       	std	Z+1, r1	; 0x01
    1030:	10 82       	st	Z, r1
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1032:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1034:	0f 90       	pop	r0
    1036:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1038:	08 95       	ret

0000103a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    103a:	81 e0       	ldi	r24, 0x01	; 1
    103c:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <xYieldPending>
    1040:	08 95       	ret

00001042 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1042:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    1046:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    104a:	84 85       	ldd	r24, Z+12	; 0x0c
    104c:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    104e:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    1052:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    1056:	a0 91 56 01 	lds	r26, 0x0156	; 0x800156 <pxCurrentTCB>
    105a:	b0 91 57 01 	lds	r27, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    105e:	56 96       	adiw	r26, 0x16	; 22
    1060:	4c 91       	ld	r20, X
    1062:	24 e0       	ldi	r18, 0x04	; 4
    1064:	30 e0       	ldi	r19, 0x00	; 0
    1066:	24 1b       	sub	r18, r20
    1068:	31 09       	sbc	r19, r1
    106a:	35 87       	std	Z+13, r19	; 0x0d
    106c:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    106e:	08 95       	ret

00001070 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    1070:	0f 93       	push	r16
    1072:	1f 93       	push	r17
    1074:	18 2f       	mov	r17, r24
    1076:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    1078:	0f b6       	in	r0, 0x3f	; 63
    107a:	f8 94       	cli
    107c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    107e:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    1082:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    1086:	41 a1       	ldd	r20, Z+33	; 0x21
    1088:	52 a1       	ldd	r21, Z+34	; 0x22
    108a:	63 a1       	ldd	r22, Z+35	; 0x23
    108c:	74 a1       	ldd	r23, Z+36	; 0x24
    108e:	45 2b       	or	r20, r21
    1090:	46 2b       	or	r20, r22
    1092:	47 2b       	or	r20, r23
    1094:	61 f4       	brne	.+24     	; 0x10ae <ulTaskNotifyTake+0x3e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1096:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    109a:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    109e:	21 e0       	ldi	r18, 0x01	; 1
    10a0:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    10a2:	00 97       	sbiw	r24, 0x00	; 0
    10a4:	21 f0       	breq	.+8      	; 0x10ae <ulTaskNotifyTake+0x3e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    10a6:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <prvAddCurrentTaskToDelayedList.isra.2>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    10aa:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    10ae:	0f 90       	pop	r0
    10b0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	f8 94       	cli
    10b6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    10b8:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    10bc:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    10c0:	61 a1       	ldd	r22, Z+33	; 0x21
    10c2:	72 a1       	ldd	r23, Z+34	; 0x22
    10c4:	83 a1       	ldd	r24, Z+35	; 0x23
    10c6:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
    10c8:	61 15       	cp	r22, r1
    10ca:	71 05       	cpc	r23, r1
    10cc:	81 05       	cpc	r24, r1
    10ce:	91 05       	cpc	r25, r1
    10d0:	a9 f0       	breq	.+42     	; 0x10fc <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    10d2:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    10d6:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
    10da:	11 23       	and	r17, r17
    10dc:	29 f0       	breq	.+10     	; 0x10e8 <ulTaskNotifyTake+0x78>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    10de:	11 a2       	std	Z+33, r1	; 0x21
    10e0:	12 a2       	std	Z+34, r1	; 0x22
    10e2:	13 a2       	std	Z+35, r1	; 0x23
    10e4:	14 a2       	std	Z+36, r1	; 0x24
    10e6:	0a c0       	rjmp	.+20     	; 0x10fc <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    10e8:	8b 01       	movw	r16, r22
    10ea:	9c 01       	movw	r18, r24
    10ec:	01 50       	subi	r16, 0x01	; 1
    10ee:	11 09       	sbc	r17, r1
    10f0:	21 09       	sbc	r18, r1
    10f2:	31 09       	sbc	r19, r1
    10f4:	01 a3       	std	Z+33, r16	; 0x21
    10f6:	12 a3       	std	Z+34, r17	; 0x22
    10f8:	23 a3       	std	Z+35, r18	; 0x23
    10fa:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    10fc:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    1100:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    1104:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1106:	0f 90       	pop	r0
    1108:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    110a:	1f 91       	pop	r17
    110c:	0f 91       	pop	r16
    110e:	08 95       	ret

00001110 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    1110:	4f 92       	push	r4
    1112:	5f 92       	push	r5
    1114:	6f 92       	push	r6
    1116:	7f 92       	push	r7
    1118:	8f 92       	push	r8
    111a:	9f 92       	push	r9
    111c:	af 92       	push	r10
    111e:	bf 92       	push	r11
    1120:	ef 92       	push	r14
    1122:	ff 92       	push	r15
    1124:	0f 93       	push	r16
    1126:	1f 93       	push	r17
    1128:	49 01       	movw	r8, r18
    112a:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    112c:	0f b6       	in	r0, 0x3f	; 63
    112e:	f8 94       	cli
    1130:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1132:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    1136:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    113a:	25 a1       	ldd	r18, Z+37	; 0x25
    113c:	22 30       	cpi	r18, 0x02	; 2
    113e:	31 f1       	breq	.+76     	; 0x118c <xTaskNotifyWait+0x7c>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1140:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    1144:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    1148:	21 a1       	ldd	r18, Z+33	; 0x21
    114a:	32 a1       	ldd	r19, Z+34	; 0x22
    114c:	43 a1       	ldd	r20, Z+35	; 0x23
    114e:	54 a1       	ldd	r21, Z+36	; 0x24
    1150:	2b 01       	movw	r4, r22
    1152:	3c 01       	movw	r6, r24
    1154:	40 94       	com	r4
    1156:	50 94       	com	r5
    1158:	60 94       	com	r6
    115a:	70 94       	com	r7
    115c:	d3 01       	movw	r26, r6
    115e:	c2 01       	movw	r24, r4
    1160:	82 23       	and	r24, r18
    1162:	93 23       	and	r25, r19
    1164:	a4 23       	and	r26, r20
    1166:	b5 23       	and	r27, r21
    1168:	81 a3       	std	Z+33, r24	; 0x21
    116a:	92 a3       	std	Z+34, r25	; 0x22
    116c:	a3 a3       	std	Z+35, r26	; 0x23
    116e:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1170:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    1174:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    1178:	81 e0       	ldi	r24, 0x01	; 1
    117a:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    117c:	e1 14       	cp	r14, r1
    117e:	f1 04       	cpc	r15, r1
    1180:	29 f0       	breq	.+10     	; 0x118c <xTaskNotifyWait+0x7c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1182:	c7 01       	movw	r24, r14
    1184:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <prvAddCurrentTaskToDelayedList.isra.2>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1188:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    118c:	0f 90       	pop	r0
    118e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1190:	0f b6       	in	r0, 0x3f	; 63
    1192:	f8 94       	cli
    1194:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1196:	01 15       	cp	r16, r1
    1198:	11 05       	cpc	r17, r1
    119a:	69 f0       	breq	.+26     	; 0x11b6 <xTaskNotifyWait+0xa6>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    119c:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    11a0:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    11a4:	81 a1       	ldd	r24, Z+33	; 0x21
    11a6:	92 a1       	ldd	r25, Z+34	; 0x22
    11a8:	a3 a1       	ldd	r26, Z+35	; 0x23
    11aa:	b4 a1       	ldd	r27, Z+36	; 0x24
    11ac:	f8 01       	movw	r30, r16
    11ae:	80 83       	st	Z, r24
    11b0:	91 83       	std	Z+1, r25	; 0x01
    11b2:	a2 83       	std	Z+2, r26	; 0x02
    11b4:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    11b6:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    11ba:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    11be:	85 a1       	ldd	r24, Z+37	; 0x25
    11c0:	82 30       	cpi	r24, 0x02	; 2
    11c2:	c1 f4       	brne	.+48     	; 0x11f4 <xTaskNotifyWait+0xe4>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    11c4:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    11c8:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    11cc:	41 a1       	ldd	r20, Z+33	; 0x21
    11ce:	52 a1       	ldd	r21, Z+34	; 0x22
    11d0:	63 a1       	ldd	r22, Z+35	; 0x23
    11d2:	74 a1       	ldd	r23, Z+36	; 0x24
    11d4:	d5 01       	movw	r26, r10
    11d6:	c4 01       	movw	r24, r8
    11d8:	80 95       	com	r24
    11da:	90 95       	com	r25
    11dc:	a0 95       	com	r26
    11de:	b0 95       	com	r27
    11e0:	84 23       	and	r24, r20
    11e2:	95 23       	and	r25, r21
    11e4:	a6 23       	and	r26, r22
    11e6:	b7 23       	and	r27, r23
    11e8:	81 a3       	std	Z+33, r24	; 0x21
    11ea:	92 a3       	std	Z+34, r25	; 0x22
    11ec:	a3 a3       	std	Z+35, r26	; 0x23
    11ee:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    11f0:	81 e0       	ldi	r24, 0x01	; 1
    11f2:	01 c0       	rjmp	.+2      	; 0x11f6 <xTaskNotifyWait+0xe6>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    11f4:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    11f6:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    11fa:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    11fe:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1200:	0f 90       	pop	r0
    1202:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1204:	1f 91       	pop	r17
    1206:	0f 91       	pop	r16
    1208:	ff 90       	pop	r15
    120a:	ef 90       	pop	r14
    120c:	bf 90       	pop	r11
    120e:	af 90       	pop	r10
    1210:	9f 90       	pop	r9
    1212:	8f 90       	pop	r8
    1214:	7f 90       	pop	r7
    1216:	6f 90       	pop	r6
    1218:	5f 90       	pop	r5
    121a:	4f 90       	pop	r4
    121c:	08 95       	ret

0000121e <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    121e:	0f 93       	push	r16
    1220:	1f 93       	push	r17
    1222:	cf 93       	push	r28
    1224:	df 93       	push	r29
    1226:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    1228:	0f b6       	in	r0, 0x3f	; 63
    122a:	f8 94       	cli
    122c:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    122e:	01 15       	cp	r16, r1
    1230:	11 05       	cpc	r17, r1
    1232:	49 f0       	breq	.+18     	; 0x1246 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1234:	81 a1       	ldd	r24, Z+33	; 0x21
    1236:	92 a1       	ldd	r25, Z+34	; 0x22
    1238:	a3 a1       	ldd	r26, Z+35	; 0x23
    123a:	b4 a1       	ldd	r27, Z+36	; 0x24
    123c:	e8 01       	movw	r28, r16
    123e:	88 83       	st	Y, r24
    1240:	99 83       	std	Y+1, r25	; 0x01
    1242:	aa 83       	std	Y+2, r26	; 0x02
    1244:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1246:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1248:	82 e0       	ldi	r24, 0x02	; 2
    124a:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    124c:	22 30       	cpi	r18, 0x02	; 2
    124e:	89 f0       	breq	.+34     	; 0x1272 <xTaskGenericNotify+0x54>
    1250:	58 f4       	brcc	.+22     	; 0x1268 <xTaskGenericNotify+0x4a>
    1252:	21 30       	cpi	r18, 0x01	; 1
    1254:	01 f5       	brne	.+64     	; 0x1296 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1256:	81 a1       	ldd	r24, Z+33	; 0x21
    1258:	92 a1       	ldd	r25, Z+34	; 0x22
    125a:	a3 a1       	ldd	r26, Z+35	; 0x23
    125c:	b4 a1       	ldd	r27, Z+36	; 0x24
    125e:	48 2b       	or	r20, r24
    1260:	59 2b       	or	r21, r25
    1262:	6a 2b       	or	r22, r26
    1264:	7b 2b       	or	r23, r27
    1266:	13 c0       	rjmp	.+38     	; 0x128e <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1268:	23 30       	cpi	r18, 0x03	; 3
    126a:	89 f0       	breq	.+34     	; 0x128e <xTaskGenericNotify+0x70>
    126c:	24 30       	cpi	r18, 0x04	; 4
    126e:	69 f0       	breq	.+26     	; 0x128a <xTaskGenericNotify+0x6c>
    1270:	12 c0       	rjmp	.+36     	; 0x1296 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1272:	81 a1       	ldd	r24, Z+33	; 0x21
    1274:	92 a1       	ldd	r25, Z+34	; 0x22
    1276:	a3 a1       	ldd	r26, Z+35	; 0x23
    1278:	b4 a1       	ldd	r27, Z+36	; 0x24
    127a:	01 96       	adiw	r24, 0x01	; 1
    127c:	a1 1d       	adc	r26, r1
    127e:	b1 1d       	adc	r27, r1
    1280:	81 a3       	std	Z+33, r24	; 0x21
    1282:	92 a3       	std	Z+34, r25	; 0x22
    1284:	a3 a3       	std	Z+35, r26	; 0x23
    1286:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1288:	06 c0       	rjmp	.+12     	; 0x1296 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    128a:	32 30       	cpi	r19, 0x02	; 2
    128c:	49 f1       	breq	.+82     	; 0x12e0 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    128e:	41 a3       	std	Z+33, r20	; 0x21
    1290:	52 a3       	std	Z+34, r21	; 0x22
    1292:	63 a3       	std	Z+35, r22	; 0x23
    1294:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1296:	31 30       	cpi	r19, 0x01	; 1
    1298:	09 f5       	brne	.+66     	; 0x12dc <xTaskGenericNotify+0xbe>
    129a:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    129c:	8f 01       	movw	r16, r30
    129e:	0e 5f       	subi	r16, 0xFE	; 254
    12a0:	1f 4f       	sbci	r17, 0xFF	; 255
    12a2:	c8 01       	movw	r24, r16
    12a4:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    12a8:	8e 89       	ldd	r24, Y+22	; 0x16
    12aa:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <uxTopReadyPriority>
    12ae:	98 17       	cp	r25, r24
    12b0:	10 f4       	brcc	.+4      	; 0x12b6 <xTaskGenericNotify+0x98>
    12b2:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <uxTopReadyPriority>
    12b6:	29 e0       	ldi	r18, 0x09	; 9
    12b8:	82 9f       	mul	r24, r18
    12ba:	c0 01       	movw	r24, r0
    12bc:	11 24       	eor	r1, r1
    12be:	b8 01       	movw	r22, r16
    12c0:	80 57       	subi	r24, 0x70	; 112
    12c2:	9e 4f       	sbci	r25, 0xFE	; 254
    12c4:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    12c8:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    12cc:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    12d0:	9e 89       	ldd	r25, Y+22	; 0x16
    12d2:	86 89       	ldd	r24, Z+22	; 0x16
    12d4:	89 17       	cp	r24, r25
    12d6:	10 f4       	brcc	.+4      	; 0x12dc <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    12d8:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	01 c0       	rjmp	.+2      	; 0x12e2 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    12e0:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    12e2:	0f 90       	pop	r0
    12e4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    12e6:	df 91       	pop	r29
    12e8:	cf 91       	pop	r28
    12ea:	1f 91       	pop	r17
    12ec:	0f 91       	pop	r16
    12ee:	08 95       	ret

000012f0 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    12f0:	ef 92       	push	r14
    12f2:	ff 92       	push	r15
    12f4:	0f 93       	push	r16
    12f6:	1f 93       	push	r17
    12f8:	cf 93       	push	r28
    12fa:	df 93       	push	r29
    12fc:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    12fe:	01 15       	cp	r16, r1
    1300:	11 05       	cpc	r17, r1
    1302:	49 f0       	breq	.+18     	; 0x1316 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1304:	81 a1       	ldd	r24, Z+33	; 0x21
    1306:	92 a1       	ldd	r25, Z+34	; 0x22
    1308:	a3 a1       	ldd	r26, Z+35	; 0x23
    130a:	b4 a1       	ldd	r27, Z+36	; 0x24
    130c:	e8 01       	movw	r28, r16
    130e:	88 83       	st	Y, r24
    1310:	99 83       	std	Y+1, r25	; 0x01
    1312:	aa 83       	std	Y+2, r26	; 0x02
    1314:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1316:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1318:	82 e0       	ldi	r24, 0x02	; 2
    131a:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    131c:	22 30       	cpi	r18, 0x02	; 2
    131e:	89 f0       	breq	.+34     	; 0x1342 <xTaskGenericNotifyFromISR+0x52>
    1320:	58 f4       	brcc	.+22     	; 0x1338 <xTaskGenericNotifyFromISR+0x48>
    1322:	21 30       	cpi	r18, 0x01	; 1
    1324:	01 f5       	brne	.+64     	; 0x1366 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1326:	81 a1       	ldd	r24, Z+33	; 0x21
    1328:	92 a1       	ldd	r25, Z+34	; 0x22
    132a:	a3 a1       	ldd	r26, Z+35	; 0x23
    132c:	b4 a1       	ldd	r27, Z+36	; 0x24
    132e:	48 2b       	or	r20, r24
    1330:	59 2b       	or	r21, r25
    1332:	6a 2b       	or	r22, r26
    1334:	7b 2b       	or	r23, r27
    1336:	13 c0       	rjmp	.+38     	; 0x135e <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1338:	23 30       	cpi	r18, 0x03	; 3
    133a:	89 f0       	breq	.+34     	; 0x135e <xTaskGenericNotifyFromISR+0x6e>
    133c:	24 30       	cpi	r18, 0x04	; 4
    133e:	69 f0       	breq	.+26     	; 0x135a <xTaskGenericNotifyFromISR+0x6a>
    1340:	12 c0       	rjmp	.+36     	; 0x1366 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1342:	81 a1       	ldd	r24, Z+33	; 0x21
    1344:	92 a1       	ldd	r25, Z+34	; 0x22
    1346:	a3 a1       	ldd	r26, Z+35	; 0x23
    1348:	b4 a1       	ldd	r27, Z+36	; 0x24
    134a:	01 96       	adiw	r24, 0x01	; 1
    134c:	a1 1d       	adc	r26, r1
    134e:	b1 1d       	adc	r27, r1
    1350:	81 a3       	std	Z+33, r24	; 0x21
    1352:	92 a3       	std	Z+34, r25	; 0x22
    1354:	a3 a3       	std	Z+35, r26	; 0x23
    1356:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1358:	06 c0       	rjmp	.+12     	; 0x1366 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    135a:	32 30       	cpi	r19, 0x02	; 2
    135c:	d9 f1       	breq	.+118    	; 0x13d4 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    135e:	41 a3       	std	Z+33, r20	; 0x21
    1360:	52 a3       	std	Z+34, r21	; 0x22
    1362:	63 a3       	std	Z+35, r22	; 0x23
    1364:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1366:	31 30       	cpi	r19, 0x01	; 1
    1368:	11 f0       	breq	.+4      	; 0x136e <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	34 c0       	rjmp	.+104    	; 0x13d6 <xTaskGenericNotifyFromISR+0xe6>
    136e:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1370:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <uxSchedulerSuspended>
    1374:	81 11       	cpse	r24, r1
    1376:	15 c0       	rjmp	.+42     	; 0x13a2 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1378:	8f 01       	movw	r16, r30
    137a:	0e 5f       	subi	r16, 0xFE	; 254
    137c:	1f 4f       	sbci	r17, 0xFF	; 255
    137e:	c8 01       	movw	r24, r16
    1380:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1384:	8e 89       	ldd	r24, Y+22	; 0x16
    1386:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <uxTopReadyPriority>
    138a:	98 17       	cp	r25, r24
    138c:	10 f4       	brcc	.+4      	; 0x1392 <xTaskGenericNotifyFromISR+0xa2>
    138e:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <uxTopReadyPriority>
    1392:	e9 e0       	ldi	r30, 0x09	; 9
    1394:	8e 9f       	mul	r24, r30
    1396:	c0 01       	movw	r24, r0
    1398:	11 24       	eor	r1, r1
    139a:	b8 01       	movw	r22, r16
    139c:	80 57       	subi	r24, 0x70	; 112
    139e:	9e 4f       	sbci	r25, 0xFE	; 254
    13a0:	05 c0       	rjmp	.+10     	; 0x13ac <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    13a2:	bf 01       	movw	r22, r30
    13a4:	64 5f       	subi	r22, 0xF4	; 244
    13a6:	7f 4f       	sbci	r23, 0xFF	; 255
    13a8:	81 e7       	ldi	r24, 0x71	; 113
    13aa:	91 e0       	ldi	r25, 0x01	; 1
    13ac:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    13b0:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    13b4:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    13b8:	9e 89       	ldd	r25, Y+22	; 0x16
    13ba:	86 89       	ldd	r24, Z+22	; 0x16
    13bc:	89 17       	cp	r24, r25
    13be:	a8 f6       	brcc	.-86     	; 0x136a <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    13c0:	e1 14       	cp	r14, r1
    13c2:	f1 04       	cpc	r15, r1
    13c4:	19 f0       	breq	.+6      	; 0x13cc <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    13c6:	81 e0       	ldi	r24, 0x01	; 1
    13c8:	e7 01       	movw	r28, r14
    13ca:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    13cc:	81 e0       	ldi	r24, 0x01	; 1
    13ce:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <xYieldPending>
    13d2:	01 c0       	rjmp	.+2      	; 0x13d6 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    13d4:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    13d6:	df 91       	pop	r29
    13d8:	cf 91       	pop	r28
    13da:	1f 91       	pop	r17
    13dc:	0f 91       	pop	r16
    13de:	ff 90       	pop	r15
    13e0:	ef 90       	pop	r14
    13e2:	08 95       	ret

000013e4 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    13e4:	ef 92       	push	r14
    13e6:	ff 92       	push	r15
    13e8:	0f 93       	push	r16
    13ea:	1f 93       	push	r17
    13ec:	cf 93       	push	r28
    13ee:	df 93       	push	r29
    13f0:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    13f2:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    13f4:	82 e0       	ldi	r24, 0x02	; 2
    13f6:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    13f8:	81 a1       	ldd	r24, Z+33	; 0x21
    13fa:	92 a1       	ldd	r25, Z+34	; 0x22
    13fc:	a3 a1       	ldd	r26, Z+35	; 0x23
    13fe:	b4 a1       	ldd	r27, Z+36	; 0x24
    1400:	01 96       	adiw	r24, 0x01	; 1
    1402:	a1 1d       	adc	r26, r1
    1404:	b1 1d       	adc	r27, r1
    1406:	81 a3       	std	Z+33, r24	; 0x21
    1408:	92 a3       	std	Z+34, r25	; 0x22
    140a:	a3 a3       	std	Z+35, r26	; 0x23
    140c:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    140e:	21 30       	cpi	r18, 0x01	; 1
    1410:	a1 f5       	brne	.+104    	; 0x147a <vTaskNotifyGiveFromISR+0x96>
    1412:	8b 01       	movw	r16, r22
    1414:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1416:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <uxSchedulerSuspended>
    141a:	81 11       	cpse	r24, r1
    141c:	16 c0       	rjmp	.+44     	; 0x144a <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    141e:	7f 01       	movw	r14, r30
    1420:	22 e0       	ldi	r18, 0x02	; 2
    1422:	e2 0e       	add	r14, r18
    1424:	f1 1c       	adc	r15, r1
    1426:	c7 01       	movw	r24, r14
    1428:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    142c:	8e 89       	ldd	r24, Y+22	; 0x16
    142e:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <uxTopReadyPriority>
    1432:	98 17       	cp	r25, r24
    1434:	10 f4       	brcc	.+4      	; 0x143a <vTaskNotifyGiveFromISR+0x56>
    1436:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <uxTopReadyPriority>
    143a:	e9 e0       	ldi	r30, 0x09	; 9
    143c:	8e 9f       	mul	r24, r30
    143e:	c0 01       	movw	r24, r0
    1440:	11 24       	eor	r1, r1
    1442:	b7 01       	movw	r22, r14
    1444:	80 57       	subi	r24, 0x70	; 112
    1446:	9e 4f       	sbci	r25, 0xFE	; 254
    1448:	05 c0       	rjmp	.+10     	; 0x1454 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    144a:	bf 01       	movw	r22, r30
    144c:	64 5f       	subi	r22, 0xF4	; 244
    144e:	7f 4f       	sbci	r23, 0xFF	; 255
    1450:	81 e7       	ldi	r24, 0x71	; 113
    1452:	91 e0       	ldi	r25, 0x01	; 1
    1454:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1458:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    145c:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    1460:	9e 89       	ldd	r25, Y+22	; 0x16
    1462:	86 89       	ldd	r24, Z+22	; 0x16
    1464:	89 17       	cp	r24, r25
    1466:	48 f4       	brcc	.+18     	; 0x147a <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1468:	01 15       	cp	r16, r1
    146a:	11 05       	cpc	r17, r1
    146c:	19 f0       	breq	.+6      	; 0x1474 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    146e:	81 e0       	ldi	r24, 0x01	; 1
    1470:	f8 01       	movw	r30, r16
    1472:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1474:	81 e0       	ldi	r24, 0x01	; 1
    1476:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    147a:	df 91       	pop	r29
    147c:	cf 91       	pop	r28
    147e:	1f 91       	pop	r17
    1480:	0f 91       	pop	r16
    1482:	ff 90       	pop	r15
    1484:	ef 90       	pop	r14
    1486:	08 95       	ret

00001488 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1488:	00 97       	sbiw	r24, 0x00	; 0
    148a:	21 f4       	brne	.+8      	; 0x1494 <xTaskNotifyStateClear+0xc>
    148c:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <pxCurrentTCB>
    1490:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    1494:	0f b6       	in	r0, 0x3f	; 63
    1496:	f8 94       	cli
    1498:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    149a:	fc 01       	movw	r30, r24
    149c:	25 a1       	ldd	r18, Z+37	; 0x25
    149e:	22 30       	cpi	r18, 0x02	; 2
    14a0:	19 f4       	brne	.+6      	; 0x14a8 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    14a2:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    14a4:	81 e0       	ldi	r24, 0x01	; 1
    14a6:	01 c0       	rjmp	.+2      	; 0x14aa <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    14a8:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    14aa:	0f 90       	pop	r0
    14ac:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    14ae:	08 95       	ret

000014b0 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
    14b0:	cf 92       	push	r12
    14b2:	df 92       	push	r13
    14b4:	ef 92       	push	r14
    14b6:	ff 92       	push	r15
    14b8:	0f 93       	push	r16
    14ba:	1f 93       	push	r17
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    14bc:	00 97       	sbiw	r24, 0x00	; 0
    14be:	21 f4       	brne	.+8      	; 0x14c8 <ulTaskNotifyValueClear+0x18>
    14c0:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <pxCurrentTCB>
    14c4:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    14c8:	0f b6       	in	r0, 0x3f	; 63
    14ca:	f8 94       	cli
    14cc:	0f 92       	push	r0
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    14ce:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxCurrentTCB>
    14d2:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    14d6:	c1 a0       	ldd	r12, Z+33	; 0x21
    14d8:	d2 a0       	ldd	r13, Z+34	; 0x22
    14da:	e3 a0       	ldd	r14, Z+35	; 0x23
    14dc:	f4 a0       	ldd	r15, Z+36	; 0x24
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
    14de:	fc 01       	movw	r30, r24
    14e0:	01 a1       	ldd	r16, Z+33	; 0x21
    14e2:	12 a1       	ldd	r17, Z+34	; 0x22
    14e4:	23 a1       	ldd	r18, Z+35	; 0x23
    14e6:	34 a1       	ldd	r19, Z+36	; 0x24
    14e8:	40 95       	com	r20
    14ea:	50 95       	com	r21
    14ec:	60 95       	com	r22
    14ee:	70 95       	com	r23
    14f0:	40 23       	and	r20, r16
    14f2:	51 23       	and	r21, r17
    14f4:	62 23       	and	r22, r18
    14f6:	73 23       	and	r23, r19
    14f8:	41 a3       	std	Z+33, r20	; 0x21
    14fa:	52 a3       	std	Z+34, r21	; 0x22
    14fc:	63 a3       	std	Z+35, r22	; 0x23
    14fe:	74 a3       	std	Z+36, r23	; 0x24
		}
		taskEXIT_CRITICAL();
    1500:	0f 90       	pop	r0
    1502:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    1504:	c7 01       	movw	r24, r14
    1506:	b6 01       	movw	r22, r12
    1508:	1f 91       	pop	r17
    150a:	0f 91       	pop	r16
    150c:	ff 90       	pop	r15
    150e:	ef 90       	pop	r14
    1510:	df 90       	pop	r13
    1512:	cf 90       	pop	r12
    1514:	08 95       	ret

00001516 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1516:	0f b6       	in	r0, 0x3f	; 63
    1518:	f8 94       	cli
    151a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    151c:	fc 01       	movw	r30, r24
    151e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1520:	0f 90       	pop	r0
    1522:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1524:	81 e0       	ldi	r24, 0x01	; 1
    1526:	91 11       	cpse	r25, r1
    1528:	80 e0       	ldi	r24, 0x00	; 0
}
    152a:	08 95       	ret

0000152c <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    152c:	0f 93       	push	r16
    152e:	1f 93       	push	r17
    1530:	cf 93       	push	r28
    1532:	df 93       	push	r29
    1534:	ec 01       	movw	r28, r24
    1536:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1538:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    153a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    153c:	44 23       	and	r20, r20
    153e:	b1 f1       	breq	.+108    	; 0x15ac <prvCopyDataToQueue+0x80>
    1540:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1542:	01 11       	cpse	r16, r1
    1544:	15 c0       	rjmp	.+42     	; 0x1570 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1546:	8a 81       	ldd	r24, Y+2	; 0x02
    1548:	9b 81       	ldd	r25, Y+3	; 0x03
    154a:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    154e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1550:	8a 81       	ldd	r24, Y+2	; 0x02
    1552:	9b 81       	ldd	r25, Y+3	; 0x03
    1554:	82 0f       	add	r24, r18
    1556:	91 1d       	adc	r25, r1
    1558:	9b 83       	std	Y+3, r25	; 0x03
    155a:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    155c:	2c 81       	ldd	r18, Y+4	; 0x04
    155e:	3d 81       	ldd	r19, Y+5	; 0x05
    1560:	82 17       	cp	r24, r18
    1562:	93 07       	cpc	r25, r19
    1564:	18 f1       	brcs	.+70     	; 0x15ac <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1566:	88 81       	ld	r24, Y
    1568:	99 81       	ldd	r25, Y+1	; 0x01
    156a:	9b 83       	std	Y+3, r25	; 0x03
    156c:	8a 83       	std	Y+2, r24	; 0x02
    156e:	1e c0       	rjmp	.+60     	; 0x15ac <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1570:	8e 81       	ldd	r24, Y+6	; 0x06
    1572:	9f 81       	ldd	r25, Y+7	; 0x07
    1574:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1578:	8c 8d       	ldd	r24, Y+28	; 0x1c
    157a:	90 e0       	ldi	r25, 0x00	; 0
    157c:	91 95       	neg	r25
    157e:	81 95       	neg	r24
    1580:	91 09       	sbc	r25, r1
    1582:	2e 81       	ldd	r18, Y+6	; 0x06
    1584:	3f 81       	ldd	r19, Y+7	; 0x07
    1586:	28 0f       	add	r18, r24
    1588:	39 1f       	adc	r19, r25
    158a:	3f 83       	std	Y+7, r19	; 0x07
    158c:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    158e:	48 81       	ld	r20, Y
    1590:	59 81       	ldd	r21, Y+1	; 0x01
    1592:	24 17       	cp	r18, r20
    1594:	35 07       	cpc	r19, r21
    1596:	30 f4       	brcc	.+12     	; 0x15a4 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1598:	2c 81       	ldd	r18, Y+4	; 0x04
    159a:	3d 81       	ldd	r19, Y+5	; 0x05
    159c:	82 0f       	add	r24, r18
    159e:	93 1f       	adc	r25, r19
    15a0:	9f 83       	std	Y+7, r25	; 0x07
    15a2:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    15a4:	02 30       	cpi	r16, 0x02	; 2
    15a6:	11 f4       	brne	.+4      	; 0x15ac <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15a8:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    15aa:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    15ac:	1f 5f       	subi	r17, 0xFF	; 255
    15ae:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    15b0:	80 e0       	ldi	r24, 0x00	; 0
    15b2:	df 91       	pop	r29
    15b4:	cf 91       	pop	r28
    15b6:	1f 91       	pop	r17
    15b8:	0f 91       	pop	r16
    15ba:	08 95       	ret

000015bc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    15bc:	fc 01       	movw	r30, r24
    15be:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    15c0:	44 8d       	ldd	r20, Z+28	; 0x1c
    15c2:	44 23       	and	r20, r20
    15c4:	a1 f0       	breq	.+40     	; 0x15ee <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    15c6:	50 e0       	ldi	r21, 0x00	; 0
    15c8:	26 81       	ldd	r18, Z+6	; 0x06
    15ca:	37 81       	ldd	r19, Z+7	; 0x07
    15cc:	24 0f       	add	r18, r20
    15ce:	35 1f       	adc	r19, r21
    15d0:	37 83       	std	Z+7, r19	; 0x07
    15d2:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    15d4:	64 81       	ldd	r22, Z+4	; 0x04
    15d6:	75 81       	ldd	r23, Z+5	; 0x05
    15d8:	26 17       	cp	r18, r22
    15da:	37 07       	cpc	r19, r23
    15dc:	20 f0       	brcs	.+8      	; 0x15e6 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    15de:	20 81       	ld	r18, Z
    15e0:	31 81       	ldd	r19, Z+1	; 0x01
    15e2:	37 83       	std	Z+7, r19	; 0x07
    15e4:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    15e6:	66 81       	ldd	r22, Z+6	; 0x06
    15e8:	77 81       	ldd	r23, Z+7	; 0x07
    15ea:	0c 94 95 16 	jmp	0x2d2a	; 0x2d2a <memcpy>
    15ee:	08 95       	ret

000015f0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    15f0:	ef 92       	push	r14
    15f2:	ff 92       	push	r15
    15f4:	1f 93       	push	r17
    15f6:	cf 93       	push	r28
    15f8:	df 93       	push	r29
    15fa:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    15fc:	0f b6       	in	r0, 0x3f	; 63
    15fe:	f8 94       	cli
    1600:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1602:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1604:	7c 01       	movw	r14, r24
    1606:	81 e1       	ldi	r24, 0x11	; 17
    1608:	e8 0e       	add	r14, r24
    160a:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    160c:	11 16       	cp	r1, r17
    160e:	5c f4       	brge	.+22     	; 0x1626 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1610:	89 89       	ldd	r24, Y+17	; 0x11
    1612:	88 23       	and	r24, r24
    1614:	41 f0       	breq	.+16     	; 0x1626 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1616:	c7 01       	movw	r24, r14
    1618:	0e 94 66 07 	call	0xecc	; 0xecc <xTaskRemoveFromEventList>
    161c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    161e:	0e 94 1d 08 	call	0x103a	; 0x103a <vTaskMissedYield>
    1622:	11 50       	subi	r17, 0x01	; 1
    1624:	f3 cf       	rjmp	.-26     	; 0x160c <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1626:	8f ef       	ldi	r24, 0xFF	; 255
    1628:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    162a:	0f 90       	pop	r0
    162c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    162e:	0f b6       	in	r0, 0x3f	; 63
    1630:	f8 94       	cli
    1632:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1634:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1636:	7e 01       	movw	r14, r28
    1638:	88 e0       	ldi	r24, 0x08	; 8
    163a:	e8 0e       	add	r14, r24
    163c:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    163e:	11 16       	cp	r1, r17
    1640:	5c f4       	brge	.+22     	; 0x1658 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1642:	88 85       	ldd	r24, Y+8	; 0x08
    1644:	88 23       	and	r24, r24
    1646:	41 f0       	breq	.+16     	; 0x1658 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1648:	c7 01       	movw	r24, r14
    164a:	0e 94 66 07 	call	0xecc	; 0xecc <xTaskRemoveFromEventList>
    164e:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1650:	0e 94 1d 08 	call	0x103a	; 0x103a <vTaskMissedYield>
    1654:	11 50       	subi	r17, 0x01	; 1
    1656:	f3 cf       	rjmp	.-26     	; 0x163e <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1658:	8f ef       	ldi	r24, 0xFF	; 255
    165a:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    165c:	0f 90       	pop	r0
    165e:	0f be       	out	0x3f, r0	; 63
}
    1660:	df 91       	pop	r29
    1662:	cf 91       	pop	r28
    1664:	1f 91       	pop	r17
    1666:	ff 90       	pop	r15
    1668:	ef 90       	pop	r14
    166a:	08 95       	ret

0000166c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    166c:	cf 93       	push	r28
    166e:	df 93       	push	r29
    1670:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1672:	0f b6       	in	r0, 0x3f	; 63
    1674:	f8 94       	cli
    1676:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1678:	48 81       	ld	r20, Y
    167a:	59 81       	ldd	r21, Y+1	; 0x01
    167c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    167e:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1680:	9a 01       	movw	r18, r20
    1682:	87 9f       	mul	r24, r23
    1684:	20 0d       	add	r18, r0
    1686:	31 1d       	adc	r19, r1
    1688:	11 24       	eor	r1, r1
    168a:	3d 83       	std	Y+5, r19	; 0x05
    168c:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    168e:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1690:	5b 83       	std	Y+3, r21	; 0x03
    1692:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	01 97       	sbiw	r24, 0x01	; 1
    1698:	78 9f       	mul	r23, r24
    169a:	90 01       	movw	r18, r0
    169c:	79 9f       	mul	r23, r25
    169e:	30 0d       	add	r19, r0
    16a0:	11 24       	eor	r1, r1
    16a2:	ca 01       	movw	r24, r20
    16a4:	82 0f       	add	r24, r18
    16a6:	93 1f       	adc	r25, r19
    16a8:	9f 83       	std	Y+7, r25	; 0x07
    16aa:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    16ac:	8f ef       	ldi	r24, 0xFF	; 255
    16ae:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    16b0:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    16b2:	61 11       	cpse	r22, r1
    16b4:	0c c0       	rjmp	.+24     	; 0x16ce <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16b6:	88 85       	ldd	r24, Y+8	; 0x08
    16b8:	88 23       	and	r24, r24
    16ba:	89 f0       	breq	.+34     	; 0x16de <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16bc:	ce 01       	movw	r24, r28
    16be:	08 96       	adiw	r24, 0x08	; 8
    16c0:	0e 94 66 07 	call	0xecc	; 0xecc <xTaskRemoveFromEventList>
    16c4:	88 23       	and	r24, r24
    16c6:	59 f0       	breq	.+22     	; 0x16de <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    16c8:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
    16cc:	08 c0       	rjmp	.+16     	; 0x16de <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    16ce:	ce 01       	movw	r24, r28
    16d0:	08 96       	adiw	r24, 0x08	; 8
    16d2:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    16d6:	ce 01       	movw	r24, r28
    16d8:	41 96       	adiw	r24, 0x11	; 17
    16da:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    16e2:	81 e0       	ldi	r24, 0x01	; 1
    16e4:	df 91       	pop	r29
    16e6:	cf 91       	pop	r28
    16e8:	08 95       	ret

000016ea <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    16ea:	0f 93       	push	r16
    16ec:	1f 93       	push	r17
    16ee:	cf 93       	push	r28
    16f0:	df 93       	push	r29
    16f2:	08 2f       	mov	r16, r24
    16f4:	16 2f       	mov	r17, r22
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    16f6:	86 9f       	mul	r24, r22
    16f8:	c0 01       	movw	r24, r0
    16fa:	11 24       	eor	r1, r1
    16fc:	4f 96       	adiw	r24, 0x1f	; 31
    16fe:	0e 94 c8 11 	call	0x2390	; 0x2390 <pvPortMalloc>
    1702:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1704:	00 97       	sbiw	r24, 0x00	; 0
    1706:	71 f0       	breq	.+28     	; 0x1724 <xQueueGenericCreate+0x3a>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1708:	11 11       	cpse	r17, r1
    170a:	03 c0       	rjmp	.+6      	; 0x1712 <xQueueGenericCreate+0x28>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    170c:	99 83       	std	Y+1, r25	; 0x01
    170e:	88 83       	st	Y, r24
    1710:	03 c0       	rjmp	.+6      	; 0x1718 <xQueueGenericCreate+0x2e>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1712:	4f 96       	adiw	r24, 0x1f	; 31
    1714:	99 83       	std	Y+1, r25	; 0x01
    1716:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1718:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    171a:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    171c:	61 e0       	ldi	r22, 0x01	; 1
    171e:	ce 01       	movw	r24, r28
    1720:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    1724:	ce 01       	movw	r24, r28
    1726:	df 91       	pop	r29
    1728:	cf 91       	pop	r28
    172a:	1f 91       	pop	r17
    172c:	0f 91       	pop	r16
    172e:	08 95       	ret

00001730 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1730:	af 92       	push	r10
    1732:	bf 92       	push	r11
    1734:	cf 92       	push	r12
    1736:	df 92       	push	r13
    1738:	ff 92       	push	r15
    173a:	0f 93       	push	r16
    173c:	1f 93       	push	r17
    173e:	cf 93       	push	r28
    1740:	df 93       	push	r29
    1742:	00 d0       	rcall	.+0      	; 0x1744 <xQueueGenericSend+0x14>
    1744:	00 d0       	rcall	.+0      	; 0x1746 <xQueueGenericSend+0x16>
    1746:	1f 92       	push	r1
    1748:	cd b7       	in	r28, 0x3d	; 61
    174a:	de b7       	in	r29, 0x3e	; 62
    174c:	8c 01       	movw	r16, r24
    174e:	6b 01       	movw	r12, r22
    1750:	5d 83       	std	Y+5, r21	; 0x05
    1752:	4c 83       	std	Y+4, r20	; 0x04
    1754:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1756:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1758:	58 01       	movw	r10, r16
    175a:	98 e0       	ldi	r25, 0x08	; 8
    175c:	a9 0e       	add	r10, r25
    175e:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1766:	f8 01       	movw	r30, r16
    1768:	22 8d       	ldd	r18, Z+26	; 0x1a
    176a:	93 8d       	ldd	r25, Z+27	; 0x1b
    176c:	29 17       	cp	r18, r25
    176e:	18 f0       	brcs	.+6      	; 0x1776 <xQueueGenericSend+0x46>
    1770:	f2 e0       	ldi	r31, 0x02	; 2
    1772:	ff 12       	cpse	r15, r31
    1774:	14 c0       	rjmp	.+40     	; 0x179e <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1776:	4f 2d       	mov	r20, r15
    1778:	b6 01       	movw	r22, r12
    177a:	c8 01       	movw	r24, r16
    177c:	0e 94 96 0a 	call	0x152c	; 0x152c <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1780:	f8 01       	movw	r30, r16
    1782:	91 89       	ldd	r25, Z+17	; 0x11
    1784:	99 23       	and	r25, r25
    1786:	21 f0       	breq	.+8      	; 0x1790 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1788:	c8 01       	movw	r24, r16
    178a:	41 96       	adiw	r24, 0x11	; 17
    178c:	0e 94 66 07 	call	0xecc	; 0xecc <xTaskRemoveFromEventList>
    1790:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1792:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1796:	0f 90       	pop	r0
    1798:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    179a:	81 e0       	ldi	r24, 0x01	; 1
    179c:	50 c0       	rjmp	.+160    	; 0x183e <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    179e:	2c 81       	ldd	r18, Y+4	; 0x04
    17a0:	3d 81       	ldd	r19, Y+5	; 0x05
    17a2:	23 2b       	or	r18, r19
    17a4:	19 f4       	brne	.+6      	; 0x17ac <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    17a6:	0f 90       	pop	r0
    17a8:	0f be       	out	0x3f, r0	; 63
    17aa:	48 c0       	rjmp	.+144    	; 0x183c <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    17ac:	81 11       	cpse	r24, r1
    17ae:	04 c0       	rjmp	.+8      	; 0x17b8 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    17b0:	ce 01       	movw	r24, r28
    17b2:	01 96       	adiw	r24, 0x01	; 1
    17b4:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    17b8:	0f 90       	pop	r0
    17ba:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    17bc:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    17c0:	0f b6       	in	r0, 0x3f	; 63
    17c2:	f8 94       	cli
    17c4:	0f 92       	push	r0
    17c6:	f8 01       	movw	r30, r16
    17c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    17ca:	8f 3f       	cpi	r24, 0xFF	; 255
    17cc:	09 f4       	brne	.+2      	; 0x17d0 <xQueueGenericSend+0xa0>
    17ce:	15 8e       	std	Z+29, r1	; 0x1d
    17d0:	f8 01       	movw	r30, r16
    17d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    17d4:	8f 3f       	cpi	r24, 0xFF	; 255
    17d6:	09 f4       	brne	.+2      	; 0x17da <xQueueGenericSend+0xaa>
    17d8:	16 8e       	std	Z+30, r1	; 0x1e
    17da:	0f 90       	pop	r0
    17dc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    17de:	be 01       	movw	r22, r28
    17e0:	6c 5f       	subi	r22, 0xFC	; 252
    17e2:	7f 4f       	sbci	r23, 0xFF	; 255
    17e4:	ce 01       	movw	r24, r28
    17e6:	01 96       	adiw	r24, 0x01	; 1
    17e8:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <xTaskCheckForTimeOut>
    17ec:	81 11       	cpse	r24, r1
    17ee:	21 c0       	rjmp	.+66     	; 0x1832 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    17f0:	0f b6       	in	r0, 0x3f	; 63
    17f2:	f8 94       	cli
    17f4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    17f6:	f8 01       	movw	r30, r16
    17f8:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    17fa:	0f 90       	pop	r0
    17fc:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    17fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1800:	98 13       	cpse	r25, r24
    1802:	11 c0       	rjmp	.+34     	; 0x1826 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1804:	6c 81       	ldd	r22, Y+4	; 0x04
    1806:	7d 81       	ldd	r23, Y+5	; 0x05
    1808:	c5 01       	movw	r24, r10
    180a:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    180e:	c8 01       	movw	r24, r16
    1810:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1814:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>
    1818:	88 23       	and	r24, r24
    181a:	11 f0       	breq	.+4      	; 0x1820 <xQueueGenericSend+0xf0>
    181c:	81 e0       	ldi	r24, 0x01	; 1
    181e:	a0 cf       	rjmp	.-192    	; 0x1760 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1820:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
    1824:	fb cf       	rjmp	.-10     	; 0x181c <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1826:	c8 01       	movw	r24, r16
    1828:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    182c:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>
    1830:	f5 cf       	rjmp	.-22     	; 0x181c <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1832:	c8 01       	movw	r24, r16
    1834:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1838:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    183c:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    183e:	0f 90       	pop	r0
    1840:	0f 90       	pop	r0
    1842:	0f 90       	pop	r0
    1844:	0f 90       	pop	r0
    1846:	0f 90       	pop	r0
    1848:	df 91       	pop	r29
    184a:	cf 91       	pop	r28
    184c:	1f 91       	pop	r17
    184e:	0f 91       	pop	r16
    1850:	ff 90       	pop	r15
    1852:	df 90       	pop	r13
    1854:	cf 90       	pop	r12
    1856:	bf 90       	pop	r11
    1858:	af 90       	pop	r10
    185a:	08 95       	ret

0000185c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    185c:	ef 92       	push	r14
    185e:	ff 92       	push	r15
    1860:	1f 93       	push	r17
    1862:	cf 93       	push	r28
    1864:	df 93       	push	r29
    1866:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1868:	9a 8d       	ldd	r25, Y+26	; 0x1a
    186a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    186c:	98 17       	cp	r25, r24
    186e:	10 f0       	brcs	.+4      	; 0x1874 <xQueueGenericSendFromISR+0x18>
    1870:	22 30       	cpi	r18, 0x02	; 2
    1872:	e9 f4       	brne	.+58     	; 0x18ae <xQueueGenericSendFromISR+0x52>
    1874:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1876:	1e 8d       	ldd	r17, Y+30	; 0x1e
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    1878:	8a 8d       	ldd	r24, Y+26	; 0x1a
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    187a:	42 2f       	mov	r20, r18
    187c:	ce 01       	movw	r24, r28
    187e:	0e 94 96 0a 	call	0x152c	; 0x152c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1882:	1f 3f       	cpi	r17, 0xFF	; 255
    1884:	81 f4       	brne	.+32     	; 0x18a6 <xQueueGenericSendFromISR+0x4a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1886:	89 89       	ldd	r24, Y+17	; 0x11
    1888:	88 23       	and	r24, r24
    188a:	79 f0       	breq	.+30     	; 0x18aa <xQueueGenericSendFromISR+0x4e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    188c:	ce 01       	movw	r24, r28
    188e:	41 96       	adiw	r24, 0x11	; 17
    1890:	0e 94 66 07 	call	0xecc	; 0xecc <xTaskRemoveFromEventList>
    1894:	88 23       	and	r24, r24
    1896:	49 f0       	breq	.+18     	; 0x18aa <xQueueGenericSendFromISR+0x4e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1898:	e1 14       	cp	r14, r1
    189a:	f1 04       	cpc	r15, r1
    189c:	31 f0       	breq	.+12     	; 0x18aa <xQueueGenericSendFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    189e:	81 e0       	ldi	r24, 0x01	; 1
    18a0:	f7 01       	movw	r30, r14
    18a2:	80 83       	st	Z, r24
    18a4:	05 c0       	rjmp	.+10     	; 0x18b0 <xQueueGenericSendFromISR+0x54>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    18a6:	1f 5f       	subi	r17, 0xFF	; 255
    18a8:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    18aa:	81 e0       	ldi	r24, 0x01	; 1
    18ac:	01 c0       	rjmp	.+2      	; 0x18b0 <xQueueGenericSendFromISR+0x54>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    18ae:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    18b0:	df 91       	pop	r29
    18b2:	cf 91       	pop	r28
    18b4:	1f 91       	pop	r17
    18b6:	ff 90       	pop	r15
    18b8:	ef 90       	pop	r14
    18ba:	08 95       	ret

000018bc <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    18bc:	cf 93       	push	r28
    18be:	df 93       	push	r29
    18c0:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18c2:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    18c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    18c6:	98 17       	cp	r25, r24
    18c8:	c0 f4       	brcc	.+48     	; 0x18fa <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    18ca:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    18cc:	9f 5f       	subi	r25, 0xFF	; 255
    18ce:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    18d0:	8f 3f       	cpi	r24, 0xFF	; 255
    18d2:	79 f4       	brne	.+30     	; 0x18f2 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18d4:	81 89       	ldd	r24, Z+17	; 0x11
    18d6:	88 23       	and	r24, r24
    18d8:	71 f0       	breq	.+28     	; 0x18f6 <xQueueGiveFromISR+0x3a>
    18da:	eb 01       	movw	r28, r22
    18dc:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18de:	41 96       	adiw	r24, 0x11	; 17
    18e0:	0e 94 66 07 	call	0xecc	; 0xecc <xTaskRemoveFromEventList>
    18e4:	88 23       	and	r24, r24
    18e6:	39 f0       	breq	.+14     	; 0x18f6 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    18e8:	20 97       	sbiw	r28, 0x00	; 0
    18ea:	29 f0       	breq	.+10     	; 0x18f6 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	88 83       	st	Y, r24
    18f0:	05 c0       	rjmp	.+10     	; 0x18fc <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    18f2:	8f 5f       	subi	r24, 0xFF	; 255
    18f4:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    18f6:	81 e0       	ldi	r24, 0x01	; 1
    18f8:	01 c0       	rjmp	.+2      	; 0x18fc <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    18fa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    18fc:	df 91       	pop	r29
    18fe:	cf 91       	pop	r28
    1900:	08 95       	ret

00001902 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1902:	af 92       	push	r10
    1904:	bf 92       	push	r11
    1906:	cf 92       	push	r12
    1908:	df 92       	push	r13
    190a:	ff 92       	push	r15
    190c:	0f 93       	push	r16
    190e:	1f 93       	push	r17
    1910:	cf 93       	push	r28
    1912:	df 93       	push	r29
    1914:	00 d0       	rcall	.+0      	; 0x1916 <xQueueReceive+0x14>
    1916:	00 d0       	rcall	.+0      	; 0x1918 <xQueueReceive+0x16>
    1918:	1f 92       	push	r1
    191a:	cd b7       	in	r28, 0x3d	; 61
    191c:	de b7       	in	r29, 0x3e	; 62
    191e:	8c 01       	movw	r16, r24
    1920:	6b 01       	movw	r12, r22
    1922:	5d 83       	std	Y+5, r21	; 0x05
    1924:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1926:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1928:	58 01       	movw	r10, r16
    192a:	91 e1       	ldi	r25, 0x11	; 17
    192c:	a9 0e       	add	r10, r25
    192e:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1930:	0f b6       	in	r0, 0x3f	; 63
    1932:	f8 94       	cli
    1934:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1936:	f8 01       	movw	r30, r16
    1938:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    193a:	ff 20       	and	r15, r15
    193c:	a9 f0       	breq	.+42     	; 0x1968 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    193e:	b6 01       	movw	r22, r12
    1940:	c8 01       	movw	r24, r16
    1942:	0e 94 de 0a 	call	0x15bc	; 0x15bc <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1946:	fa 94       	dec	r15
    1948:	f8 01       	movw	r30, r16
    194a:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    194c:	80 85       	ldd	r24, Z+8	; 0x08
    194e:	88 23       	and	r24, r24
    1950:	39 f0       	breq	.+14     	; 0x1960 <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1952:	c8 01       	movw	r24, r16
    1954:	08 96       	adiw	r24, 0x08	; 8
    1956:	0e 94 66 07 	call	0xecc	; 0xecc <xTaskRemoveFromEventList>
    195a:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    195c:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1960:	0f 90       	pop	r0
    1962:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	50 c0       	rjmp	.+160    	; 0x1a08 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1968:	2c 81       	ldd	r18, Y+4	; 0x04
    196a:	3d 81       	ldd	r19, Y+5	; 0x05
    196c:	23 2b       	or	r18, r19
    196e:	19 f4       	brne	.+6      	; 0x1976 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1970:	0f 90       	pop	r0
    1972:	0f be       	out	0x3f, r0	; 63
    1974:	48 c0       	rjmp	.+144    	; 0x1a06 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1976:	81 11       	cpse	r24, r1
    1978:	04 c0       	rjmp	.+8      	; 0x1982 <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    197a:	ce 01       	movw	r24, r28
    197c:	01 96       	adiw	r24, 0x01	; 1
    197e:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1982:	0f 90       	pop	r0
    1984:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1986:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    198a:	0f b6       	in	r0, 0x3f	; 63
    198c:	f8 94       	cli
    198e:	0f 92       	push	r0
    1990:	f8 01       	movw	r30, r16
    1992:	85 8d       	ldd	r24, Z+29	; 0x1d
    1994:	8f 3f       	cpi	r24, 0xFF	; 255
    1996:	09 f4       	brne	.+2      	; 0x199a <xQueueReceive+0x98>
    1998:	15 8e       	std	Z+29, r1	; 0x1d
    199a:	f8 01       	movw	r30, r16
    199c:	86 8d       	ldd	r24, Z+30	; 0x1e
    199e:	8f 3f       	cpi	r24, 0xFF	; 255
    19a0:	09 f4       	brne	.+2      	; 0x19a4 <xQueueReceive+0xa2>
    19a2:	16 8e       	std	Z+30, r1	; 0x1e
    19a4:	0f 90       	pop	r0
    19a6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    19a8:	be 01       	movw	r22, r28
    19aa:	6c 5f       	subi	r22, 0xFC	; 252
    19ac:	7f 4f       	sbci	r23, 0xFF	; 255
    19ae:	ce 01       	movw	r24, r28
    19b0:	01 96       	adiw	r24, 0x01	; 1
    19b2:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <xTaskCheckForTimeOut>
    19b6:	81 11       	cpse	r24, r1
    19b8:	1c c0       	rjmp	.+56     	; 0x19f2 <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    19ba:	c8 01       	movw	r24, r16
    19bc:	0e 94 8b 0a 	call	0x1516	; 0x1516 <prvIsQueueEmpty>
    19c0:	88 23       	and	r24, r24
    19c2:	89 f0       	breq	.+34     	; 0x19e6 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19c4:	6c 81       	ldd	r22, Y+4	; 0x04
    19c6:	7d 81       	ldd	r23, Y+5	; 0x05
    19c8:	c5 01       	movw	r24, r10
    19ca:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    19ce:	c8 01       	movw	r24, r16
    19d0:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    19d4:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>
    19d8:	88 23       	and	r24, r24
    19da:	11 f0       	breq	.+4      	; 0x19e0 <xQueueReceive+0xde>
    19dc:	81 e0       	ldi	r24, 0x01	; 1
    19de:	a8 cf       	rjmp	.-176    	; 0x1930 <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    19e0:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
    19e4:	fb cf       	rjmp	.-10     	; 0x19dc <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    19e6:	c8 01       	movw	r24, r16
    19e8:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19ec:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>
    19f0:	f5 cf       	rjmp	.-22     	; 0x19dc <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    19f2:	c8 01       	movw	r24, r16
    19f4:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19f8:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    19fc:	c8 01       	movw	r24, r16
    19fe:	0e 94 8b 0a 	call	0x1516	; 0x1516 <prvIsQueueEmpty>
    1a02:	88 23       	and	r24, r24
    1a04:	59 f3       	breq	.-42     	; 0x19dc <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1a06:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1a08:	0f 90       	pop	r0
    1a0a:	0f 90       	pop	r0
    1a0c:	0f 90       	pop	r0
    1a0e:	0f 90       	pop	r0
    1a10:	0f 90       	pop	r0
    1a12:	df 91       	pop	r29
    1a14:	cf 91       	pop	r28
    1a16:	1f 91       	pop	r17
    1a18:	0f 91       	pop	r16
    1a1a:	ff 90       	pop	r15
    1a1c:	df 90       	pop	r13
    1a1e:	cf 90       	pop	r12
    1a20:	bf 90       	pop	r11
    1a22:	af 90       	pop	r10
    1a24:	08 95       	ret

00001a26 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1a26:	ef 92       	push	r14
    1a28:	ff 92       	push	r15
    1a2a:	0f 93       	push	r16
    1a2c:	1f 93       	push	r17
    1a2e:	cf 93       	push	r28
    1a30:	df 93       	push	r29
    1a32:	00 d0       	rcall	.+0      	; 0x1a34 <xQueueSemaphoreTake+0xe>
    1a34:	00 d0       	rcall	.+0      	; 0x1a36 <xQueueSemaphoreTake+0x10>
    1a36:	1f 92       	push	r1
    1a38:	cd b7       	in	r28, 0x3d	; 61
    1a3a:	de b7       	in	r29, 0x3e	; 62
    1a3c:	8c 01       	movw	r16, r24
    1a3e:	7d 83       	std	Y+5, r23	; 0x05
    1a40:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1a42:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a44:	78 01       	movw	r14, r16
    1a46:	81 e1       	ldi	r24, 0x11	; 17
    1a48:	e8 0e       	add	r14, r24
    1a4a:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1a4c:	0f b6       	in	r0, 0x3f	; 63
    1a4e:	f8 94       	cli
    1a50:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1a52:	f8 01       	movw	r30, r16
    1a54:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1a56:	88 23       	and	r24, r24
    1a58:	81 f0       	breq	.+32     	; 0x1a7a <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1a5a:	81 50       	subi	r24, 0x01	; 1
    1a5c:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a5e:	80 85       	ldd	r24, Z+8	; 0x08
    1a60:	88 23       	and	r24, r24
    1a62:	39 f0       	breq	.+14     	; 0x1a72 <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a64:	c8 01       	movw	r24, r16
    1a66:	08 96       	adiw	r24, 0x08	; 8
    1a68:	0e 94 66 07 	call	0xecc	; 0xecc <xTaskRemoveFromEventList>
    1a6c:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1a6e:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1a72:	0f 90       	pop	r0
    1a74:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a76:	81 e0       	ldi	r24, 0x01	; 1
    1a78:	50 c0       	rjmp	.+160    	; 0x1b1a <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a7a:	2c 81       	ldd	r18, Y+4	; 0x04
    1a7c:	3d 81       	ldd	r19, Y+5	; 0x05
    1a7e:	23 2b       	or	r18, r19
    1a80:	19 f4       	brne	.+6      	; 0x1a88 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1a82:	0f 90       	pop	r0
    1a84:	0f be       	out	0x3f, r0	; 63
    1a86:	48 c0       	rjmp	.+144    	; 0x1b18 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1a88:	91 11       	cpse	r25, r1
    1a8a:	04 c0       	rjmp	.+8      	; 0x1a94 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1a8c:	ce 01       	movw	r24, r28
    1a8e:	01 96       	adiw	r24, 0x01	; 1
    1a90:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a94:	0f 90       	pop	r0
    1a96:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a98:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a9c:	0f b6       	in	r0, 0x3f	; 63
    1a9e:	f8 94       	cli
    1aa0:	0f 92       	push	r0
    1aa2:	f8 01       	movw	r30, r16
    1aa4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1aa6:	8f 3f       	cpi	r24, 0xFF	; 255
    1aa8:	09 f4       	brne	.+2      	; 0x1aac <xQueueSemaphoreTake+0x86>
    1aaa:	15 8e       	std	Z+29, r1	; 0x1d
    1aac:	f8 01       	movw	r30, r16
    1aae:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ab0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ab2:	09 f4       	brne	.+2      	; 0x1ab6 <xQueueSemaphoreTake+0x90>
    1ab4:	16 8e       	std	Z+30, r1	; 0x1e
    1ab6:	0f 90       	pop	r0
    1ab8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1aba:	be 01       	movw	r22, r28
    1abc:	6c 5f       	subi	r22, 0xFC	; 252
    1abe:	7f 4f       	sbci	r23, 0xFF	; 255
    1ac0:	ce 01       	movw	r24, r28
    1ac2:	01 96       	adiw	r24, 0x01	; 1
    1ac4:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <xTaskCheckForTimeOut>
    1ac8:	81 11       	cpse	r24, r1
    1aca:	1c c0       	rjmp	.+56     	; 0x1b04 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1acc:	c8 01       	movw	r24, r16
    1ace:	0e 94 8b 0a 	call	0x1516	; 0x1516 <prvIsQueueEmpty>
    1ad2:	88 23       	and	r24, r24
    1ad4:	89 f0       	breq	.+34     	; 0x1af8 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ad6:	6c 81       	ldd	r22, Y+4	; 0x04
    1ad8:	7d 81       	ldd	r23, Y+5	; 0x05
    1ada:	c7 01       	movw	r24, r14
    1adc:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ae0:	c8 01       	movw	r24, r16
    1ae2:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ae6:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>
    1aea:	88 23       	and	r24, r24
    1aec:	11 f0       	breq	.+4      	; 0x1af2 <xQueueSemaphoreTake+0xcc>
    1aee:	91 e0       	ldi	r25, 0x01	; 1
    1af0:	ad cf       	rjmp	.-166    	; 0x1a4c <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1af2:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
    1af6:	fb cf       	rjmp	.-10     	; 0x1aee <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1af8:	c8 01       	movw	r24, r16
    1afa:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1afe:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>
    1b02:	f5 cf       	rjmp	.-22     	; 0x1aee <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1b04:	c8 01       	movw	r24, r16
    1b06:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b0a:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b0e:	c8 01       	movw	r24, r16
    1b10:	0e 94 8b 0a 	call	0x1516	; 0x1516 <prvIsQueueEmpty>
    1b14:	88 23       	and	r24, r24
    1b16:	59 f3       	breq	.-42     	; 0x1aee <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1b18:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1b1a:	0f 90       	pop	r0
    1b1c:	0f 90       	pop	r0
    1b1e:	0f 90       	pop	r0
    1b20:	0f 90       	pop	r0
    1b22:	0f 90       	pop	r0
    1b24:	df 91       	pop	r29
    1b26:	cf 91       	pop	r28
    1b28:	1f 91       	pop	r17
    1b2a:	0f 91       	pop	r16
    1b2c:	ff 90       	pop	r15
    1b2e:	ef 90       	pop	r14
    1b30:	08 95       	ret

00001b32 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1b32:	cf 92       	push	r12
    1b34:	df 92       	push	r13
    1b36:	ef 92       	push	r14
    1b38:	ff 92       	push	r15
    1b3a:	0f 93       	push	r16
    1b3c:	1f 93       	push	r17
    1b3e:	cf 93       	push	r28
    1b40:	df 93       	push	r29
    1b42:	00 d0       	rcall	.+0      	; 0x1b44 <xQueuePeek+0x12>
    1b44:	00 d0       	rcall	.+0      	; 0x1b46 <xQueuePeek+0x14>
    1b46:	1f 92       	push	r1
    1b48:	cd b7       	in	r28, 0x3d	; 61
    1b4a:	de b7       	in	r29, 0x3e	; 62
    1b4c:	8c 01       	movw	r16, r24
    1b4e:	7b 01       	movw	r14, r22
    1b50:	5d 83       	std	Y+5, r21	; 0x05
    1b52:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1b54:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b56:	68 01       	movw	r12, r16
    1b58:	91 e1       	ldi	r25, 0x11	; 17
    1b5a:	c9 0e       	add	r12, r25
    1b5c:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1b5e:	0f b6       	in	r0, 0x3f	; 63
    1b60:	f8 94       	cli
    1b62:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b64:	f8 01       	movw	r30, r16
    1b66:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b68:	99 23       	and	r25, r25
    1b6a:	b9 f0       	breq	.+46     	; 0x1b9a <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1b6c:	c6 80       	ldd	r12, Z+6	; 0x06
    1b6e:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b70:	b7 01       	movw	r22, r14
    1b72:	c8 01       	movw	r24, r16
    1b74:	0e 94 de 0a 	call	0x15bc	; 0x15bc <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1b78:	f8 01       	movw	r30, r16
    1b7a:	d7 82       	std	Z+7, r13	; 0x07
    1b7c:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b7e:	81 89       	ldd	r24, Z+17	; 0x11
    1b80:	88 23       	and	r24, r24
    1b82:	39 f0       	breq	.+14     	; 0x1b92 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b84:	c8 01       	movw	r24, r16
    1b86:	41 96       	adiw	r24, 0x11	; 17
    1b88:	0e 94 66 07 	call	0xecc	; 0xecc <xTaskRemoveFromEventList>
    1b8c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1b8e:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1b92:	0f 90       	pop	r0
    1b94:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b96:	81 e0       	ldi	r24, 0x01	; 1
    1b98:	50 c0       	rjmp	.+160    	; 0x1c3a <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b9a:	2c 81       	ldd	r18, Y+4	; 0x04
    1b9c:	3d 81       	ldd	r19, Y+5	; 0x05
    1b9e:	23 2b       	or	r18, r19
    1ba0:	19 f4       	brne	.+6      	; 0x1ba8 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ba2:	0f 90       	pop	r0
    1ba4:	0f be       	out	0x3f, r0	; 63
    1ba6:	48 c0       	rjmp	.+144    	; 0x1c38 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1ba8:	81 11       	cpse	r24, r1
    1baa:	04 c0       	rjmp	.+8      	; 0x1bb4 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1bac:	ce 01       	movw	r24, r28
    1bae:	01 96       	adiw	r24, 0x01	; 1
    1bb0:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1bb4:	0f 90       	pop	r0
    1bb6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1bb8:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1bbc:	0f b6       	in	r0, 0x3f	; 63
    1bbe:	f8 94       	cli
    1bc0:	0f 92       	push	r0
    1bc2:	f8 01       	movw	r30, r16
    1bc4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1bc6:	8f 3f       	cpi	r24, 0xFF	; 255
    1bc8:	09 f4       	brne	.+2      	; 0x1bcc <xQueuePeek+0x9a>
    1bca:	15 8e       	std	Z+29, r1	; 0x1d
    1bcc:	f8 01       	movw	r30, r16
    1bce:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bd0:	8f 3f       	cpi	r24, 0xFF	; 255
    1bd2:	09 f4       	brne	.+2      	; 0x1bd6 <xQueuePeek+0xa4>
    1bd4:	16 8e       	std	Z+30, r1	; 0x1e
    1bd6:	0f 90       	pop	r0
    1bd8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1bda:	be 01       	movw	r22, r28
    1bdc:	6c 5f       	subi	r22, 0xFC	; 252
    1bde:	7f 4f       	sbci	r23, 0xFF	; 255
    1be0:	ce 01       	movw	r24, r28
    1be2:	01 96       	adiw	r24, 0x01	; 1
    1be4:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <xTaskCheckForTimeOut>
    1be8:	81 11       	cpse	r24, r1
    1bea:	1c c0       	rjmp	.+56     	; 0x1c24 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1bec:	c8 01       	movw	r24, r16
    1bee:	0e 94 8b 0a 	call	0x1516	; 0x1516 <prvIsQueueEmpty>
    1bf2:	88 23       	and	r24, r24
    1bf4:	89 f0       	breq	.+34     	; 0x1c18 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bf6:	6c 81       	ldd	r22, Y+4	; 0x04
    1bf8:	7d 81       	ldd	r23, Y+5	; 0x05
    1bfa:	c6 01       	movw	r24, r12
    1bfc:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c00:	c8 01       	movw	r24, r16
    1c02:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c06:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>
    1c0a:	88 23       	and	r24, r24
    1c0c:	11 f0       	breq	.+4      	; 0x1c12 <xQueuePeek+0xe0>
    1c0e:	81 e0       	ldi	r24, 0x01	; 1
    1c10:	a6 cf       	rjmp	.-180    	; 0x1b5e <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    1c12:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vPortYield>
    1c16:	fb cf       	rjmp	.-10     	; 0x1c0e <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1c18:	c8 01       	movw	r24, r16
    1c1a:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c1e:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>
    1c22:	f5 cf       	rjmp	.-22     	; 0x1c0e <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1c24:	c8 01       	movw	r24, r16
    1c26:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c2a:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c2e:	c8 01       	movw	r24, r16
    1c30:	0e 94 8b 0a 	call	0x1516	; 0x1516 <prvIsQueueEmpty>
    1c34:	88 23       	and	r24, r24
    1c36:	59 f3       	breq	.-42     	; 0x1c0e <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1c38:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1c3a:	0f 90       	pop	r0
    1c3c:	0f 90       	pop	r0
    1c3e:	0f 90       	pop	r0
    1c40:	0f 90       	pop	r0
    1c42:	0f 90       	pop	r0
    1c44:	df 91       	pop	r29
    1c46:	cf 91       	pop	r28
    1c48:	1f 91       	pop	r17
    1c4a:	0f 91       	pop	r16
    1c4c:	ff 90       	pop	r15
    1c4e:	ef 90       	pop	r14
    1c50:	df 90       	pop	r13
    1c52:	cf 90       	pop	r12
    1c54:	08 95       	ret

00001c56 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1c56:	ef 92       	push	r14
    1c58:	ff 92       	push	r15
    1c5a:	0f 93       	push	r16
    1c5c:	1f 93       	push	r17
    1c5e:	cf 93       	push	r28
    1c60:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1c62:	fc 01       	movw	r30, r24
    1c64:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c66:	00 23       	and	r16, r16
    1c68:	e9 f0       	breq	.+58     	; 0x1ca4 <xQueueReceiveFromISR+0x4e>
    1c6a:	7a 01       	movw	r14, r20
    1c6c:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1c6e:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c70:	0e 94 de 0a 	call	0x15bc	; 0x15bc <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1c74:	01 50       	subi	r16, 0x01	; 1
    1c76:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1c78:	1f 3f       	cpi	r17, 0xFF	; 255
    1c7a:	81 f4       	brne	.+32     	; 0x1c9c <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c7c:	88 85       	ldd	r24, Y+8	; 0x08
    1c7e:	88 23       	and	r24, r24
    1c80:	79 f0       	breq	.+30     	; 0x1ca0 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c82:	ce 01       	movw	r24, r28
    1c84:	08 96       	adiw	r24, 0x08	; 8
    1c86:	0e 94 66 07 	call	0xecc	; 0xecc <xTaskRemoveFromEventList>
    1c8a:	88 23       	and	r24, r24
    1c8c:	49 f0       	breq	.+18     	; 0x1ca0 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1c8e:	e1 14       	cp	r14, r1
    1c90:	f1 04       	cpc	r15, r1
    1c92:	31 f0       	breq	.+12     	; 0x1ca0 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1c94:	81 e0       	ldi	r24, 0x01	; 1
    1c96:	f7 01       	movw	r30, r14
    1c98:	80 83       	st	Z, r24
    1c9a:	05 c0       	rjmp	.+10     	; 0x1ca6 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1c9c:	1f 5f       	subi	r17, 0xFF	; 255
    1c9e:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1ca0:	81 e0       	ldi	r24, 0x01	; 1
    1ca2:	01 c0       	rjmp	.+2      	; 0x1ca6 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1ca4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1ca6:	df 91       	pop	r29
    1ca8:	cf 91       	pop	r28
    1caa:	1f 91       	pop	r17
    1cac:	0f 91       	pop	r16
    1cae:	ff 90       	pop	r15
    1cb0:	ef 90       	pop	r14
    1cb2:	08 95       	ret

00001cb4 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1cb4:	0f 93       	push	r16
    1cb6:	1f 93       	push	r17
    1cb8:	cf 93       	push	r28
    1cba:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1cbc:	fc 01       	movw	r30, r24
    1cbe:	22 8d       	ldd	r18, Z+26	; 0x1a
    1cc0:	22 23       	and	r18, r18
    1cc2:	49 f0       	breq	.+18     	; 0x1cd6 <xQueuePeekFromISR+0x22>
    1cc4:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1cc6:	06 81       	ldd	r16, Z+6	; 0x06
    1cc8:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1cca:	0e 94 de 0a 	call	0x15bc	; 0x15bc <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1cce:	1f 83       	std	Y+7, r17	; 0x07
    1cd0:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1cd2:	81 e0       	ldi	r24, 0x01	; 1
    1cd4:	01 c0       	rjmp	.+2      	; 0x1cd8 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1cd6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1cd8:	df 91       	pop	r29
    1cda:	cf 91       	pop	r28
    1cdc:	1f 91       	pop	r17
    1cde:	0f 91       	pop	r16
    1ce0:	08 95       	ret

00001ce2 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1ce2:	0f b6       	in	r0, 0x3f	; 63
    1ce4:	f8 94       	cli
    1ce6:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1ce8:	fc 01       	movw	r30, r24
    1cea:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1cec:	0f 90       	pop	r0
    1cee:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1cf0:	08 95       	ret

00001cf2 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	f8 94       	cli
    1cf6:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1cf8:	fc 01       	movw	r30, r24
    1cfa:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1cfc:	0f 90       	pop	r0
    1cfe:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1d00:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1d02:	82 1b       	sub	r24, r18
    1d04:	08 95       	ret

00001d06 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1d06:	fc 01       	movw	r30, r24
    1d08:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1d0a:	08 95       	ret

00001d0c <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1d0c:	0c 94 fa 11 	jmp	0x23f4	; 0x23f4 <vPortFree>

00001d10 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1d10:	fc 01       	movw	r30, r24
    1d12:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1d14:	81 e0       	ldi	r24, 0x01	; 1
    1d16:	91 11       	cpse	r25, r1
    1d18:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1d1a:	08 95       	ret

00001d1c <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1d1c:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1d1e:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1d20:	81 e0       	ldi	r24, 0x01	; 1
    1d22:	23 8d       	ldd	r18, Z+27	; 0x1b
    1d24:	29 13       	cpse	r18, r25
    1d26:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1d28:	08 95       	ret

00001d2a <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1d2a:	cf 93       	push	r28
    1d2c:	df 93       	push	r29
    1d2e:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1d30:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1d32:	0f b6       	in	r0, 0x3f	; 63
    1d34:	f8 94       	cli
    1d36:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1d38:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d3a:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1d3c:	0f 90       	pop	r0
    1d3e:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1d40:	89 13       	cpse	r24, r25
    1d42:	0f c0       	rjmp	.+30     	; 0x1d62 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1d44:	41 15       	cp	r20, r1
    1d46:	51 05       	cpc	r21, r1
    1d48:	49 f0       	breq	.+18     	; 0x1d5c <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1d4a:	be 01       	movw	r22, r28
    1d4c:	68 5f       	subi	r22, 0xF8	; 248
    1d4e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d50:	ca 01       	movw	r24, r20
    1d52:	0e 94 74 10 	call	0x20e8	; 0x20e8 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1d56:	78 94       	sei
					return errQUEUE_BLOCKED;
    1d58:	8c ef       	ldi	r24, 0xFC	; 252
    1d5a:	1b c0       	rjmp	.+54     	; 0x1d92 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1d5c:	78 94       	sei
					return errQUEUE_FULL;
    1d5e:	80 e0       	ldi	r24, 0x00	; 0
    1d60:	18 c0       	rjmp	.+48     	; 0x1d92 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1d62:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1d64:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d66:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d68:	89 17       	cp	r24, r25
    1d6a:	88 f4       	brcc	.+34     	; 0x1d8e <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1d6c:	40 e0       	ldi	r20, 0x00	; 0
    1d6e:	ce 01       	movw	r24, r28
    1d70:	0e 94 96 0a 	call	0x152c	; 0x152c <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d74:	89 89       	ldd	r24, Y+17	; 0x11
    1d76:	81 11       	cpse	r24, r1
    1d78:	02 c0       	rjmp	.+4      	; 0x1d7e <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1d7a:	81 e0       	ldi	r24, 0x01	; 1
    1d7c:	09 c0       	rjmp	.+18     	; 0x1d90 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d7e:	ce 01       	movw	r24, r28
    1d80:	41 96       	adiw	r24, 0x11	; 17
    1d82:	0e 94 a3 11 	call	0x2346	; 0x2346 <xCoRoutineRemoveFromEventList>
    1d86:	88 23       	and	r24, r24
    1d88:	c1 f3       	breq	.-16     	; 0x1d7a <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1d8a:	8b ef       	ldi	r24, 0xFB	; 251
    1d8c:	01 c0       	rjmp	.+2      	; 0x1d90 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1d8e:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1d90:	78 94       	sei

		return xReturn;
	}
    1d92:	df 91       	pop	r29
    1d94:	cf 91       	pop	r28
    1d96:	08 95       	ret

00001d98 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1d98:	cf 93       	push	r28
    1d9a:	df 93       	push	r29
    1d9c:	ec 01       	movw	r28, r24
    1d9e:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1da0:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1da2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1da4:	81 11       	cpse	r24, r1
    1da6:	0f c0       	rjmp	.+30     	; 0x1dc6 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1da8:	41 15       	cp	r20, r1
    1daa:	51 05       	cpc	r21, r1
    1dac:	49 f0       	breq	.+18     	; 0x1dc0 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1dae:	be 01       	movw	r22, r28
    1db0:	6f 5e       	subi	r22, 0xEF	; 239
    1db2:	7f 4f       	sbci	r23, 0xFF	; 255
    1db4:	ca 01       	movw	r24, r20
    1db6:	0e 94 74 10 	call	0x20e8	; 0x20e8 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1dba:	78 94       	sei
					return errQUEUE_BLOCKED;
    1dbc:	8c ef       	ldi	r24, 0xFC	; 252
    1dbe:	30 c0       	rjmp	.+96     	; 0x1e20 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1dc0:	78 94       	sei
					return errQUEUE_FULL;
    1dc2:	80 e0       	ldi	r24, 0x00	; 0
    1dc4:	2d c0       	rjmp	.+90     	; 0x1e20 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1dc6:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1dc8:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1dca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1dcc:	88 23       	and	r24, r24
    1dce:	31 f1       	breq	.+76     	; 0x1e1c <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1dd0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1dd2:	50 e0       	ldi	r21, 0x00	; 0
    1dd4:	2e 81       	ldd	r18, Y+6	; 0x06
    1dd6:	3f 81       	ldd	r19, Y+7	; 0x07
    1dd8:	24 0f       	add	r18, r20
    1dda:	35 1f       	adc	r19, r21
    1ddc:	3f 83       	std	Y+7, r19	; 0x07
    1dde:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1de0:	8c 81       	ldd	r24, Y+4	; 0x04
    1de2:	9d 81       	ldd	r25, Y+5	; 0x05
    1de4:	28 17       	cp	r18, r24
    1de6:	39 07       	cpc	r19, r25
    1de8:	20 f0       	brcs	.+8      	; 0x1df2 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1dea:	88 81       	ld	r24, Y
    1dec:	99 81       	ldd	r25, Y+1	; 0x01
    1dee:	9f 83       	std	Y+7, r25	; 0x07
    1df0:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1df2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1df4:	91 50       	subi	r25, 0x01	; 1
    1df6:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1df8:	6e 81       	ldd	r22, Y+6	; 0x06
    1dfa:	7f 81       	ldd	r23, Y+7	; 0x07
    1dfc:	cf 01       	movw	r24, r30
    1dfe:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e02:	88 85       	ldd	r24, Y+8	; 0x08
    1e04:	81 11       	cpse	r24, r1
    1e06:	02 c0       	rjmp	.+4      	; 0x1e0c <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1e08:	81 e0       	ldi	r24, 0x01	; 1
    1e0a:	09 c0       	rjmp	.+18     	; 0x1e1e <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e0c:	ce 01       	movw	r24, r28
    1e0e:	08 96       	adiw	r24, 0x08	; 8
    1e10:	0e 94 a3 11 	call	0x2346	; 0x2346 <xCoRoutineRemoveFromEventList>
    1e14:	88 23       	and	r24, r24
    1e16:	c1 f3       	breq	.-16     	; 0x1e08 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1e18:	8b ef       	ldi	r24, 0xFB	; 251
    1e1a:	01 c0       	rjmp	.+2      	; 0x1e1e <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1e1c:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1e1e:	78 94       	sei

		return xReturn;
	}
    1e20:	df 91       	pop	r29
    1e22:	cf 91       	pop	r28
    1e24:	08 95       	ret

00001e26 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1e26:	0f 93       	push	r16
    1e28:	1f 93       	push	r17
    1e2a:	cf 93       	push	r28
    1e2c:	8c 01       	movw	r16, r24
    1e2e:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e30:	fc 01       	movw	r30, r24
    1e32:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e34:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e36:	98 17       	cp	r25, r24
    1e38:	10 f0       	brcs	.+4      	; 0x1e3e <xQueueCRSendFromISR+0x18>
    1e3a:	4c 2f       	mov	r20, r28
    1e3c:	12 c0       	rjmp	.+36     	; 0x1e62 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1e3e:	40 e0       	ldi	r20, 0x00	; 0
    1e40:	c8 01       	movw	r24, r16
    1e42:	0e 94 96 0a 	call	0x152c	; 0x152c <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1e46:	c1 11       	cpse	r28, r1
    1e48:	f8 cf       	rjmp	.-16     	; 0x1e3a <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e4a:	f8 01       	movw	r30, r16
    1e4c:	81 89       	ldd	r24, Z+17	; 0x11
    1e4e:	88 23       	and	r24, r24
    1e50:	39 f0       	breq	.+14     	; 0x1e60 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e52:	c8 01       	movw	r24, r16
    1e54:	41 96       	adiw	r24, 0x11	; 17
    1e56:	0e 94 a3 11 	call	0x2346	; 0x2346 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1e5a:	41 e0       	ldi	r20, 0x01	; 1
    1e5c:	81 11       	cpse	r24, r1
    1e5e:	01 c0       	rjmp	.+2      	; 0x1e62 <xQueueCRSendFromISR+0x3c>
    1e60:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1e62:	84 2f       	mov	r24, r20
    1e64:	cf 91       	pop	r28
    1e66:	1f 91       	pop	r17
    1e68:	0f 91       	pop	r16
    1e6a:	08 95       	ret

00001e6c <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1e6c:	0f 93       	push	r16
    1e6e:	1f 93       	push	r17
    1e70:	cf 93       	push	r28
    1e72:	df 93       	push	r29
    1e74:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e76:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e78:	88 23       	and	r24, r24
    1e7a:	79 f1       	breq	.+94     	; 0x1eda <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1e7c:	24 8d       	ldd	r18, Z+28	; 0x1c
    1e7e:	30 e0       	ldi	r19, 0x00	; 0
    1e80:	a6 81       	ldd	r26, Z+6	; 0x06
    1e82:	b7 81       	ldd	r27, Z+7	; 0x07
    1e84:	a2 0f       	add	r26, r18
    1e86:	b3 1f       	adc	r27, r19
    1e88:	b7 83       	std	Z+7, r27	; 0x07
    1e8a:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1e8c:	84 81       	ldd	r24, Z+4	; 0x04
    1e8e:	95 81       	ldd	r25, Z+5	; 0x05
    1e90:	a8 17       	cp	r26, r24
    1e92:	b9 07       	cpc	r27, r25
    1e94:	20 f0       	brcs	.+8      	; 0x1e9e <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1e96:	80 81       	ld	r24, Z
    1e98:	91 81       	ldd	r25, Z+1	; 0x01
    1e9a:	97 83       	std	Z+7, r25	; 0x07
    1e9c:	86 83       	std	Z+6, r24	; 0x06
    1e9e:	8a 01       	movw	r16, r20
    1ea0:	cb 01       	movw	r24, r22
    1ea2:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1ea4:	42 8d       	ldd	r20, Z+26	; 0x1a
    1ea6:	41 50       	subi	r20, 0x01	; 1
    1ea8:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1eaa:	66 81       	ldd	r22, Z+6	; 0x06
    1eac:	77 81       	ldd	r23, Z+7	; 0x07
    1eae:	a9 01       	movw	r20, r18
    1eb0:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1eb4:	f8 01       	movw	r30, r16
    1eb6:	80 81       	ld	r24, Z
    1eb8:	88 23       	and	r24, r24
    1eba:	11 f0       	breq	.+4      	; 0x1ec0 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1ebc:	81 e0       	ldi	r24, 0x01	; 1
    1ebe:	0e c0       	rjmp	.+28     	; 0x1edc <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ec0:	88 85       	ldd	r24, Y+8	; 0x08
    1ec2:	88 23       	and	r24, r24
    1ec4:	d9 f3       	breq	.-10     	; 0x1ebc <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ec6:	ce 01       	movw	r24, r28
    1ec8:	08 96       	adiw	r24, 0x08	; 8
    1eca:	0e 94 a3 11 	call	0x2346	; 0x2346 <xCoRoutineRemoveFromEventList>
    1ece:	88 23       	and	r24, r24
    1ed0:	a9 f3       	breq	.-22     	; 0x1ebc <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1ed2:	81 e0       	ldi	r24, 0x01	; 1
    1ed4:	f8 01       	movw	r30, r16
    1ed6:	80 83       	st	Z, r24
    1ed8:	01 c0       	rjmp	.+2      	; 0x1edc <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1eda:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1edc:	df 91       	pop	r29
    1ede:	cf 91       	pop	r28
    1ee0:	1f 91       	pop	r17
    1ee2:	0f 91       	pop	r16
    1ee4:	08 95       	ret

00001ee6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1ee6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ee8:	03 96       	adiw	r24, 0x03	; 3
    1eea:	92 83       	std	Z+2, r25	; 0x02
    1eec:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1eee:	2f ef       	ldi	r18, 0xFF	; 255
    1ef0:	3f ef       	ldi	r19, 0xFF	; 255
    1ef2:	34 83       	std	Z+4, r19	; 0x04
    1ef4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ef6:	96 83       	std	Z+6, r25	; 0x06
    1ef8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1efa:	90 87       	std	Z+8, r25	; 0x08
    1efc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1efe:	10 82       	st	Z, r1
    1f00:	08 95       	ret

00001f02 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1f02:	fc 01       	movw	r30, r24
    1f04:	11 86       	std	Z+9, r1	; 0x09
    1f06:	10 86       	std	Z+8, r1	; 0x08
    1f08:	08 95       	ret

00001f0a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1f0a:	cf 93       	push	r28
    1f0c:	df 93       	push	r29
    1f0e:	9c 01       	movw	r18, r24
    1f10:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1f12:	dc 01       	movw	r26, r24
    1f14:	11 96       	adiw	r26, 0x01	; 1
    1f16:	cd 91       	ld	r28, X+
    1f18:	dc 91       	ld	r29, X
    1f1a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1f1c:	d3 83       	std	Z+3, r29	; 0x03
    1f1e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1f20:	8c 81       	ldd	r24, Y+4	; 0x04
    1f22:	9d 81       	ldd	r25, Y+5	; 0x05
    1f24:	95 83       	std	Z+5, r25	; 0x05
    1f26:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1f28:	8c 81       	ldd	r24, Y+4	; 0x04
    1f2a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f2c:	dc 01       	movw	r26, r24
    1f2e:	13 96       	adiw	r26, 0x03	; 3
    1f30:	7c 93       	st	X, r23
    1f32:	6e 93       	st	-X, r22
    1f34:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1f36:	7d 83       	std	Y+5, r23	; 0x05
    1f38:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1f3a:	31 87       	std	Z+9, r19	; 0x09
    1f3c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1f3e:	f9 01       	movw	r30, r18
    1f40:	80 81       	ld	r24, Z
    1f42:	8f 5f       	subi	r24, 0xFF	; 255
    1f44:	80 83       	st	Z, r24
}
    1f46:	df 91       	pop	r29
    1f48:	cf 91       	pop	r28
    1f4a:	08 95       	ret

00001f4c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1f4c:	0f 93       	push	r16
    1f4e:	1f 93       	push	r17
    1f50:	cf 93       	push	r28
    1f52:	df 93       	push	r29
    1f54:	8c 01       	movw	r16, r24
    1f56:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1f58:	80 81       	ld	r24, Z
    1f5a:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1f5c:	8f 3f       	cpi	r24, 0xFF	; 255
    1f5e:	2f ef       	ldi	r18, 0xFF	; 255
    1f60:	92 07       	cpc	r25, r18
    1f62:	21 f4       	brne	.+8      	; 0x1f6c <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1f64:	e8 01       	movw	r28, r16
    1f66:	af 81       	ldd	r26, Y+7	; 0x07
    1f68:	b8 85       	ldd	r27, Y+8	; 0x08
    1f6a:	0e c0       	rjmp	.+28     	; 0x1f88 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1f6c:	d8 01       	movw	r26, r16
    1f6e:	13 96       	adiw	r26, 0x03	; 3
    1f70:	12 96       	adiw	r26, 0x02	; 2
    1f72:	2d 91       	ld	r18, X+
    1f74:	3c 91       	ld	r19, X
    1f76:	13 97       	sbiw	r26, 0x03	; 3
    1f78:	e9 01       	movw	r28, r18
    1f7a:	48 81       	ld	r20, Y
    1f7c:	59 81       	ldd	r21, Y+1	; 0x01
    1f7e:	84 17       	cp	r24, r20
    1f80:	95 07       	cpc	r25, r21
    1f82:	10 f0       	brcs	.+4      	; 0x1f88 <vListInsert+0x3c>
    1f84:	d9 01       	movw	r26, r18
    1f86:	f4 cf       	rjmp	.-24     	; 0x1f70 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1f88:	12 96       	adiw	r26, 0x02	; 2
    1f8a:	8d 91       	ld	r24, X+
    1f8c:	9c 91       	ld	r25, X
    1f8e:	13 97       	sbiw	r26, 0x03	; 3
    1f90:	93 83       	std	Z+3, r25	; 0x03
    1f92:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1f94:	ec 01       	movw	r28, r24
    1f96:	fd 83       	std	Y+5, r31	; 0x05
    1f98:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1f9a:	b5 83       	std	Z+5, r27	; 0x05
    1f9c:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1f9e:	13 96       	adiw	r26, 0x03	; 3
    1fa0:	fc 93       	st	X, r31
    1fa2:	ee 93       	st	-X, r30
    1fa4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1fa6:	11 87       	std	Z+9, r17	; 0x09
    1fa8:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1faa:	f8 01       	movw	r30, r16
    1fac:	80 81       	ld	r24, Z
    1fae:	8f 5f       	subi	r24, 0xFF	; 255
    1fb0:	80 83       	st	Z, r24
}
    1fb2:	df 91       	pop	r29
    1fb4:	cf 91       	pop	r28
    1fb6:	1f 91       	pop	r17
    1fb8:	0f 91       	pop	r16
    1fba:	08 95       	ret

00001fbc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1fbc:	cf 93       	push	r28
    1fbe:	df 93       	push	r29
    1fc0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1fc2:	a0 85       	ldd	r26, Z+8	; 0x08
    1fc4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1fc6:	82 81       	ldd	r24, Z+2	; 0x02
    1fc8:	93 81       	ldd	r25, Z+3	; 0x03
    1fca:	24 81       	ldd	r18, Z+4	; 0x04
    1fcc:	35 81       	ldd	r19, Z+5	; 0x05
    1fce:	ec 01       	movw	r28, r24
    1fd0:	3d 83       	std	Y+5, r19	; 0x05
    1fd2:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1fd4:	c4 81       	ldd	r28, Z+4	; 0x04
    1fd6:	d5 81       	ldd	r29, Z+5	; 0x05
    1fd8:	9b 83       	std	Y+3, r25	; 0x03
    1fda:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1fdc:	11 96       	adiw	r26, 0x01	; 1
    1fde:	8d 91       	ld	r24, X+
    1fe0:	9c 91       	ld	r25, X
    1fe2:	12 97       	sbiw	r26, 0x02	; 2
    1fe4:	e8 17       	cp	r30, r24
    1fe6:	f9 07       	cpc	r31, r25
    1fe8:	21 f4       	brne	.+8      	; 0x1ff2 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1fea:	12 96       	adiw	r26, 0x02	; 2
    1fec:	dc 93       	st	X, r29
    1fee:	ce 93       	st	-X, r28
    1ff0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1ff2:	11 86       	std	Z+9, r1	; 0x09
    1ff4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1ff6:	8c 91       	ld	r24, X
    1ff8:	81 50       	subi	r24, 0x01	; 1
    1ffa:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1ffc:	8c 91       	ld	r24, X
}
    1ffe:	df 91       	pop	r29
    2000:	cf 91       	pop	r28
    2002:	08 95       	ret

00002004 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    2004:	cf 92       	push	r12
    2006:	df 92       	push	r13
    2008:	ef 92       	push	r14
    200a:	ff 92       	push	r15
    200c:	1f 93       	push	r17
    200e:	cf 93       	push	r28
    2010:	df 93       	push	r29
    2012:	6c 01       	movw	r12, r24
    2014:	16 2f       	mov	r17, r22
    2016:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    2018:	8a e1       	ldi	r24, 0x1A	; 26
    201a:	90 e0       	ldi	r25, 0x00	; 0
    201c:	0e 94 c8 11 	call	0x2390	; 0x2390 <pvPortMalloc>
    2020:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    2022:	89 2b       	or	r24, r25
    2024:	09 f4       	brne	.+2      	; 0x2028 <xCoRoutineCreate+0x24>
    2026:	57 c0       	rjmp	.+174    	; 0x20d6 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2028:	80 91 b4 01 	lds	r24, 0x01B4	; 0x8001b4 <pxCurrentCoRoutine>
    202c:	90 91 b5 01 	lds	r25, 0x01B5	; 0x8001b5 <pxCurrentCoRoutine+0x1>
    2030:	89 2b       	or	r24, r25
    2032:	21 f5       	brne	.+72     	; 0x207c <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2034:	d0 93 b5 01 	sts	0x01B5, r29	; 0x8001b5 <pxCurrentCoRoutine+0x1>
    2038:	c0 93 b4 01 	sts	0x01B4, r28	; 0x8001b4 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    203c:	8c ed       	ldi	r24, 0xDC	; 220
    203e:	91 e0       	ldi	r25, 0x01	; 1
    2040:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
    2044:	85 ee       	ldi	r24, 0xE5	; 229
    2046:	91 e0       	ldi	r25, 0x01	; 1
    2048:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    204c:	83 ed       	ldi	r24, 0xD3	; 211
    204e:	91 e0       	ldi	r25, 0x01	; 1
    2050:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    2054:	8a ec       	ldi	r24, 0xCA	; 202
    2056:	91 e0       	ldi	r25, 0x01	; 1
    2058:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    205c:	8d eb       	ldi	r24, 0xBD	; 189
    205e:	91 e0       	ldi	r25, 0x01	; 1
    2060:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2064:	83 ed       	ldi	r24, 0xD3	; 211
    2066:	91 e0       	ldi	r25, 0x01	; 1
    2068:	90 93 c9 01 	sts	0x01C9, r25	; 0x8001c9 <pxDelayedCoRoutineList+0x1>
    206c:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2070:	8a ec       	ldi	r24, 0xCA	; 202
    2072:	91 e0       	ldi	r25, 0x01	; 1
    2074:	90 93 c7 01 	sts	0x01C7, r25	; 0x8001c7 <pxOverflowDelayedCoRoutineList+0x1>
    2078:	80 93 c6 01 	sts	0x01C6, r24	; 0x8001c6 <pxOverflowDelayedCoRoutineList>
    207c:	11 11       	cpse	r17, r1
    207e:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2080:	19 8e       	std	Y+25, r1	; 0x19
    2082:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2084:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2086:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2088:	fe 01       	movw	r30, r28
    208a:	c1 92       	st	Z+, r12
    208c:	d1 92       	st	Z+, r13
    208e:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2090:	cf 01       	movw	r24, r30
    2092:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2096:	ce 01       	movw	r24, r28
    2098:	0c 96       	adiw	r24, 0x0c	; 12
    209a:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    209e:	d9 87       	std	Y+9, r29	; 0x09
    20a0:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    20a2:	db 8b       	std	Y+19, r29	; 0x13
    20a4:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    20a6:	82 e0       	ldi	r24, 0x02	; 2
    20a8:	90 e0       	ldi	r25, 0x00	; 0
    20aa:	81 1b       	sub	r24, r17
    20ac:	91 09       	sbc	r25, r1
    20ae:	9d 87       	std	Y+13, r25	; 0x0d
    20b0:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    20b2:	8e 89       	ldd	r24, Y+22	; 0x16
    20b4:	90 91 bc 01 	lds	r25, 0x01BC	; 0x8001bc <uxTopCoRoutineReadyPriority>
    20b8:	98 17       	cp	r25, r24
    20ba:	10 f4       	brcc	.+4      	; 0x20c0 <xCoRoutineCreate+0xbc>
    20bc:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <uxTopCoRoutineReadyPriority>
    20c0:	f9 e0       	ldi	r31, 0x09	; 9
    20c2:	8f 9f       	mul	r24, r31
    20c4:	c0 01       	movw	r24, r0
    20c6:	11 24       	eor	r1, r1
    20c8:	b7 01       	movw	r22, r14
    20ca:	84 52       	subi	r24, 0x24	; 36
    20cc:	9e 4f       	sbci	r25, 0xFE	; 254
    20ce:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>

		xReturn = pdPASS;
    20d2:	81 e0       	ldi	r24, 0x01	; 1
    20d4:	01 c0       	rjmp	.+2      	; 0x20d8 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    20d6:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    20d8:	df 91       	pop	r29
    20da:	cf 91       	pop	r28
    20dc:	1f 91       	pop	r17
    20de:	ff 90       	pop	r15
    20e0:	ef 90       	pop	r14
    20e2:	df 90       	pop	r13
    20e4:	cf 90       	pop	r12
    20e6:	08 95       	ret

000020e8 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    20e8:	0f 93       	push	r16
    20ea:	1f 93       	push	r17
    20ec:	cf 93       	push	r28
    20ee:	df 93       	push	r29
    20f0:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    20f2:	c0 91 ba 01 	lds	r28, 0x01BA	; 0x8001ba <xCoRoutineTickCount>
    20f6:	d0 91 bb 01 	lds	r29, 0x01BB	; 0x8001bb <xCoRoutineTickCount+0x1>
    20fa:	c8 0f       	add	r28, r24
    20fc:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    20fe:	80 91 b4 01 	lds	r24, 0x01B4	; 0x8001b4 <pxCurrentCoRoutine>
    2102:	90 91 b5 01 	lds	r25, 0x01B5	; 0x8001b5 <pxCurrentCoRoutine+0x1>
    2106:	02 96       	adiw	r24, 0x02	; 2
    2108:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    210c:	e0 91 b4 01 	lds	r30, 0x01B4	; 0x8001b4 <pxCurrentCoRoutine>
    2110:	f0 91 b5 01 	lds	r31, 0x01B5	; 0x8001b5 <pxCurrentCoRoutine+0x1>
    2114:	d3 83       	std	Z+3, r29	; 0x03
    2116:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2118:	80 91 ba 01 	lds	r24, 0x01BA	; 0x8001ba <xCoRoutineTickCount>
    211c:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <xCoRoutineTickCount+0x1>
    2120:	bf 01       	movw	r22, r30
    2122:	6e 5f       	subi	r22, 0xFE	; 254
    2124:	7f 4f       	sbci	r23, 0xFF	; 255
    2126:	c8 17       	cp	r28, r24
    2128:	d9 07       	cpc	r29, r25
    212a:	28 f4       	brcc	.+10     	; 0x2136 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    212c:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <pxOverflowDelayedCoRoutineList>
    2130:	90 91 c7 01 	lds	r25, 0x01C7	; 0x8001c7 <pxOverflowDelayedCoRoutineList+0x1>
    2134:	04 c0       	rjmp	.+8      	; 0x213e <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2136:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <pxDelayedCoRoutineList>
    213a:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <pxDelayedCoRoutineList+0x1>
    213e:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <vListInsert>
	}

	if( pxEventList )
    2142:	01 15       	cp	r16, r1
    2144:	11 05       	cpc	r17, r1
    2146:	69 f0       	breq	.+26     	; 0x2162 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2148:	60 91 b4 01 	lds	r22, 0x01B4	; 0x8001b4 <pxCurrentCoRoutine>
    214c:	70 91 b5 01 	lds	r23, 0x01B5	; 0x8001b5 <pxCurrentCoRoutine+0x1>
    2150:	64 5f       	subi	r22, 0xF4	; 244
    2152:	7f 4f       	sbci	r23, 0xFF	; 255
    2154:	c8 01       	movw	r24, r16
	}
}
    2156:	df 91       	pop	r29
    2158:	cf 91       	pop	r28
    215a:	1f 91       	pop	r17
    215c:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    215e:	0c 94 a6 0f 	jmp	0x1f4c	; 0x1f4c <vListInsert>
	}
}
    2162:	df 91       	pop	r29
    2164:	cf 91       	pop	r28
    2166:	1f 91       	pop	r17
    2168:	0f 91       	pop	r16
    216a:	08 95       	ret

0000216c <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    216c:	ff 92       	push	r15
    216e:	0f 93       	push	r16
    2170:	1f 93       	push	r17
    2172:	cf 93       	push	r28
    2174:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2176:	99 e0       	ldi	r25, 0x09	; 9
    2178:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    217a:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <xPendingReadyCoRoutineList>
    217e:	88 23       	and	r24, r24
    2180:	11 f1       	breq	.+68     	; 0x21c6 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2182:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    2184:	e0 91 c2 01 	lds	r30, 0x01C2	; 0x8001c2 <xPendingReadyCoRoutineList+0x5>
    2188:	f0 91 c3 01 	lds	r31, 0x01C3	; 0x8001c3 <xPendingReadyCoRoutineList+0x6>
    218c:	c6 81       	ldd	r28, Z+6	; 0x06
    218e:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2190:	ce 01       	movw	r24, r28
    2192:	0c 96       	adiw	r24, 0x0c	; 12
    2194:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2198:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    219a:	8e 01       	movw	r16, r28
    219c:	0e 5f       	subi	r16, 0xFE	; 254
    219e:	1f 4f       	sbci	r17, 0xFF	; 255
    21a0:	c8 01       	movw	r24, r16
    21a2:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    21a6:	8e 89       	ldd	r24, Y+22	; 0x16
    21a8:	90 91 bc 01 	lds	r25, 0x01BC	; 0x8001bc <uxTopCoRoutineReadyPriority>
    21ac:	98 17       	cp	r25, r24
    21ae:	10 f4       	brcc	.+4      	; 0x21b4 <vCoRoutineSchedule+0x48>
    21b0:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <uxTopCoRoutineReadyPriority>
    21b4:	f8 9e       	mul	r15, r24
    21b6:	c0 01       	movw	r24, r0
    21b8:	11 24       	eor	r1, r1
    21ba:	b8 01       	movw	r22, r16
    21bc:	84 52       	subi	r24, 0x24	; 36
    21be:	9e 4f       	sbci	r25, 0xFE	; 254
    21c0:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>
    21c4:	da cf       	rjmp	.-76     	; 0x217a <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    21c6:	0e 94 60 05 	call	0xac0	; 0xac0 <xTaskGetTickCount>
    21ca:	20 91 b8 01 	lds	r18, 0x01B8	; 0x8001b8 <xLastTickCount>
    21ce:	30 91 b9 01 	lds	r19, 0x01B9	; 0x8001b9 <xLastTickCount+0x1>
    21d2:	82 1b       	sub	r24, r18
    21d4:	93 0b       	sbc	r25, r19
    21d6:	90 93 b7 01 	sts	0x01B7, r25	; 0x8001b7 <xPassedTicks+0x1>
    21da:	80 93 b6 01 	sts	0x01B6, r24	; 0x8001b6 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    21de:	89 e0       	ldi	r24, 0x09	; 9
    21e0:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    21e2:	20 91 b6 01 	lds	r18, 0x01B6	; 0x8001b6 <xPassedTicks>
    21e6:	30 91 b7 01 	lds	r19, 0x01B7	; 0x8001b7 <xPassedTicks+0x1>
    21ea:	80 91 ba 01 	lds	r24, 0x01BA	; 0x8001ba <xCoRoutineTickCount>
    21ee:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <xCoRoutineTickCount+0x1>
    21f2:	21 15       	cp	r18, r1
    21f4:	31 05       	cpc	r19, r1
    21f6:	09 f4       	brne	.+2      	; 0x21fa <vCoRoutineSchedule+0x8e>
    21f8:	54 c0       	rjmp	.+168    	; 0x22a2 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    21fa:	01 96       	adiw	r24, 0x01	; 1
    21fc:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <xCoRoutineTickCount+0x1>
    2200:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <xCoRoutineTickCount>
		xPassedTicks--;
    2204:	21 50       	subi	r18, 0x01	; 1
    2206:	31 09       	sbc	r19, r1
    2208:	30 93 b7 01 	sts	0x01B7, r19	; 0x8001b7 <xPassedTicks+0x1>
    220c:	20 93 b6 01 	sts	0x01B6, r18	; 0x8001b6 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2210:	89 2b       	or	r24, r25
    2212:	09 f0       	breq	.+2      	; 0x2216 <vCoRoutineSchedule+0xaa>
    2214:	3e c0       	rjmp	.+124    	; 0x2292 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2216:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <pxDelayedCoRoutineList>
    221a:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    221e:	20 91 c6 01 	lds	r18, 0x01C6	; 0x8001c6 <pxOverflowDelayedCoRoutineList>
    2222:	30 91 c7 01 	lds	r19, 0x01C7	; 0x8001c7 <pxOverflowDelayedCoRoutineList+0x1>
    2226:	30 93 c9 01 	sts	0x01C9, r19	; 0x8001c9 <pxDelayedCoRoutineList+0x1>
    222a:	20 93 c8 01 	sts	0x01C8, r18	; 0x8001c8 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    222e:	90 93 c7 01 	sts	0x01C7, r25	; 0x8001c7 <pxOverflowDelayedCoRoutineList+0x1>
    2232:	80 93 c6 01 	sts	0x01C6, r24	; 0x8001c6 <pxOverflowDelayedCoRoutineList>
    2236:	2d c0       	rjmp	.+90     	; 0x2292 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2238:	05 80       	ldd	r0, Z+5	; 0x05
    223a:	f6 81       	ldd	r31, Z+6	; 0x06
    223c:	e0 2d       	mov	r30, r0
    223e:	c6 81       	ldd	r28, Z+6	; 0x06
    2240:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    2242:	2a 81       	ldd	r18, Y+2	; 0x02
    2244:	3b 81       	ldd	r19, Y+3	; 0x03
    2246:	80 91 ba 01 	lds	r24, 0x01BA	; 0x8001ba <xCoRoutineTickCount>
    224a:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <xCoRoutineTickCount+0x1>
    224e:	82 17       	cp	r24, r18
    2250:	93 07       	cpc	r25, r19
    2252:	38 f2       	brcs	.-114    	; 0x21e2 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    2254:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    2256:	8e 01       	movw	r16, r28
    2258:	0e 5f       	subi	r16, 0xFE	; 254
    225a:	1f 4f       	sbci	r17, 0xFF	; 255
    225c:	c8 01       	movw	r24, r16
    225e:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    2262:	8c 89       	ldd	r24, Y+20	; 0x14
    2264:	9d 89       	ldd	r25, Y+21	; 0x15
    2266:	89 2b       	or	r24, r25
    2268:	21 f0       	breq	.+8      	; 0x2272 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    226a:	ce 01       	movw	r24, r28
    226c:	0c 96       	adiw	r24, 0x0c	; 12
    226e:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2272:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2274:	8e 89       	ldd	r24, Y+22	; 0x16
    2276:	90 91 bc 01 	lds	r25, 0x01BC	; 0x8001bc <uxTopCoRoutineReadyPriority>
    227a:	98 17       	cp	r25, r24
    227c:	10 f4       	brcc	.+4      	; 0x2282 <vCoRoutineSchedule+0x116>
    227e:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <uxTopCoRoutineReadyPriority>
    2282:	f8 9e       	mul	r15, r24
    2284:	c0 01       	movw	r24, r0
    2286:	11 24       	eor	r1, r1
    2288:	b8 01       	movw	r22, r16
    228a:	84 52       	subi	r24, 0x24	; 36
    228c:	9e 4f       	sbci	r25, 0xFE	; 254
    228e:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2292:	e0 91 c8 01 	lds	r30, 0x01C8	; 0x8001c8 <pxDelayedCoRoutineList>
    2296:	f0 91 c9 01 	lds	r31, 0x01C9	; 0x8001c9 <pxDelayedCoRoutineList+0x1>
    229a:	80 81       	ld	r24, Z
    229c:	81 11       	cpse	r24, r1
    229e:	cc cf       	rjmp	.-104    	; 0x2238 <vCoRoutineSchedule+0xcc>
    22a0:	a0 cf       	rjmp	.-192    	; 0x21e2 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    22a2:	90 93 b9 01 	sts	0x01B9, r25	; 0x8001b9 <xLastTickCount+0x1>
    22a6:	80 93 b8 01 	sts	0x01B8, r24	; 0x8001b8 <xLastTickCount>
    22aa:	80 91 bc 01 	lds	r24, 0x01BC	; 0x8001bc <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    22ae:	69 e0       	ldi	r22, 0x09	; 9
    22b0:	48 2f       	mov	r20, r24
    22b2:	50 e0       	ldi	r21, 0x00	; 0
    22b4:	64 9f       	mul	r22, r20
    22b6:	90 01       	movw	r18, r0
    22b8:	65 9f       	mul	r22, r21
    22ba:	30 0d       	add	r19, r0
    22bc:	11 24       	eor	r1, r1
    22be:	f9 01       	movw	r30, r18
    22c0:	e4 52       	subi	r30, 0x24	; 36
    22c2:	fe 4f       	sbci	r31, 0xFE	; 254
    22c4:	90 81       	ld	r25, Z
    22c6:	91 11       	cpse	r25, r1
    22c8:	0c c0       	rjmp	.+24     	; 0x22e2 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    22ca:	81 11       	cpse	r24, r1
    22cc:	08 c0       	rjmp	.+16     	; 0x22de <vCoRoutineSchedule+0x172>
    22ce:	10 92 bc 01 	sts	0x01BC, r1	; 0x8001bc <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    22d2:	df 91       	pop	r29
    22d4:	cf 91       	pop	r28
    22d6:	1f 91       	pop	r17
    22d8:	0f 91       	pop	r16
    22da:	ff 90       	pop	r15
    22dc:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    22de:	81 50       	subi	r24, 0x01	; 1
    22e0:	e7 cf       	rjmp	.-50     	; 0x22b0 <vCoRoutineSchedule+0x144>
    22e2:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    22e6:	a1 81       	ldd	r26, Z+1	; 0x01
    22e8:	b2 81       	ldd	r27, Z+2	; 0x02
    22ea:	12 96       	adiw	r26, 0x02	; 2
    22ec:	0d 90       	ld	r0, X+
    22ee:	bc 91       	ld	r27, X
    22f0:	a0 2d       	mov	r26, r0
    22f2:	b2 83       	std	Z+2, r27	; 0x02
    22f4:	a1 83       	std	Z+1, r26	; 0x01
    22f6:	21 52       	subi	r18, 0x21	; 33
    22f8:	3e 4f       	sbci	r19, 0xFE	; 254
    22fa:	a2 17       	cp	r26, r18
    22fc:	b3 07       	cpc	r27, r19
    22fe:	31 f4       	brne	.+12     	; 0x230c <vCoRoutineSchedule+0x1a0>
    2300:	12 96       	adiw	r26, 0x02	; 2
    2302:	8d 91       	ld	r24, X+
    2304:	9c 91       	ld	r25, X
    2306:	13 97       	sbiw	r26, 0x03	; 3
    2308:	92 83       	std	Z+2, r25	; 0x02
    230a:	81 83       	std	Z+1, r24	; 0x01
    230c:	89 e0       	ldi	r24, 0x09	; 9
    230e:	84 9f       	mul	r24, r20
    2310:	f0 01       	movw	r30, r0
    2312:	85 9f       	mul	r24, r21
    2314:	f0 0d       	add	r31, r0
    2316:	11 24       	eor	r1, r1
    2318:	e4 52       	subi	r30, 0x24	; 36
    231a:	fe 4f       	sbci	r31, 0xFE	; 254
    231c:	01 80       	ldd	r0, Z+1	; 0x01
    231e:	f2 81       	ldd	r31, Z+2	; 0x02
    2320:	e0 2d       	mov	r30, r0
    2322:	86 81       	ldd	r24, Z+6	; 0x06
    2324:	97 81       	ldd	r25, Z+7	; 0x07
    2326:	90 93 b5 01 	sts	0x01B5, r25	; 0x8001b5 <pxCurrentCoRoutine+0x1>
    232a:	80 93 b4 01 	sts	0x01B4, r24	; 0x8001b4 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    232e:	dc 01       	movw	r26, r24
    2330:	ed 91       	ld	r30, X+
    2332:	fc 91       	ld	r31, X
    2334:	11 97       	sbiw	r26, 0x01	; 1
    2336:	57 96       	adiw	r26, 0x17	; 23
    2338:	6c 91       	ld	r22, X

	return;
}
    233a:	df 91       	pop	r29
    233c:	cf 91       	pop	r28
    233e:	1f 91       	pop	r17
    2340:	0f 91       	pop	r16
    2342:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2344:	09 94       	ijmp

00002346 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2346:	0f 93       	push	r16
    2348:	1f 93       	push	r17
    234a:	cf 93       	push	r28
    234c:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    234e:	dc 01       	movw	r26, r24
    2350:	15 96       	adiw	r26, 0x05	; 5
    2352:	ed 91       	ld	r30, X+
    2354:	fc 91       	ld	r31, X
    2356:	16 97       	sbiw	r26, 0x06	; 6
    2358:	c6 81       	ldd	r28, Z+6	; 0x06
    235a:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    235c:	8e 01       	movw	r16, r28
    235e:	04 5f       	subi	r16, 0xF4	; 244
    2360:	1f 4f       	sbci	r17, 0xFF	; 255
    2362:	c8 01       	movw	r24, r16
    2364:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2368:	b8 01       	movw	r22, r16
    236a:	8d eb       	ldi	r24, 0xBD	; 189
    236c:	91 e0       	ldi	r25, 0x01	; 1
    236e:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2372:	e0 91 b4 01 	lds	r30, 0x01B4	; 0x8001b4 <pxCurrentCoRoutine>
    2376:	f0 91 b5 01 	lds	r31, 0x01B5	; 0x8001b5 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    237a:	81 e0       	ldi	r24, 0x01	; 1
    237c:	2e 89       	ldd	r18, Y+22	; 0x16
    237e:	96 89       	ldd	r25, Z+22	; 0x16
    2380:	29 17       	cp	r18, r25
    2382:	08 f4       	brcc	.+2      	; 0x2386 <xCoRoutineRemoveFromEventList+0x40>
    2384:	80 e0       	ldi	r24, 0x00	; 0
}
    2386:	df 91       	pop	r29
    2388:	cf 91       	pop	r28
    238a:	1f 91       	pop	r17
    238c:	0f 91       	pop	r16
    238e:	08 95       	ret

00002390 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2390:	cf 93       	push	r28
    2392:	df 93       	push	r29
    2394:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2396:	0e 94 5a 05 	call	0xab4	; 0xab4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    239a:	80 91 ee 01 	lds	r24, 0x01EE	; 0x8001ee <pucAlignedHeap.2101>
    239e:	90 91 ef 01 	lds	r25, 0x01EF	; 0x8001ef <pucAlignedHeap.2101+0x1>
    23a2:	89 2b       	or	r24, r25
    23a4:	31 f4       	brne	.+12     	; 0x23b2 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    23a6:	83 ef       	ldi	r24, 0xF3	; 243
    23a8:	91 e0       	ldi	r25, 0x01	; 1
    23aa:	90 93 ef 01 	sts	0x01EF, r25	; 0x8001ef <pucAlignedHeap.2101+0x1>
    23ae:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <pucAlignedHeap.2101>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    23b2:	20 91 f0 01 	lds	r18, 0x01F0	; 0x8001f0 <xNextFreeByte>
    23b6:	30 91 f1 01 	lds	r19, 0x01F1	; 0x8001f1 <xNextFreeByte+0x1>
    23ba:	c9 01       	movw	r24, r18
    23bc:	8c 0f       	add	r24, r28
    23be:	9d 1f       	adc	r25, r29
    23c0:	8b 3d       	cpi	r24, 0xDB	; 219
    23c2:	45 e0       	ldi	r20, 0x05	; 5
    23c4:	94 07       	cpc	r25, r20
    23c6:	70 f4       	brcc	.+28     	; 0x23e4 <pvPortMalloc+0x54>
    23c8:	28 17       	cp	r18, r24
    23ca:	39 07       	cpc	r19, r25
    23cc:	58 f4       	brcc	.+22     	; 0x23e4 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    23ce:	c0 91 ee 01 	lds	r28, 0x01EE	; 0x8001ee <pucAlignedHeap.2101>
    23d2:	d0 91 ef 01 	lds	r29, 0x01EF	; 0x8001ef <pucAlignedHeap.2101+0x1>
    23d6:	c2 0f       	add	r28, r18
    23d8:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    23da:	90 93 f1 01 	sts	0x01F1, r25	; 0x8001f1 <xNextFreeByte+0x1>
    23de:	80 93 f0 01 	sts	0x01F0, r24	; 0x8001f0 <xNextFreeByte>
    23e2:	02 c0       	rjmp	.+4      	; 0x23e8 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    23e4:	c0 e0       	ldi	r28, 0x00	; 0
    23e6:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    23e8:	0e 94 2b 06 	call	0xc56	; 0xc56 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    23ec:	ce 01       	movw	r24, r28
    23ee:	df 91       	pop	r29
    23f0:	cf 91       	pop	r28
    23f2:	08 95       	ret

000023f4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    23f4:	08 95       	ret

000023f6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    23f6:	10 92 f1 01 	sts	0x01F1, r1	; 0x8001f1 <xNextFreeByte+0x1>
    23fa:	10 92 f0 01 	sts	0x01F0, r1	; 0x8001f0 <xNextFreeByte>
    23fe:	08 95       	ret

00002400 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2400:	20 91 f0 01 	lds	r18, 0x01F0	; 0x8001f0 <xNextFreeByte>
    2404:	30 91 f1 01 	lds	r19, 0x01F1	; 0x8001f1 <xNextFreeByte+0x1>
}
    2408:	8b ed       	ldi	r24, 0xDB	; 219
    240a:	95 e0       	ldi	r25, 0x05	; 5
    240c:	82 1b       	sub	r24, r18
    240e:	93 0b       	sbc	r25, r19
    2410:	08 95       	ret

00002412 <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    2412:	0f 93       	push	r16
    2414:	1f 93       	push	r17
    2416:	cf 93       	push	r28
    2418:	df 93       	push	r29
    241a:	1f 92       	push	r1
    241c:	cd b7       	in	r28, 0x3d	; 61
    241e:	de b7       	in	r29, 0x3e	; 62
    2420:	8c 01       	movw	r16, r24
static as we do not need it to maintain their state between blocks. */
BaseType_t xResult;
UBaseType_t uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    2422:	fc 01       	movw	r30, r24
    2424:	80 8d       	ldd	r24, Z+24	; 0x18
    2426:	91 8d       	ldd	r25, Z+25	; 0x19
    2428:	8e 36       	cpi	r24, 0x6E	; 110
    242a:	f1 e0       	ldi	r31, 0x01	; 1
    242c:	9f 07       	cpc	r25, r31
    242e:	b1 f0       	breq	.+44     	; 0x245c <prvFlashCoRoutine+0x4a>
    2430:	8f 36       	cpi	r24, 0x6F	; 111
    2432:	21 e0       	ldi	r18, 0x01	; 1
    2434:	92 07       	cpc	r25, r18
    2436:	51 f1       	breq	.+84     	; 0x248c <prvFlashCoRoutine+0x7a>
    2438:	89 2b       	or	r24, r25
    243a:	59 f5       	brne	.+86     	; 0x2492 <prvFlashCoRoutine+0x80>
	( void ) uxIndex;

	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
    243c:	4f ef       	ldi	r20, 0xFF	; 255
    243e:	5f ef       	ldi	r21, 0xFF	; 255
    2440:	be 01       	movw	r22, r28
    2442:	6f 5f       	subi	r22, 0xFF	; 255
    2444:	7f 4f       	sbci	r23, 0xFF	; 255
    2446:	80 91 ce 07 	lds	r24, 0x07CE	; 0x8007ce <xFlashQueue>
    244a:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <xFlashQueue+0x1>
    244e:	0e 94 cc 0e 	call	0x1d98	; 0x1d98 <xQueueCRReceive>
    2452:	8c 3f       	cpi	r24, 0xFC	; 252
    2454:	71 f4       	brne	.+28     	; 0x2472 <prvFlashCoRoutine+0x60>
    2456:	8e e6       	ldi	r24, 0x6E	; 110
    2458:	91 e0       	ldi	r25, 0x01	; 1
    245a:	0f c0       	rjmp	.+30     	; 0x247a <prvFlashCoRoutine+0x68>
    245c:	40 e0       	ldi	r20, 0x00	; 0
    245e:	50 e0       	ldi	r21, 0x00	; 0
    2460:	be 01       	movw	r22, r28
    2462:	6f 5f       	subi	r22, 0xFF	; 255
    2464:	7f 4f       	sbci	r23, 0xFF	; 255
    2466:	80 91 ce 07 	lds	r24, 0x07CE	; 0x8007ce <xFlashQueue>
    246a:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <xFlashQueue+0x1>
    246e:	0e 94 cc 0e 	call	0x1d98	; 0x1d98 <xQueueCRReceive>
    2472:	8b 3f       	cpi	r24, 0xFB	; 251
    2474:	31 f4       	brne	.+12     	; 0x2482 <prvFlashCoRoutine+0x70>
    2476:	8f e6       	ldi	r24, 0x6F	; 111
    2478:	91 e0       	ldi	r25, 0x01	; 1
    247a:	f8 01       	movw	r30, r16
    247c:	91 8f       	std	Z+25, r25	; 0x19
    247e:	80 8f       	std	Z+24, r24	; 0x18
    2480:	08 c0       	rjmp	.+16     	; 0x2492 <prvFlashCoRoutine+0x80>

		if( xResult != pdPASS )
    2482:	81 30       	cpi	r24, 0x01	; 1
    2484:	19 f0       	breq	.+6      	; 0x248c <prvFlashCoRoutine+0x7a>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
    2486:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <xCoRoutineFlashStatus>
    248a:	d8 cf       	rjmp	.-80     	; 0x243c <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED();
    248c:	0e 94 cd 00 	call	0x19a	; 0x19a <vParTestToggleLED>
    2490:	d5 cf       	rjmp	.-86     	; 0x243c <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2492:	0f 90       	pop	r0
    2494:	df 91       	pop	r29
    2496:	cf 91       	pop	r28
    2498:	1f 91       	pop	r17
    249a:	0f 91       	pop	r16
    249c:	08 95       	ret

0000249e <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    249e:	0f 93       	push	r16
    24a0:	1f 93       	push	r17
    24a2:	cf 93       	push	r28
    24a4:	df 93       	push	r29
    24a6:	1f 92       	push	r1
    24a8:	cd b7       	in	r28, 0x3d	; 61
    24aa:	de b7       	in	r29, 0x3e	; 62
    24ac:	8c 01       	movw	r16, r24
    24ae:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_PERIOD_MS,
																450 / portTICK_PERIOD_MS,
																500  / portTICK_PERIOD_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    24b0:	fc 01       	movw	r30, r24
    24b2:	80 8d       	ldd	r24, Z+24	; 0x18
    24b4:	91 8d       	ldd	r25, Z+25	; 0x19
    24b6:	8e 32       	cpi	r24, 0x2E	; 46
    24b8:	f1 e0       	ldi	r31, 0x01	; 1
    24ba:	9f 07       	cpc	r25, r31
    24bc:	d9 f0       	breq	.+54     	; 0x24f4 <prvFixedDelayCoRoutine+0x56>
    24be:	18 f4       	brcc	.+6      	; 0x24c6 <prvFixedDelayCoRoutine+0x28>
    24c0:	89 2b       	or	r24, r25
    24c2:	41 f0       	breq	.+16     	; 0x24d4 <prvFixedDelayCoRoutine+0x36>
    24c4:	3e c0       	rjmp	.+124    	; 0x2542 <prvFixedDelayCoRoutine+0xa4>
    24c6:	8f 32       	cpi	r24, 0x2F	; 47
    24c8:	e1 e0       	ldi	r30, 0x01	; 1
    24ca:	9e 07       	cpc	r25, r30
    24cc:	39 f1       	breq	.+78     	; 0x251c <prvFixedDelayCoRoutine+0x7e>
    24ce:	82 34       	cpi	r24, 0x42	; 66
    24d0:	91 40       	sbci	r25, 0x01	; 1
    24d2:	b9 f5       	brne	.+110    	; 0x2542 <prvFixedDelayCoRoutine+0xa4>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
    24d4:	40 e0       	ldi	r20, 0x00	; 0
    24d6:	50 e0       	ldi	r21, 0x00	; 0
    24d8:	be 01       	movw	r22, r28
    24da:	6f 5f       	subi	r22, 0xFF	; 255
    24dc:	7f 4f       	sbci	r23, 0xFF	; 255
    24de:	80 91 ce 07 	lds	r24, 0x07CE	; 0x8007ce <xFlashQueue>
    24e2:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <xFlashQueue+0x1>
    24e6:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <xQueueCRSend>
    24ea:	8c 3f       	cpi	r24, 0xFC	; 252
    24ec:	71 f4       	brne	.+28     	; 0x250a <prvFixedDelayCoRoutine+0x6c>
    24ee:	8e e2       	ldi	r24, 0x2E	; 46
    24f0:	91 e0       	ldi	r25, 0x01	; 1
    24f2:	24 c0       	rjmp	.+72     	; 0x253c <prvFixedDelayCoRoutine+0x9e>
    24f4:	40 e0       	ldi	r20, 0x00	; 0
    24f6:	50 e0       	ldi	r21, 0x00	; 0
    24f8:	be 01       	movw	r22, r28
    24fa:	6f 5f       	subi	r22, 0xFF	; 255
    24fc:	7f 4f       	sbci	r23, 0xFF	; 255
    24fe:	80 91 ce 07 	lds	r24, 0x07CE	; 0x8007ce <xFlashQueue>
    2502:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <xFlashQueue+0x1>
    2506:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <xQueueCRSend>
    250a:	8b 3f       	cpi	r24, 0xFB	; 251
    250c:	19 f4       	brne	.+6      	; 0x2514 <prvFixedDelayCoRoutine+0x76>
    250e:	8f e2       	ldi	r24, 0x2F	; 47
    2510:	91 e0       	ldi	r25, 0x01	; 1
    2512:	14 c0       	rjmp	.+40     	; 0x253c <prvFixedDelayCoRoutine+0x9e>

		if( xResult != pdPASS )
    2514:	81 30       	cpi	r24, 0x01	; 1
    2516:	11 f0       	breq	.+4      	; 0x251c <prvFixedDelayCoRoutine+0x7e>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
    2518:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <xCoRoutineFlashStatus>
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
    251c:	e9 81       	ldd	r30, Y+1	; 0x01
    251e:	f0 e0       	ldi	r31, 0x00	; 0
    2520:	ee 0f       	add	r30, r30
    2522:	ff 1f       	adc	r31, r31
    2524:	ea 5f       	subi	r30, 0xFA	; 250
    2526:	fe 4f       	sbci	r31, 0xFE	; 254
    2528:	80 81       	ld	r24, Z
    252a:	91 81       	ldd	r25, Z+1	; 0x01
    252c:	00 97       	sbiw	r24, 0x00	; 0
    252e:	21 f0       	breq	.+8      	; 0x2538 <prvFixedDelayCoRoutine+0x9a>
    2530:	60 e0       	ldi	r22, 0x00	; 0
    2532:	70 e0       	ldi	r23, 0x00	; 0
    2534:	0e 94 74 10 	call	0x20e8	; 0x20e8 <vCoRoutineAddToDelayedList>
    2538:	82 e4       	ldi	r24, 0x42	; 66
    253a:	91 e0       	ldi	r25, 0x01	; 1
    253c:	f8 01       	movw	r30, r16
    253e:	91 8f       	std	Z+25, r25	; 0x19
    2540:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2542:	0f 90       	pop	r0
    2544:	df 91       	pop	r29
    2546:	cf 91       	pop	r28
    2548:	1f 91       	pop	r17
    254a:	0f 91       	pop	r16
    254c:	08 95       	ret

0000254e <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
{
    254e:	cf 93       	push	r28
    2550:	df 93       	push	r29
    2552:	d8 2f       	mov	r29, r24
    2554:	89 30       	cpi	r24, 0x09	; 9
    2556:	08 f0       	brcs	.+2      	; 0x255a <vStartFlashCoRoutines+0xc>
    2558:	d8 e0       	ldi	r29, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
    255a:	40 e0       	ldi	r20, 0x00	; 0
    255c:	61 e0       	ldi	r22, 0x01	; 1
    255e:	81 e0       	ldi	r24, 0x01	; 1
    2560:	0e 94 75 0b 	call	0x16ea	; 0x16ea <xQueueGenericCreate>
    2564:	90 93 cf 07 	sts	0x07CF, r25	; 0x8007cf <xFlashQueue+0x1>
    2568:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <xFlashQueue>

	if( xFlashQueue )
    256c:	89 2b       	or	r24, r25
    256e:	99 f0       	breq	.+38     	; 0x2596 <vStartFlashCoRoutines+0x48>
    2570:	c0 e0       	ldi	r28, 0x00	; 0
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    2572:	cd 17       	cp	r28, r29
    2574:	41 f0       	breq	.+16     	; 0x2586 <vStartFlashCoRoutines+0x38>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
    2576:	4c 2f       	mov	r20, r28
    2578:	60 e0       	ldi	r22, 0x00	; 0
    257a:	8f e4       	ldi	r24, 0x4F	; 79
    257c:	92 e1       	ldi	r25, 0x12	; 18
    257e:	0e 94 02 10 	call	0x2004	; 0x2004 <xCoRoutineCreate>
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    2582:	cf 5f       	subi	r28, 0xFF	; 255
    2584:	f6 cf       	rjmp	.-20     	; 0x2572 <vStartFlashCoRoutines+0x24>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    2586:	40 e0       	ldi	r20, 0x00	; 0
    2588:	61 e0       	ldi	r22, 0x01	; 1
    258a:	89 e0       	ldi	r24, 0x09	; 9
    258c:	92 e1       	ldi	r25, 0x12	; 18
	}
}
    258e:	df 91       	pop	r29
    2590:	cf 91       	pop	r28
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    2592:	0c 94 02 10 	jmp	0x2004	; 0x2004 <xCoRoutineCreate>
	}
}
    2596:	df 91       	pop	r29
    2598:	cf 91       	pop	r28
    259a:	08 95       	ret

0000259c <xAreFlashCoRoutinesStillRunning>:
BaseType_t xAreFlashCoRoutinesStillRunning( void )
{
	/* Return pdPASS or pdFAIL depending on whether an error has been detected
	or not. */
	return xCoRoutineFlashStatus;
}
    259c:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <xCoRoutineFlashStatus>
    25a0:	08 95       	ret

000025a2 <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    25a2:	cf 93       	push	r28
    25a4:	df 93       	push	r29
    25a6:	00 d0       	rcall	.+0      	; 0x25a8 <vCompeteingIntMathTask+0x6>
    25a8:	00 d0       	rcall	.+0      	; 0x25aa <vCompeteingIntMathTask+0x8>
    25aa:	cd b7       	in	r28, 0x3d	; 61
    25ac:	de b7       	in	r29, 0x3e	; 62
    25ae:	7c 01       	movw	r14, r24
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    25b0:	00 e0       	ldi	r16, 0x00	; 0
    25b2:	10 e0       	ldi	r17, 0x00	; 0
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    25b4:	8b e7       	ldi	r24, 0x7B	; 123
    25b6:	88 2e       	mov	r8, r24
    25b8:	91 2c       	mov	r9, r1
    25ba:	a1 2c       	mov	r10, r1
    25bc:	b1 2c       	mov	r11, r1
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
		lValue /= intgCONST4;
    25be:	97 e0       	ldi	r25, 0x07	; 7
    25c0:	49 2e       	mov	r4, r25
    25c2:	51 2c       	mov	r5, r1
    25c4:	61 2c       	mov	r6, r1
    25c6:	71 2c       	mov	r7, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    25c8:	dd 24       	eor	r13, r13
    25ca:	d3 94       	inc	r13
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    25cc:	89 82       	std	Y+1, r8	; 0x01
    25ce:	9a 82       	std	Y+2, r9	; 0x02
    25d0:	ab 82       	std	Y+3, r10	; 0x03
    25d2:	bc 82       	std	Y+4, r11	; 0x04
		lValue += intgCONST2;
    25d4:	89 81       	ldd	r24, Y+1	; 0x01
    25d6:	9a 81       	ldd	r25, Y+2	; 0x02
    25d8:	ab 81       	ldd	r26, Y+3	; 0x03
    25da:	bc 81       	ldd	r27, Y+4	; 0x04
    25dc:	89 5b       	subi	r24, 0xB9	; 185
    25de:	9b 46       	sbci	r25, 0x6B	; 107
    25e0:	ac 4f       	sbci	r26, 0xFC	; 252
    25e2:	bf 4f       	sbci	r27, 0xFF	; 255
    25e4:	89 83       	std	Y+1, r24	; 0x01
    25e6:	9a 83       	std	Y+2, r25	; 0x02
    25e8:	ab 83       	std	Y+3, r26	; 0x03
    25ea:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    25ec:	29 81       	ldd	r18, Y+1	; 0x01
    25ee:	3a 81       	ldd	r19, Y+2	; 0x02
    25f0:	4b 81       	ldd	r20, Y+3	; 0x03
    25f2:	5c 81       	ldd	r21, Y+4	; 0x04
    25f4:	ad ef       	ldi	r26, 0xFD	; 253
    25f6:	bf ef       	ldi	r27, 0xFF	; 255
    25f8:	0e 94 81 16 	call	0x2d02	; 0x2d02 <__mulohisi3>
    25fc:	69 83       	std	Y+1, r22	; 0x01
    25fe:	7a 83       	std	Y+2, r23	; 0x02
    2600:	8b 83       	std	Y+3, r24	; 0x03
    2602:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
    2604:	69 81       	ldd	r22, Y+1	; 0x01
    2606:	7a 81       	ldd	r23, Y+2	; 0x02
    2608:	8b 81       	ldd	r24, Y+3	; 0x03
    260a:	9c 81       	ldd	r25, Y+4	; 0x04
    260c:	a3 01       	movw	r20, r6
    260e:	92 01       	movw	r18, r4
    2610:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <__divmodsi4>
    2614:	29 83       	std	Y+1, r18	; 0x01
    2616:	3a 83       	std	Y+2, r19	; 0x02
    2618:	4b 83       	std	Y+3, r20	; 0x03
    261a:	5c 83       	std	Y+4, r21	; 0x04

		/* If the calculation is found to be incorrect we stop setting the
		TaskHasExecuted variable so the check task can see an error has
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    261c:	89 81       	ldd	r24, Y+1	; 0x01
    261e:	9a 81       	ldd	r25, Y+2	; 0x02
    2620:	ab 81       	ldd	r26, Y+3	; 0x03
    2622:	bc 81       	ldd	r27, Y+4	; 0x04
    2624:	8b 31       	cpi	r24, 0x1B	; 27
    2626:	97 47       	sbci	r25, 0x77	; 119
    2628:	ae 4f       	sbci	r26, 0xFE	; 254
    262a:	bf 4f       	sbci	r27, 0xFF	; 255
    262c:	19 f0       	breq	.+6      	; 0x2634 <vCompeteingIntMathTask+0x92>
    262e:	01 e0       	ldi	r16, 0x01	; 1
    2630:	10 e0       	ldi	r17, 0x00	; 0
    2632:	cc cf       	rjmp	.-104    	; 0x25cc <vCompeteingIntMathTask+0x2a>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    2634:	01 15       	cp	r16, r1
    2636:	11 05       	cpc	r17, r1
    2638:	d1 f7       	brne	.-12     	; 0x262e <vCompeteingIntMathTask+0x8c>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    263a:	0f b6       	in	r0, 0x3f	; 63
    263c:	f8 94       	cli
    263e:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    2640:	f7 01       	movw	r30, r14
    2642:	d0 82       	st	Z, r13
			portEXIT_CRITICAL();
    2644:	0f 90       	pop	r0
    2646:	0f be       	out	0x3f, r0	; 63
    2648:	c1 cf       	rjmp	.-126    	; 0x25cc <vCompeteingIntMathTask+0x2a>

0000264a <vStartIntegerMathTasks>:
static BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    264a:	ef 92       	push	r14
    264c:	ff 92       	push	r15
    264e:	0f 93       	push	r16
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    2650:	e1 2c       	mov	r14, r1
    2652:	f1 2c       	mov	r15, r1
    2654:	08 2f       	mov	r16, r24
    2656:	20 ed       	ldi	r18, 0xD0	; 208
    2658:	37 e0       	ldi	r19, 0x07	; 7
    265a:	45 e5       	ldi	r20, 0x55	; 85
    265c:	50 e0       	ldi	r21, 0x00	; 0
    265e:	6b e2       	ldi	r22, 0x2B	; 43
    2660:	71 e0       	ldi	r23, 0x01	; 1
    2662:	81 ed       	ldi	r24, 0xD1	; 209
    2664:	92 e1       	ldi	r25, 0x12	; 18
    2666:	0e 94 db 03 	call	0x7b6	; 0x7b6 <xTaskCreate>
	}
}
    266a:	0f 91       	pop	r16
    266c:	ff 90       	pop	r15
    266e:	ef 90       	pop	r14
    2670:	08 95       	ret

00002672 <xAreIntegerMathsTaskStillRunning>:
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
BaseType_t xReturn = pdTRUE;
    2672:	81 e0       	ldi	r24, 0x01	; 1
    2674:	90 91 d0 07 	lds	r25, 0x07D0	; 0x8007d0 <xTaskCheck>
    2678:	91 11       	cpse	r25, r1
    267a:	01 c0       	rjmp	.+2      	; 0x267e <xAreIntegerMathsTaskStillRunning+0xc>
    267c:	80 e0       	ldi	r24, 0x00	; 0
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    267e:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <xTaskCheck>
	}

	return xReturn;
}
    2682:	08 95       	ret

00002684 <vPolledQueueProducer>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    2684:	cf 93       	push	r28
    2686:	df 93       	push	r29
    2688:	00 d0       	rcall	.+0      	; 0x268a <vPolledQueueProducer+0x6>
    268a:	cd b7       	in	r28, 0x3d	; 61
    268c:	de b7       	in	r29, 0x3e	; 62
    268e:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
    2690:	1a 82       	std	Y+2, r1	; 0x02
    2692:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xError = pdFALSE, xLoop;
    2694:	00 e0       	ldi	r16, 0x00	; 0
    2696:	13 e0       	ldi	r17, 0x03	; 3
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    2698:	20 e0       	ldi	r18, 0x00	; 0
    269a:	40 e0       	ldi	r20, 0x00	; 0
    269c:	50 e0       	ldi	r21, 0x00	; 0
    269e:	be 01       	movw	r22, r28
    26a0:	6f 5f       	subi	r22, 0xFF	; 255
    26a2:	7f 4f       	sbci	r23, 0xFF	; 255
    26a4:	f7 01       	movw	r30, r14
    26a6:	80 81       	ld	r24, Z
    26a8:	91 81       	ldd	r25, Z+1	; 0x01
    26aa:	0e 94 98 0b 	call	0x1730	; 0x1730 <xQueueGenericSend>
    26ae:	81 30       	cpi	r24, 0x01	; 1
    26b0:	91 f4       	brne	.+36     	; 0x26d6 <vPolledQueueProducer+0x52>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
    26b2:	01 11       	cpse	r16, r1
    26b4:	0a c0       	rjmp	.+20     	; 0x26ca <vPolledQueueProducer+0x46>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    26b6:	0f b6       	in	r0, 0x3f	; 63
    26b8:	f8 94       	cli
    26ba:	0f 92       	push	r0
						xPollingProducerCount++;
    26bc:	80 91 d3 07 	lds	r24, 0x07D3	; 0x8007d3 <xPollingProducerCount>
    26c0:	8f 5f       	subi	r24, 0xFF	; 255
    26c2:	80 93 d3 07 	sts	0x07D3, r24	; 0x8007d3 <xPollingProducerCount>
					portEXIT_CRITICAL();
    26c6:	0f 90       	pop	r0
    26c8:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    26ca:	89 81       	ldd	r24, Y+1	; 0x01
    26cc:	9a 81       	ldd	r25, Y+2	; 0x02
    26ce:	01 96       	adiw	r24, 0x01	; 1
    26d0:	9a 83       	std	Y+2, r25	; 0x02
    26d2:	89 83       	std	Y+1, r24	; 0x01
    26d4:	01 c0       	rjmp	.+2      	; 0x26d8 <vPolledQueueProducer+0x54>
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    26d6:	01 e0       	ldi	r16, 0x01	; 1
    26d8:	11 50       	subi	r17, 0x01	; 1
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    26da:	f1 f6       	brne	.-68     	; 0x2698 <vPolledQueueProducer+0x14>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    26dc:	83 e0       	ldi	r24, 0x03	; 3
    26de:	90 e0       	ldi	r25, 0x00	; 0
    26e0:	0e 94 d5 06 	call	0xdaa	; 0xdaa <vTaskDelay>
	}
    26e4:	d8 cf       	rjmp	.-80     	; 0x2696 <vPolledQueueProducer+0x12>

000026e6 <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    26e6:	cf 93       	push	r28
    26e8:	df 93       	push	r29
    26ea:	00 d0       	rcall	.+0      	; 0x26ec <vPolledQueueConsumer+0x6>
    26ec:	cd b7       	in	r28, 0x3d	; 61
    26ee:	de b7       	in	r29, 0x3e	; 62
    26f0:	6c 01       	movw	r12, r24
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE;
    26f2:	f1 2c       	mov	r15, r1
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
    26f4:	00 e0       	ldi	r16, 0x00	; 0
    26f6:	10 e0       	ldi	r17, 0x00	; 0
BaseType_t xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    26f8:	f6 01       	movw	r30, r12
    26fa:	80 81       	ld	r24, Z
    26fc:	91 81       	ldd	r25, Z+1	; 0x01
    26fe:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <uxQueueMessagesWaiting>
    2702:	88 23       	and	r24, r24
    2704:	21 f1       	breq	.+72     	; 0x274e <vPolledQueueConsumer+0x68>
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    2706:	40 e0       	ldi	r20, 0x00	; 0
    2708:	50 e0       	ldi	r21, 0x00	; 0
    270a:	be 01       	movw	r22, r28
    270c:	6f 5f       	subi	r22, 0xFF	; 255
    270e:	7f 4f       	sbci	r23, 0xFF	; 255
    2710:	f6 01       	movw	r30, r12
    2712:	80 81       	ld	r24, Z
    2714:	91 81       	ldd	r25, Z+1	; 0x01
    2716:	0e 94 81 0c 	call	0x1902	; 0x1902 <xQueueReceive>
    271a:	81 30       	cpi	r24, 0x01	; 1
    271c:	69 f7       	brne	.-38     	; 0x26f8 <vPolledQueueConsumer+0x12>
			{
				if( usData != usExpectedValue )
    271e:	89 81       	ldd	r24, Y+1	; 0x01
    2720:	9a 81       	ldd	r25, Y+2	; 0x02
    2722:	08 17       	cp	r16, r24
    2724:	19 07       	cpc	r17, r25
    2726:	69 f4       	brne	.+26     	; 0x2742 <vPolledQueueConsumer+0x5c>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
    2728:	f1 10       	cpse	r15, r1
    272a:	0e c0       	rjmp	.+28     	; 0x2748 <vPolledQueueConsumer+0x62>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    272c:	0f b6       	in	r0, 0x3f	; 63
    272e:	f8 94       	cli
    2730:	0f 92       	push	r0
							xPollingConsumerCount++;
    2732:	80 91 d4 07 	lds	r24, 0x07D4	; 0x8007d4 <xPollingConsumerCount>
    2736:	8f 5f       	subi	r24, 0xFF	; 255
    2738:	80 93 d4 07 	sts	0x07D4, r24	; 0x8007d4 <xPollingConsumerCount>
						portEXIT_CRITICAL();
    273c:	0f 90       	pop	r0
    273e:	0f be       	out	0x3f, r0	; 63
    2740:	03 c0       	rjmp	.+6      	; 0x2748 <vPolledQueueConsumer+0x62>
    2742:	8c 01       	movw	r16, r24
			{
				if( usData != usExpectedValue )
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    2744:	ff 24       	eor	r15, r15
    2746:	f3 94       	inc	r15
						portEXIT_CRITICAL();
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    2748:	0f 5f       	subi	r16, 0xFF	; 255
    274a:	1f 4f       	sbci	r17, 0xFF	; 255
    274c:	d5 cf       	rjmp	.-86     	; 0x26f8 <vPolledQueueConsumer+0x12>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    274e:	8f ee       	ldi	r24, 0xEF	; 239
    2750:	9f ef       	ldi	r25, 0xFF	; 255
    2752:	0e 94 d5 06 	call	0xdaa	; 0xdaa <vTaskDelay>
	}
    2756:	d0 cf       	rjmp	.-96     	; 0x26f8 <vPolledQueueConsumer+0x12>

00002758 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    2758:	ef 92       	push	r14
    275a:	ff 92       	push	r15
    275c:	0f 93       	push	r16
    275e:	cf 93       	push	r28
    2760:	c8 2f       	mov	r28, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    2762:	40 e0       	ldi	r20, 0x00	; 0
    2764:	62 e0       	ldi	r22, 0x02	; 2
    2766:	8a e0       	ldi	r24, 0x0A	; 10
    2768:	0e 94 75 0b 	call	0x16ea	; 0x16ea <xQueueGenericCreate>
    276c:	90 93 d2 07 	sts	0x07D2, r25	; 0x8007d2 <xPolledQueue.2223+0x1>
    2770:	80 93 d1 07 	sts	0x07D1, r24	; 0x8007d1 <xPolledQueue.2223>

	if( xPolledQueue != NULL )
    2774:	89 2b       	or	r24, r25
    2776:	b9 f0       	breq	.+46     	; 0x27a6 <vStartPolledQueueTasks+0x4e>
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

		/* Spawn the producer and consumer. */
		xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2778:	e1 2c       	mov	r14, r1
    277a:	f1 2c       	mov	r15, r1
    277c:	0c 2f       	mov	r16, r28
    277e:	21 ed       	ldi	r18, 0xD1	; 209
    2780:	37 e0       	ldi	r19, 0x07	; 7
    2782:	45 e5       	ldi	r20, 0x55	; 85
    2784:	50 e0       	ldi	r21, 0x00	; 0
    2786:	63 e3       	ldi	r22, 0x33	; 51
    2788:	71 e0       	ldi	r23, 0x01	; 1
    278a:	83 e7       	ldi	r24, 0x73	; 115
    278c:	93 e1       	ldi	r25, 0x13	; 19
    278e:	0e 94 db 03 	call	0x7b6	; 0x7b6 <xTaskCreate>
		xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2792:	21 ed       	ldi	r18, 0xD1	; 209
    2794:	37 e0       	ldi	r19, 0x07	; 7
    2796:	45 e5       	ldi	r20, 0x55	; 85
    2798:	50 e0       	ldi	r21, 0x00	; 0
    279a:	6b e3       	ldi	r22, 0x3B	; 59
    279c:	71 e0       	ldi	r23, 0x01	; 1
    279e:	82 e4       	ldi	r24, 0x42	; 66
    27a0:	93 e1       	ldi	r25, 0x13	; 19
    27a2:	0e 94 db 03 	call	0x7b6	; 0x7b6 <xTaskCreate>
	}
}
    27a6:	cf 91       	pop	r28
    27a8:	0f 91       	pop	r16
    27aa:	ff 90       	pop	r15
    27ac:	ef 90       	pop	r14
    27ae:	08 95       	ret

000027b0 <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    27b0:	80 91 d4 07 	lds	r24, 0x07D4	; 0x8007d4 <xPollingConsumerCount>
    27b4:	88 23       	and	r24, r24
    27b6:	29 f0       	breq	.+10     	; 0x27c2 <xArePollingQueuesStillRunning+0x12>
		( xPollingProducerCount == pollqINITIAL_VALUE )
    27b8:	90 91 d3 07 	lds	r25, 0x07D3	; 0x8007d3 <xPollingProducerCount>
	  )
	{
		xReturn = pdFALSE;
    27bc:	81 e0       	ldi	r24, 0x01	; 1
    27be:	91 11       	cpse	r25, r1
    27c0:	01 c0       	rjmp	.+2      	; 0x27c4 <xArePollingQueuesStillRunning+0x14>
    27c2:	80 e0       	ldi	r24, 0x00	; 0
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    27c4:	10 92 d4 07 	sts	0x07D4, r1	; 0x8007d4 <xPollingConsumerCount>
	xPollingProducerCount = pollqINITIAL_VALUE;
    27c8:	10 92 d3 07 	sts	0x07D3, r1	; 0x8007d3 <xPollingProducerCount>

	return xReturn;
}
    27cc:	08 95       	ret

000027ce <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    27ce:	cf 93       	push	r28
    27d0:	df 93       	push	r29
    27d2:	1f 92       	push	r1
    27d4:	cd b7       	in	r28, 0x3d	; 61
    27d6:	de b7       	in	r29, 0x3e	; 62
signed char cExpectedByte, cByteRxed;
BaseType_t xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
    27d8:	00 e0       	ldi	r16, 0x00	; 0

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    27da:	11 e4       	ldi	r17, 0x41	; 65
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    27dc:	4f ef       	ldi	r20, 0xFF	; 255
    27de:	5f ef       	ldi	r21, 0xFF	; 255
    27e0:	be 01       	movw	r22, r28
    27e2:	6f 5f       	subi	r22, 0xFF	; 255
    27e4:	7f 4f       	sbci	r23, 0xFF	; 255
    27e6:	80 e0       	ldi	r24, 0x00	; 0
    27e8:	90 e0       	ldi	r25, 0x00	; 0
    27ea:	0e 94 2e 01 	call	0x25c	; 0x25c <xSerialGetChar>
    27ee:	88 23       	and	r24, r24
    27f0:	29 f0       	breq	.+10     	; 0x27fc <vComRxTask+0x2e>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
    27f2:	89 81       	ldd	r24, Y+1	; 0x01
    27f4:	81 13       	cpse	r24, r17
    27f6:	07 c0       	rjmp	.+14     	; 0x2806 <vComRxTask+0x38>
				{
					vParTestToggleLED();
    27f8:	0e 94 cd 00 	call	0x19a	; 0x19a <vParTestToggleLED>
    27fc:	1f 5f       	subi	r17, 0xFF	; 255

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    27fe:	19 35       	cpi	r17, 0x59	; 89
    2800:	69 f7       	brne	.-38     	; 0x27dc <vComRxTask+0xe>
    2802:	10 e0       	ldi	r17, 0x00	; 0
    2804:	01 c0       	rjmp	.+2      	; 0x2808 <vComRxTask+0x3a>
				{
					vParTestToggleLED();
				}
				else
				{
					xResyncRequired = pdTRUE;
    2806:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
    2808:	80 91 d6 07 	lds	r24, 0x07D6	; 0x8007d6 <uxBaseLED>
    280c:	60 e0       	ldi	r22, 0x00	; 0
    280e:	8f 5f       	subi	r24, 0xFF	; 255
    2810:	0e 94 a9 00 	call	0x152	; 0x152 <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
    2814:	11 30       	cpi	r17, 0x01	; 1
    2816:	79 f4       	brne	.+30     	; 0x2836 <vComRxTask+0x68>
		{
			while( cByteRxed != comLAST_BYTE )
    2818:	89 81       	ldd	r24, Y+1	; 0x01
    281a:	88 35       	cpi	r24, 0x58	; 88
    281c:	51 f0       	breq	.+20     	; 0x2832 <vComRxTask+0x64>
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
    281e:	4f ef       	ldi	r20, 0xFF	; 255
    2820:	5f ef       	ldi	r21, 0xFF	; 255
    2822:	be 01       	movw	r22, r28
    2824:	6f 5f       	subi	r22, 0xFF	; 255
    2826:	7f 4f       	sbci	r23, 0xFF	; 255
    2828:	80 e0       	ldi	r24, 0x00	; 0
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	0e 94 2e 01 	call	0x25c	; 0x25c <xSerialGetChar>
    2830:	f3 cf       	rjmp	.-26     	; 0x2818 <vComRxTask+0x4a>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
    2832:	0f 5f       	subi	r16, 0xFF	; 255
    2834:	d2 cf       	rjmp	.-92     	; 0x27da <vComRxTask+0xc>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
    2836:	02 30       	cpi	r16, 0x02	; 2
    2838:	84 f6       	brge	.-96     	; 0x27da <vComRxTask+0xc>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
    283a:	80 91 d5 07 	lds	r24, 0x07D5	; 0x8007d5 <uxRxLoops>
    283e:	8f 5f       	subi	r24, 0xFF	; 255
    2840:	80 93 d5 07 	sts	0x07D5, r24	; 0x8007d5 <uxRxLoops>
    2844:	ca cf       	rjmp	.-108    	; 0x27da <vComRxTask+0xc>

00002846 <vComTxTask>:
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    2846:	06 e9       	ldi	r16, 0x96	; 150
    2848:	10 e0       	ldi	r17, 0x00	; 0

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    284a:	c1 e4       	ldi	r28, 0x41	; 65
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
    284c:	40 e0       	ldi	r20, 0x00	; 0
    284e:	50 e0       	ldi	r21, 0x00	; 0
    2850:	6c 2f       	mov	r22, r28
    2852:	80 e0       	ldi	r24, 0x00	; 0
    2854:	90 e0       	ldi	r25, 0x00	; 0
    2856:	0e 94 3a 01 	call	0x274	; 0x274 <xSerialPutChar>
    285a:	81 30       	cpi	r24, 0x01	; 1
    285c:	11 f4       	brne	.+4      	; 0x2862 <vComTxTask+0x1c>
			{
				vParTestToggleLED();
    285e:	0e 94 cd 00 	call	0x19a	; 0x19a <vParTestToggleLED>
    2862:	cf 5f       	subi	r28, 0xFF	; 255

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    2864:	c9 35       	cpi	r28, 0x59	; 89
    2866:	91 f7       	brne	.-28     	; 0x284c <vComTxTask+0x6>
				vParTestToggleLED();
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
    2868:	60 e0       	ldi	r22, 0x00	; 0
    286a:	80 91 d6 07 	lds	r24, 0x07D6	; 0x8007d6 <uxBaseLED>
    286e:	0e 94 a9 00 	call	0x152	; 0x152 <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
    2872:	0e 94 60 05 	call	0xac0	; 0xac0 <xTaskGetTickCount>
    2876:	03 96       	adiw	r24, 0x03	; 3

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    2878:	b8 01       	movw	r22, r16
    287a:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <__udivmodhi4>

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
    287e:	82 33       	cpi	r24, 0x32	; 50
    2880:	91 05       	cpc	r25, r1
    2882:	10 f4       	brcc	.+4      	; 0x2888 <vComTxTask+0x42>
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
    2884:	82 e3       	ldi	r24, 0x32	; 50
    2886:	90 e0       	ldi	r25, 0x00	; 0
		}

		vTaskDelay( xTimeToWait );
    2888:	0e 94 d5 06 	call	0xdaa	; 0xdaa <vTaskDelay>
	}
    288c:	de cf       	rjmp	.-68     	; 0x284a <vComTxTask+0x4>

0000288e <vAltStartComTestTasks>:
static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
{
    288e:	ef 92       	push	r14
    2890:	ff 92       	push	r15
    2892:	0f 93       	push	r16
    2894:	cf 93       	push	r28
    2896:	c8 2f       	mov	r28, r24
    2898:	cb 01       	movw	r24, r22
    289a:	ba 01       	movw	r22, r20
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
    289c:	20 93 d6 07 	sts	0x07D6, r18	; 0x8007d6 <uxBaseLED>
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
    28a0:	48 e1       	ldi	r20, 0x18	; 24
    28a2:	0e 94 e5 00 	call	0x1ca	; 0x1ca <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
    28a6:	0f ef       	ldi	r16, 0xFF	; 255
    28a8:	0c 0f       	add	r16, r28
    28aa:	e1 2c       	mov	r14, r1
    28ac:	f1 2c       	mov	r15, r1
    28ae:	20 e0       	ldi	r18, 0x00	; 0
    28b0:	30 e0       	ldi	r19, 0x00	; 0
    28b2:	45 e5       	ldi	r20, 0x55	; 85
    28b4:	50 e0       	ldi	r21, 0x00	; 0
    28b6:	63 e4       	ldi	r22, 0x43	; 67
    28b8:	71 e0       	ldi	r23, 0x01	; 1
    28ba:	83 e2       	ldi	r24, 0x23	; 35
    28bc:	94 e1       	ldi	r25, 0x14	; 20
    28be:	0e 94 db 03 	call	0x7b6	; 0x7b6 <xTaskCreate>
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
    28c2:	0c 2f       	mov	r16, r28
    28c4:	20 e0       	ldi	r18, 0x00	; 0
    28c6:	30 e0       	ldi	r19, 0x00	; 0
    28c8:	45 e5       	ldi	r20, 0x55	; 85
    28ca:	50 e0       	ldi	r21, 0x00	; 0
    28cc:	69 e4       	ldi	r22, 0x49	; 73
    28ce:	71 e0       	ldi	r23, 0x01	; 1
    28d0:	87 ee       	ldi	r24, 0xE7	; 231
    28d2:	93 e1       	ldi	r25, 0x13	; 19
    28d4:	0e 94 db 03 	call	0x7b6	; 0x7b6 <xTaskCreate>
}
    28d8:	cf 91       	pop	r28
    28da:	0f 91       	pop	r16
    28dc:	ff 90       	pop	r15
    28de:	ef 90       	pop	r14
    28e0:	08 95       	ret

000028e2 <xAreComTestTasksStillRunning>:
BaseType_t xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
    28e2:	90 91 d5 07 	lds	r25, 0x07D5	; 0x8007d5 <uxRxLoops>
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
    28e6:	10 92 d5 07 	sts	0x07D5, r1	; 0x8007d5 <uxRxLoops>

	return xReturn;
    28ea:	81 e0       	ldi	r24, 0x01	; 1
    28ec:	91 11       	cpse	r25, r1
    28ee:	01 c0       	rjmp	.+2      	; 0x28f2 <xAreComTestTasksStillRunning+0x10>
    28f0:	80 e0       	ldi	r24, 0x00	; 0
}
    28f2:	08 95       	ret

000028f4 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    28f4:	31 e1       	ldi	r19, 0x11	; 17
    28f6:	fc 01       	movw	r30, r24
    28f8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    28fa:	31 97       	sbiw	r30, 0x01	; 1
    28fc:	22 e2       	ldi	r18, 0x22	; 34
    28fe:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2900:	31 97       	sbiw	r30, 0x01	; 1
    2902:	a3 e3       	ldi	r26, 0x33	; 51
    2904:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2906:	31 97       	sbiw	r30, 0x01	; 1
    2908:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    290a:	31 97       	sbiw	r30, 0x01	; 1
    290c:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    290e:	31 97       	sbiw	r30, 0x01	; 1
    2910:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2912:	31 97       	sbiw	r30, 0x01	; 1
    2914:	60 e8       	ldi	r22, 0x80	; 128
    2916:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2918:	31 97       	sbiw	r30, 0x01	; 1
    291a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    291c:	31 97       	sbiw	r30, 0x01	; 1
    291e:	62 e0       	ldi	r22, 0x02	; 2
    2920:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2922:	31 97       	sbiw	r30, 0x01	; 1
    2924:	63 e0       	ldi	r22, 0x03	; 3
    2926:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2928:	31 97       	sbiw	r30, 0x01	; 1
    292a:	64 e0       	ldi	r22, 0x04	; 4
    292c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    292e:	31 97       	sbiw	r30, 0x01	; 1
    2930:	65 e0       	ldi	r22, 0x05	; 5
    2932:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2934:	31 97       	sbiw	r30, 0x01	; 1
    2936:	66 e0       	ldi	r22, 0x06	; 6
    2938:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    293a:	31 97       	sbiw	r30, 0x01	; 1
    293c:	67 e0       	ldi	r22, 0x07	; 7
    293e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2940:	31 97       	sbiw	r30, 0x01	; 1
    2942:	68 e0       	ldi	r22, 0x08	; 8
    2944:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2946:	31 97       	sbiw	r30, 0x01	; 1
    2948:	69 e0       	ldi	r22, 0x09	; 9
    294a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    294c:	31 97       	sbiw	r30, 0x01	; 1
    294e:	60 e1       	ldi	r22, 0x10	; 16
    2950:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2952:	31 97       	sbiw	r30, 0x01	; 1
    2954:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2956:	31 97       	sbiw	r30, 0x01	; 1
    2958:	32 e1       	ldi	r19, 0x12	; 18
    295a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    295c:	31 97       	sbiw	r30, 0x01	; 1
    295e:	33 e1       	ldi	r19, 0x13	; 19
    2960:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2962:	31 97       	sbiw	r30, 0x01	; 1
    2964:	34 e1       	ldi	r19, 0x14	; 20
    2966:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2968:	31 97       	sbiw	r30, 0x01	; 1
    296a:	35 e1       	ldi	r19, 0x15	; 21
    296c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    296e:	31 97       	sbiw	r30, 0x01	; 1
    2970:	36 e1       	ldi	r19, 0x16	; 22
    2972:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2974:	31 97       	sbiw	r30, 0x01	; 1
    2976:	37 e1       	ldi	r19, 0x17	; 23
    2978:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    297a:	31 97       	sbiw	r30, 0x01	; 1
    297c:	38 e1       	ldi	r19, 0x18	; 24
    297e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2980:	31 97       	sbiw	r30, 0x01	; 1
    2982:	39 e1       	ldi	r19, 0x19	; 25
    2984:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2986:	31 97       	sbiw	r30, 0x01	; 1
    2988:	30 e2       	ldi	r19, 0x20	; 32
    298a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    298c:	31 97       	sbiw	r30, 0x01	; 1
    298e:	31 e2       	ldi	r19, 0x21	; 33
    2990:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2992:	31 97       	sbiw	r30, 0x01	; 1
    2994:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2996:	31 97       	sbiw	r30, 0x01	; 1
    2998:	23 e2       	ldi	r18, 0x23	; 35
    299a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    299c:	31 97       	sbiw	r30, 0x01	; 1
    299e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    29a0:	31 97       	sbiw	r30, 0x01	; 1
    29a2:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    29a4:	31 97       	sbiw	r30, 0x01	; 1
    29a6:	26 e2       	ldi	r18, 0x26	; 38
    29a8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    29aa:	31 97       	sbiw	r30, 0x01	; 1
    29ac:	27 e2       	ldi	r18, 0x27	; 39
    29ae:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    29b0:	31 97       	sbiw	r30, 0x01	; 1
    29b2:	28 e2       	ldi	r18, 0x28	; 40
    29b4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    29b6:	31 97       	sbiw	r30, 0x01	; 1
    29b8:	29 e2       	ldi	r18, 0x29	; 41
    29ba:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    29bc:	31 97       	sbiw	r30, 0x01	; 1
    29be:	20 e3       	ldi	r18, 0x30	; 48
    29c0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    29c2:	31 97       	sbiw	r30, 0x01	; 1
    29c4:	21 e3       	ldi	r18, 0x31	; 49
    29c6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    29c8:	86 97       	sbiw	r24, 0x26	; 38
    29ca:	08 95       	ret

000029cc <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    29cc:	81 e0       	ldi	r24, 0x01	; 1
    29ce:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
	OCR1AL = ucLowByte;
    29d2:	87 e3       	ldi	r24, 0x37	; 55
    29d4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    29d8:	8b e0       	ldi	r24, 0x0B	; 11
    29da:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK0;
    29de:	ee e6       	ldi	r30, 0x6E	; 110
    29e0:	f0 e0       	ldi	r31, 0x00	; 0
    29e2:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    29e4:	80 61       	ori	r24, 0x10	; 16
	TIMSK0 = ucLowByte;
    29e6:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    29e8:	a0 91 56 01 	lds	r26, 0x0156	; 0x800156 <pxCurrentTCB>
    29ec:	b0 91 57 01 	lds	r27, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    29f0:	cd 91       	ld	r28, X+
    29f2:	cd bf       	out	0x3d, r28	; 61
    29f4:	dd 91       	ld	r29, X+
    29f6:	de bf       	out	0x3e, r29	; 62
    29f8:	ff 91       	pop	r31
    29fa:	ef 91       	pop	r30
    29fc:	df 91       	pop	r29
    29fe:	cf 91       	pop	r28
    2a00:	bf 91       	pop	r27
    2a02:	af 91       	pop	r26
    2a04:	9f 91       	pop	r25
    2a06:	8f 91       	pop	r24
    2a08:	7f 91       	pop	r23
    2a0a:	6f 91       	pop	r22
    2a0c:	5f 91       	pop	r21
    2a0e:	4f 91       	pop	r20
    2a10:	3f 91       	pop	r19
    2a12:	2f 91       	pop	r18
    2a14:	1f 91       	pop	r17
    2a16:	0f 91       	pop	r16
    2a18:	ff 90       	pop	r15
    2a1a:	ef 90       	pop	r14
    2a1c:	df 90       	pop	r13
    2a1e:	cf 90       	pop	r12
    2a20:	bf 90       	pop	r11
    2a22:	af 90       	pop	r10
    2a24:	9f 90       	pop	r9
    2a26:	8f 90       	pop	r8
    2a28:	7f 90       	pop	r7
    2a2a:	6f 90       	pop	r6
    2a2c:	5f 90       	pop	r5
    2a2e:	4f 90       	pop	r4
    2a30:	3f 90       	pop	r3
    2a32:	2f 90       	pop	r2
    2a34:	1f 90       	pop	r1
    2a36:	0f 90       	pop	r0
    2a38:	0f be       	out	0x3f, r0	; 63
    2a3a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2a3c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2a3e:	81 e0       	ldi	r24, 0x01	; 1
    2a40:	08 95       	ret

00002a42 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2a42:	08 95       	ret

00002a44 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2a44:	0f 92       	push	r0
    2a46:	0f b6       	in	r0, 0x3f	; 63
    2a48:	f8 94       	cli
    2a4a:	0f 92       	push	r0
    2a4c:	1f 92       	push	r1
    2a4e:	11 24       	eor	r1, r1
    2a50:	2f 92       	push	r2
    2a52:	3f 92       	push	r3
    2a54:	4f 92       	push	r4
    2a56:	5f 92       	push	r5
    2a58:	6f 92       	push	r6
    2a5a:	7f 92       	push	r7
    2a5c:	8f 92       	push	r8
    2a5e:	9f 92       	push	r9
    2a60:	af 92       	push	r10
    2a62:	bf 92       	push	r11
    2a64:	cf 92       	push	r12
    2a66:	df 92       	push	r13
    2a68:	ef 92       	push	r14
    2a6a:	ff 92       	push	r15
    2a6c:	0f 93       	push	r16
    2a6e:	1f 93       	push	r17
    2a70:	2f 93       	push	r18
    2a72:	3f 93       	push	r19
    2a74:	4f 93       	push	r20
    2a76:	5f 93       	push	r21
    2a78:	6f 93       	push	r22
    2a7a:	7f 93       	push	r23
    2a7c:	8f 93       	push	r24
    2a7e:	9f 93       	push	r25
    2a80:	af 93       	push	r26
    2a82:	bf 93       	push	r27
    2a84:	cf 93       	push	r28
    2a86:	df 93       	push	r29
    2a88:	ef 93       	push	r30
    2a8a:	ff 93       	push	r31
    2a8c:	a0 91 56 01 	lds	r26, 0x0156	; 0x800156 <pxCurrentTCB>
    2a90:	b0 91 57 01 	lds	r27, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    2a94:	0d b6       	in	r0, 0x3d	; 61
    2a96:	0d 92       	st	X+, r0
    2a98:	0e b6       	in	r0, 0x3e	; 62
    2a9a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2a9c:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2aa0:	a0 91 56 01 	lds	r26, 0x0156	; 0x800156 <pxCurrentTCB>
    2aa4:	b0 91 57 01 	lds	r27, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    2aa8:	cd 91       	ld	r28, X+
    2aaa:	cd bf       	out	0x3d, r28	; 61
    2aac:	dd 91       	ld	r29, X+
    2aae:	de bf       	out	0x3e, r29	; 62
    2ab0:	ff 91       	pop	r31
    2ab2:	ef 91       	pop	r30
    2ab4:	df 91       	pop	r29
    2ab6:	cf 91       	pop	r28
    2ab8:	bf 91       	pop	r27
    2aba:	af 91       	pop	r26
    2abc:	9f 91       	pop	r25
    2abe:	8f 91       	pop	r24
    2ac0:	7f 91       	pop	r23
    2ac2:	6f 91       	pop	r22
    2ac4:	5f 91       	pop	r21
    2ac6:	4f 91       	pop	r20
    2ac8:	3f 91       	pop	r19
    2aca:	2f 91       	pop	r18
    2acc:	1f 91       	pop	r17
    2ace:	0f 91       	pop	r16
    2ad0:	ff 90       	pop	r15
    2ad2:	ef 90       	pop	r14
    2ad4:	df 90       	pop	r13
    2ad6:	cf 90       	pop	r12
    2ad8:	bf 90       	pop	r11
    2ada:	af 90       	pop	r10
    2adc:	9f 90       	pop	r9
    2ade:	8f 90       	pop	r8
    2ae0:	7f 90       	pop	r7
    2ae2:	6f 90       	pop	r6
    2ae4:	5f 90       	pop	r5
    2ae6:	4f 90       	pop	r4
    2ae8:	3f 90       	pop	r3
    2aea:	2f 90       	pop	r2
    2aec:	1f 90       	pop	r1
    2aee:	0f 90       	pop	r0
    2af0:	0f be       	out	0x3f, r0	; 63
    2af2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2af4:	08 95       	ret

00002af6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2af6:	0f 92       	push	r0
    2af8:	0f b6       	in	r0, 0x3f	; 63
    2afa:	f8 94       	cli
    2afc:	0f 92       	push	r0
    2afe:	1f 92       	push	r1
    2b00:	11 24       	eor	r1, r1
    2b02:	2f 92       	push	r2
    2b04:	3f 92       	push	r3
    2b06:	4f 92       	push	r4
    2b08:	5f 92       	push	r5
    2b0a:	6f 92       	push	r6
    2b0c:	7f 92       	push	r7
    2b0e:	8f 92       	push	r8
    2b10:	9f 92       	push	r9
    2b12:	af 92       	push	r10
    2b14:	bf 92       	push	r11
    2b16:	cf 92       	push	r12
    2b18:	df 92       	push	r13
    2b1a:	ef 92       	push	r14
    2b1c:	ff 92       	push	r15
    2b1e:	0f 93       	push	r16
    2b20:	1f 93       	push	r17
    2b22:	2f 93       	push	r18
    2b24:	3f 93       	push	r19
    2b26:	4f 93       	push	r20
    2b28:	5f 93       	push	r21
    2b2a:	6f 93       	push	r22
    2b2c:	7f 93       	push	r23
    2b2e:	8f 93       	push	r24
    2b30:	9f 93       	push	r25
    2b32:	af 93       	push	r26
    2b34:	bf 93       	push	r27
    2b36:	cf 93       	push	r28
    2b38:	df 93       	push	r29
    2b3a:	ef 93       	push	r30
    2b3c:	ff 93       	push	r31
    2b3e:	a0 91 56 01 	lds	r26, 0x0156	; 0x800156 <pxCurrentTCB>
    2b42:	b0 91 57 01 	lds	r27, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    2b46:	0d b6       	in	r0, 0x3d	; 61
    2b48:	0d 92       	st	X+, r0
    2b4a:	0e b6       	in	r0, 0x3e	; 62
    2b4c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2b4e:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <xTaskIncrementTick>
    2b52:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2b54:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2b58:	a0 91 56 01 	lds	r26, 0x0156	; 0x800156 <pxCurrentTCB>
    2b5c:	b0 91 57 01 	lds	r27, 0x0157	; 0x800157 <pxCurrentTCB+0x1>
    2b60:	cd 91       	ld	r28, X+
    2b62:	cd bf       	out	0x3d, r28	; 61
    2b64:	dd 91       	ld	r29, X+
    2b66:	de bf       	out	0x3e, r29	; 62
    2b68:	ff 91       	pop	r31
    2b6a:	ef 91       	pop	r30
    2b6c:	df 91       	pop	r29
    2b6e:	cf 91       	pop	r28
    2b70:	bf 91       	pop	r27
    2b72:	af 91       	pop	r26
    2b74:	9f 91       	pop	r25
    2b76:	8f 91       	pop	r24
    2b78:	7f 91       	pop	r23
    2b7a:	6f 91       	pop	r22
    2b7c:	5f 91       	pop	r21
    2b7e:	4f 91       	pop	r20
    2b80:	3f 91       	pop	r19
    2b82:	2f 91       	pop	r18
    2b84:	1f 91       	pop	r17
    2b86:	0f 91       	pop	r16
    2b88:	ff 90       	pop	r15
    2b8a:	ef 90       	pop	r14
    2b8c:	df 90       	pop	r13
    2b8e:	cf 90       	pop	r12
    2b90:	bf 90       	pop	r11
    2b92:	af 90       	pop	r10
    2b94:	9f 90       	pop	r9
    2b96:	8f 90       	pop	r8
    2b98:	7f 90       	pop	r7
    2b9a:	6f 90       	pop	r6
    2b9c:	5f 90       	pop	r5
    2b9e:	4f 90       	pop	r4
    2ba0:	3f 90       	pop	r3
    2ba2:	2f 90       	pop	r2
    2ba4:	1f 90       	pop	r1
    2ba6:	0f 90       	pop	r0
    2ba8:	0f be       	out	0x3f, r0	; 63
    2baa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2bac:	08 95       	ret

00002bae <SIG_OUTPUT_COMPARE1A>:
    2bae:	0e 94 7b 15 	call	0x2af6	; 0x2af6 <vPortYieldFromTick>
    2bb2:	18 95       	reti

00002bb4 <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

short main( void )
{
    2bb4:	ef 92       	push	r14
    2bb6:	ff 92       	push	r15
    2bb8:	0f 93       	push	r16
    2bba:	cf 93       	push	r28
    2bbc:	df 93       	push	r29
    2bbe:	1f 92       	push	r1
    2bc0:	cd b7       	in	r28, 0x3d	; 61
    2bc2:	de b7       	in	r29, 0x3e	; 62

static void prvIncrementResetCount( void )
{
unsigned char ucCount;

	eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
    2bc4:	41 e0       	ldi	r20, 0x01	; 1
    2bc6:	50 e0       	ldi	r21, 0x00	; 0
    2bc8:	60 e5       	ldi	r22, 0x50	; 80
    2bca:	70 e0       	ldi	r23, 0x00	; 0
    2bcc:	ce 01       	movw	r24, r28
    2bce:	01 96       	adiw	r24, 0x01	; 1
    2bd0:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <eeprom_read_block>
	ucCount++;
    2bd4:	69 81       	ldd	r22, Y+1	; 0x01
    2bd6:	6f 5f       	subi	r22, 0xFF	; 255
    2bd8:	69 83       	std	Y+1, r22	; 0x01
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
    2bda:	80 e5       	ldi	r24, 0x50	; 80
    2bdc:	90 e0       	ldi	r25, 0x00	; 0
    2bde:	0e 94 ae 16 	call	0x2d5c	; 0x2d5c <eeprom_write_byte>
short main( void )
{
	prvIncrementResetCount();

	/* Setup the LED's for output. */
	vParTestInitialise();
    2be2:	0e 94 8d 00 	call	0x11a	; 0x11a <vParTestInitialise>

	/* Create the standard demo tasks. */
	vStartIntegerMathTasks( tskIDLE_PRIORITY );
    2be6:	80 e0       	ldi	r24, 0x00	; 0
    2be8:	0e 94 25 13 	call	0x264a	; 0x264a <vStartIntegerMathTasks>
	vAltStartComTestTasks( mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED );
    2bec:	24 e0       	ldi	r18, 0x04	; 4
    2bee:	40 e8       	ldi	r20, 0x80	; 128
    2bf0:	55 e2       	ldi	r21, 0x25	; 37
    2bf2:	60 e0       	ldi	r22, 0x00	; 0
    2bf4:	70 e0       	ldi	r23, 0x00	; 0
    2bf6:	82 e0       	ldi	r24, 0x02	; 2
    2bf8:	0e 94 47 14 	call	0x288e	; 0x288e <vAltStartComTestTasks>
	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
    2bfc:	82 e0       	ldi	r24, 0x02	; 2
    2bfe:	0e 94 ac 13 	call	0x2758	; 0x2758 <vStartPolledQueueTasks>
	vStartRegTestTasks();
    2c02:	0e 94 2b 03 	call	0x656	; 0x656 <vStartRegTestTasks>

	/* Create the tasks defined within this file. */
	xTaskCreate( vErrorChecks, "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
    2c06:	e1 2c       	mov	r14, r1
    2c08:	f1 2c       	mov	r15, r1
    2c0a:	03 e0       	ldi	r16, 0x03	; 3
    2c0c:	20 e0       	ldi	r18, 0x00	; 0
    2c0e:	30 e0       	ldi	r19, 0x00	; 0
    2c10:	45 e5       	ldi	r20, 0x55	; 85
    2c12:	50 e0       	ldi	r21, 0x00	; 0
    2c14:	66 e1       	ldi	r22, 0x16	; 22
    2c16:	71 e0       	ldi	r23, 0x01	; 1
    2c18:	83 e5       	ldi	r24, 0x53	; 83
    2c1a:	90 e0       	ldi	r25, 0x00	; 0
    2c1c:	0e 94 db 03 	call	0x7b6	; 0x7b6 <xTaskCreate>

	/* Create the co-routines that flash the LED's. */
	vStartFlashCoRoutines( mainNUM_FLASH_COROUTINES );
    2c20:	83 e0       	ldi	r24, 0x03	; 3
    2c22:	0e 94 a7 12 	call	0x254e	; 0x254e <vStartFlashCoRoutines>

	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
    2c26:	0e 94 2b 05 	call	0xa56	; 0xa56 <vTaskStartScheduler>

	return 0;
}
    2c2a:	80 e0       	ldi	r24, 0x00	; 0
    2c2c:	90 e0       	ldi	r25, 0x00	; 0
    2c2e:	0f 90       	pop	r0
    2c30:	df 91       	pop	r29
    2c32:	cf 91       	pop	r28
    2c34:	0f 91       	pop	r16
    2c36:	ff 90       	pop	r15
    2c38:	ef 90       	pop	r14
    2c3a:	08 95       	ret

00002c3c <__udivmodhi4>:
    2c3c:	aa 1b       	sub	r26, r26
    2c3e:	bb 1b       	sub	r27, r27
    2c40:	51 e1       	ldi	r21, 0x11	; 17
    2c42:	07 c0       	rjmp	.+14     	; 0x2c52 <__udivmodhi4_ep>

00002c44 <__udivmodhi4_loop>:
    2c44:	aa 1f       	adc	r26, r26
    2c46:	bb 1f       	adc	r27, r27
    2c48:	a6 17       	cp	r26, r22
    2c4a:	b7 07       	cpc	r27, r23
    2c4c:	10 f0       	brcs	.+4      	; 0x2c52 <__udivmodhi4_ep>
    2c4e:	a6 1b       	sub	r26, r22
    2c50:	b7 0b       	sbc	r27, r23

00002c52 <__udivmodhi4_ep>:
    2c52:	88 1f       	adc	r24, r24
    2c54:	99 1f       	adc	r25, r25
    2c56:	5a 95       	dec	r21
    2c58:	a9 f7       	brne	.-22     	; 0x2c44 <__udivmodhi4_loop>
    2c5a:	80 95       	com	r24
    2c5c:	90 95       	com	r25
    2c5e:	bc 01       	movw	r22, r24
    2c60:	cd 01       	movw	r24, r26
    2c62:	08 95       	ret

00002c64 <__udivmodsi4>:
    2c64:	a1 e2       	ldi	r26, 0x21	; 33
    2c66:	1a 2e       	mov	r1, r26
    2c68:	aa 1b       	sub	r26, r26
    2c6a:	bb 1b       	sub	r27, r27
    2c6c:	fd 01       	movw	r30, r26
    2c6e:	0d c0       	rjmp	.+26     	; 0x2c8a <__udivmodsi4_ep>

00002c70 <__udivmodsi4_loop>:
    2c70:	aa 1f       	adc	r26, r26
    2c72:	bb 1f       	adc	r27, r27
    2c74:	ee 1f       	adc	r30, r30
    2c76:	ff 1f       	adc	r31, r31
    2c78:	a2 17       	cp	r26, r18
    2c7a:	b3 07       	cpc	r27, r19
    2c7c:	e4 07       	cpc	r30, r20
    2c7e:	f5 07       	cpc	r31, r21
    2c80:	20 f0       	brcs	.+8      	; 0x2c8a <__udivmodsi4_ep>
    2c82:	a2 1b       	sub	r26, r18
    2c84:	b3 0b       	sbc	r27, r19
    2c86:	e4 0b       	sbc	r30, r20
    2c88:	f5 0b       	sbc	r31, r21

00002c8a <__udivmodsi4_ep>:
    2c8a:	66 1f       	adc	r22, r22
    2c8c:	77 1f       	adc	r23, r23
    2c8e:	88 1f       	adc	r24, r24
    2c90:	99 1f       	adc	r25, r25
    2c92:	1a 94       	dec	r1
    2c94:	69 f7       	brne	.-38     	; 0x2c70 <__udivmodsi4_loop>
    2c96:	60 95       	com	r22
    2c98:	70 95       	com	r23
    2c9a:	80 95       	com	r24
    2c9c:	90 95       	com	r25
    2c9e:	9b 01       	movw	r18, r22
    2ca0:	ac 01       	movw	r20, r24
    2ca2:	bd 01       	movw	r22, r26
    2ca4:	cf 01       	movw	r24, r30
    2ca6:	08 95       	ret

00002ca8 <__divmodsi4>:
    2ca8:	05 2e       	mov	r0, r21
    2caa:	97 fb       	bst	r25, 7
    2cac:	1e f4       	brtc	.+6      	; 0x2cb4 <__divmodsi4+0xc>
    2cae:	00 94       	com	r0
    2cb0:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <__negsi2>
    2cb4:	57 fd       	sbrc	r21, 7
    2cb6:	07 d0       	rcall	.+14     	; 0x2cc6 <__divmodsi4_neg2>
    2cb8:	0e 94 32 16 	call	0x2c64	; 0x2c64 <__udivmodsi4>
    2cbc:	07 fc       	sbrc	r0, 7
    2cbe:	03 d0       	rcall	.+6      	; 0x2cc6 <__divmodsi4_neg2>
    2cc0:	4e f4       	brtc	.+18     	; 0x2cd4 <__divmodsi4_exit>
    2cc2:	0c 94 6b 16 	jmp	0x2cd6	; 0x2cd6 <__negsi2>

00002cc6 <__divmodsi4_neg2>:
    2cc6:	50 95       	com	r21
    2cc8:	40 95       	com	r20
    2cca:	30 95       	com	r19
    2ccc:	21 95       	neg	r18
    2cce:	3f 4f       	sbci	r19, 0xFF	; 255
    2cd0:	4f 4f       	sbci	r20, 0xFF	; 255
    2cd2:	5f 4f       	sbci	r21, 0xFF	; 255

00002cd4 <__divmodsi4_exit>:
    2cd4:	08 95       	ret

00002cd6 <__negsi2>:
    2cd6:	90 95       	com	r25
    2cd8:	80 95       	com	r24
    2cda:	70 95       	com	r23
    2cdc:	61 95       	neg	r22
    2cde:	7f 4f       	sbci	r23, 0xFF	; 255
    2ce0:	8f 4f       	sbci	r24, 0xFF	; 255
    2ce2:	9f 4f       	sbci	r25, 0xFF	; 255
    2ce4:	08 95       	ret

00002ce6 <__muluhisi3>:
    2ce6:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <__umulhisi3>
    2cea:	a5 9f       	mul	r26, r21
    2cec:	90 0d       	add	r25, r0
    2cee:	b4 9f       	mul	r27, r20
    2cf0:	90 0d       	add	r25, r0
    2cf2:	a4 9f       	mul	r26, r20
    2cf4:	80 0d       	add	r24, r0
    2cf6:	91 1d       	adc	r25, r1
    2cf8:	11 24       	eor	r1, r1
    2cfa:	08 95       	ret

00002cfc <__mulshisi3>:
    2cfc:	b7 ff       	sbrs	r27, 7
    2cfe:	0c 94 73 16 	jmp	0x2ce6	; 0x2ce6 <__muluhisi3>

00002d02 <__mulohisi3>:
    2d02:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <__muluhisi3>
    2d06:	82 1b       	sub	r24, r18
    2d08:	93 0b       	sbc	r25, r19
    2d0a:	08 95       	ret

00002d0c <__umulhisi3>:
    2d0c:	a2 9f       	mul	r26, r18
    2d0e:	b0 01       	movw	r22, r0
    2d10:	b3 9f       	mul	r27, r19
    2d12:	c0 01       	movw	r24, r0
    2d14:	a3 9f       	mul	r26, r19
    2d16:	70 0d       	add	r23, r0
    2d18:	81 1d       	adc	r24, r1
    2d1a:	11 24       	eor	r1, r1
    2d1c:	91 1d       	adc	r25, r1
    2d1e:	b2 9f       	mul	r27, r18
    2d20:	70 0d       	add	r23, r0
    2d22:	81 1d       	adc	r24, r1
    2d24:	11 24       	eor	r1, r1
    2d26:	91 1d       	adc	r25, r1
    2d28:	08 95       	ret

00002d2a <memcpy>:
    2d2a:	fb 01       	movw	r30, r22
    2d2c:	dc 01       	movw	r26, r24
    2d2e:	02 c0       	rjmp	.+4      	; 0x2d34 <memcpy+0xa>
    2d30:	01 90       	ld	r0, Z+
    2d32:	0d 92       	st	X+, r0
    2d34:	41 50       	subi	r20, 0x01	; 1
    2d36:	50 40       	sbci	r21, 0x00	; 0
    2d38:	d8 f7       	brcc	.-10     	; 0x2d30 <memcpy+0x6>
    2d3a:	08 95       	ret

00002d3c <eeprom_read_block>:
    2d3c:	dc 01       	movw	r26, r24
    2d3e:	cb 01       	movw	r24, r22

00002d40 <eeprom_read_blraw>:
    2d40:	fc 01       	movw	r30, r24
    2d42:	f9 99       	sbic	0x1f, 1	; 31
    2d44:	fe cf       	rjmp	.-4      	; 0x2d42 <eeprom_read_blraw+0x2>
    2d46:	06 c0       	rjmp	.+12     	; 0x2d54 <eeprom_read_blraw+0x14>
    2d48:	f2 bd       	out	0x22, r31	; 34
    2d4a:	e1 bd       	out	0x21, r30	; 33
    2d4c:	f8 9a       	sbi	0x1f, 0	; 31
    2d4e:	31 96       	adiw	r30, 0x01	; 1
    2d50:	00 b4       	in	r0, 0x20	; 32
    2d52:	0d 92       	st	X+, r0
    2d54:	41 50       	subi	r20, 0x01	; 1
    2d56:	50 40       	sbci	r21, 0x00	; 0
    2d58:	b8 f7       	brcc	.-18     	; 0x2d48 <eeprom_read_blraw+0x8>
    2d5a:	08 95       	ret

00002d5c <eeprom_write_byte>:
    2d5c:	26 2f       	mov	r18, r22

00002d5e <eeprom_write_r18>:
    2d5e:	f9 99       	sbic	0x1f, 1	; 31
    2d60:	fe cf       	rjmp	.-4      	; 0x2d5e <eeprom_write_r18>
    2d62:	1f ba       	out	0x1f, r1	; 31
    2d64:	92 bd       	out	0x22, r25	; 34
    2d66:	81 bd       	out	0x21, r24	; 33
    2d68:	20 bd       	out	0x20, r18	; 32
    2d6a:	0f b6       	in	r0, 0x3f	; 63
    2d6c:	f8 94       	cli
    2d6e:	fa 9a       	sbi	0x1f, 2	; 31
    2d70:	f9 9a       	sbi	0x1f, 1	; 31
    2d72:	0f be       	out	0x3f, r0	; 63
    2d74:	01 96       	adiw	r24, 0x01	; 1
    2d76:	08 95       	ret

00002d78 <_exit>:
    2d78:	f8 94       	cli

00002d7a <__stop_program>:
    2d7a:	ff cf       	rjmp	.-2      	; 0x2d7a <__stop_program>
