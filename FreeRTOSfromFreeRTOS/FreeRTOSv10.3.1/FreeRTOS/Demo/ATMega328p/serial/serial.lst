   1               		.file	"serial.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 202               	.global	xSerialPortInitMinimal
 204               	xSerialPortInitMinimal:
 205               		.stabd	46,0,0
   1:serial/serial.c **** /*
   2:serial/serial.c ****  * FreeRTOS Kernel V10.3.1
   3:serial/serial.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:serial/serial.c ****  *
   5:serial/serial.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:serial/serial.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:serial/serial.c ****  * the Software without restriction, including without limitation the rights to
   8:serial/serial.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:serial/serial.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:serial/serial.c ****  * subject to the following conditions:
  11:serial/serial.c ****  *
  12:serial/serial.c ****  * The above copyright notice and this permission notice shall be included in all
  13:serial/serial.c ****  * copies or substantial portions of the Software.
  14:serial/serial.c ****  *
  15:serial/serial.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:serial/serial.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:serial/serial.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:serial/serial.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:serial/serial.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:serial/serial.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:serial/serial.c ****  *
  22:serial/serial.c ****  * http://www.FreeRTOS.org
  23:serial/serial.c ****  * http://aws.amazon.com/freertos
  24:serial/serial.c ****  *
  25:serial/serial.c ****  * 1 tab == 4 spaces!
  26:serial/serial.c ****  */
  27:serial/serial.c **** 
  28:serial/serial.c **** /*
  29:serial/serial.c **** Changes from V1.2.3
  30:serial/serial.c **** 
  31:serial/serial.c **** 	+ The function xPortInitMinimal() has been renamed to 
  32:serial/serial.c **** 	  xSerialPortInitMinimal() and the function xPortInit() has been renamed
  33:serial/serial.c **** 	  to xSerialPortInit().
  34:serial/serial.c **** 
  35:serial/serial.c **** Changes from V2.0.0
  36:serial/serial.c **** 
  37:serial/serial.c **** 	+ Delay periods are now specified using variables and constants of
  38:serial/serial.c **** 	  TickType_t rather than unsigned long.
  39:serial/serial.c **** 	+ xQueueReceiveFromISR() used in place of xQueueReceive() within the ISR.
  40:serial/serial.c **** 
  41:serial/serial.c **** Changes from V2.6.0
  42:serial/serial.c **** 
  43:serial/serial.c **** 	+ Replaced the inb() and outb() functions with direct memory
  44:serial/serial.c **** 	  access.  This allows the port to be built with the 20050414 build of
  45:serial/serial.c **** 	  WinAVR.
  46:serial/serial.c **** */
  47:serial/serial.c **** 
  48:serial/serial.c **** /* BASIC INTERRUPT DRIVEN SERIAL PORT DRIVER. */
  49:serial/serial.c **** 
  50:serial/serial.c **** 
  51:serial/serial.c **** #include <stdlib.h>
  52:serial/serial.c **** #include <avr/interrupt.h>
  53:serial/serial.c **** #include "FreeRTOS.h"
  54:serial/serial.c **** #include "queue.h"
  55:serial/serial.c **** #include "task.h"
  56:serial/serial.c **** #include "serial.h"
  57:serial/serial.c **** 
  58:serial/serial.c **** #define serBAUD_DIV_CONSTANT			( ( unsigned long ) 16 )
  59:serial/serial.c **** 
  60:serial/serial.c **** /* Constants for writing to UCSRB. */
  61:serial/serial.c **** #define serRX_INT_ENABLE				( ( unsigned char ) 0x80 )
  62:serial/serial.c **** #define serRX_ENABLE					( ( unsigned char ) 0x10 )
  63:serial/serial.c **** #define serTX_ENABLE					( ( unsigned char ) 0x08 )
  64:serial/serial.c **** #define serTX_INT_ENABLE				( ( unsigned char ) 0x20 )
  65:serial/serial.c **** 
  66:serial/serial.c **** /* Constants for writing to UCSRC. */
  67:serial/serial.c **** #define serUCSRC_SELECT					( ( unsigned char ) 0x80 )
  68:serial/serial.c **** #define serEIGHT_DATA_BITS				( ( unsigned char ) 0x06 )
  69:serial/serial.c **** 
  70:serial/serial.c **** static QueueHandle_t xRxedChars; 
  71:serial/serial.c **** static QueueHandle_t xCharsForTx; 
  72:serial/serial.c **** 
  73:serial/serial.c **** #define vInterruptOn()										\
  74:serial/serial.c **** {															\
  75:serial/serial.c **** 	unsigned char ucByte;								\
  76:serial/serial.c **** 															\
  77:serial/serial.c **** 	ucByte = UCSR0B;											\
  78:serial/serial.c **** 	ucByte |= serTX_INT_ENABLE;								\
  79:serial/serial.c **** 	UCSR0B = ucByte;											\
  80:serial/serial.c **** }																				
  81:serial/serial.c **** /*-----------------------------------------------------------*/
  82:serial/serial.c **** 
  83:serial/serial.c **** #define vInterruptOff()										\
  84:serial/serial.c **** {															\
  85:serial/serial.c **** 	unsigned char ucInByte;								\
  86:serial/serial.c **** 															\
  87:serial/serial.c **** 	ucInByte = UCSR0B;										\
  88:serial/serial.c **** 	ucInByte &= ~serTX_INT_ENABLE;							\
  89:serial/serial.c **** 	UCSR0B = ucInByte;										\
  90:serial/serial.c **** }
  91:serial/serial.c **** /*-----------------------------------------------------------*/
  92:serial/serial.c **** 
  93:serial/serial.c **** xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLe
  94:serial/serial.c **** {
 207               	.LM0:
 208               	.LFBB1:
 209 0000 CF92      		push r12
 210 0002 DF92      		push r13
 211 0004 EF92      		push r14
 212 0006 FF92      		push r15
 213 0008 CF93      		push r28
 214               	/* prologue: function */
 215               	/* frame size = 0 */
 216               	/* stack size = 5 */
 217               	.L__stack_usage = 5
 218 000a 6B01      		movw r12,r22
 219 000c 7C01      		movw r14,r24
 220 000e C42F      		mov r28,r20
  95:serial/serial.c **** unsigned long ulBaudRateCounter;
  96:serial/serial.c **** unsigned char ucByte;
  97:serial/serial.c **** 
  98:serial/serial.c **** 	portENTER_CRITICAL();
 222               	.LM1:
 223               	/* #APP */
 224               	 ;  98 "serial/serial.c" 1
 225 0010 0FB6      		in		__tmp_reg__, __SREG__
 226               	 ;  0 "" 2
 227               	 ;  98 "serial/serial.c" 1
 228 0012 F894      		cli
 229               	 ;  0 "" 2
 230               	 ;  98 "serial/serial.c" 1
 231 0014 0F92      		push	__tmp_reg__
 232               	 ;  0 "" 2
  99:serial/serial.c **** 	{
 100:serial/serial.c **** 		/* Create the queues used by the com test task. */
 101:serial/serial.c **** 		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
 234               	.LM2:
 235               	/* #NOAPP */
 236 0016 40E0      		ldi r20,0
 237 0018 61E0      		ldi r22,lo8(1)
 238 001a 8C2F      		mov r24,r28
 239 001c 0E94 0000 		call xQueueGenericCreate
 240 0020 9093 0000 		sts xRxedChars+1,r25
 241 0024 8093 0000 		sts xRxedChars,r24
 102:serial/serial.c **** 		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
 243               	.LM3:
 244 0028 40E0      		ldi r20,0
 245 002a 61E0      		ldi r22,lo8(1)
 246 002c 8C2F      		mov r24,r28
 247 002e 0E94 0000 		call xQueueGenericCreate
 248 0032 9093 0000 		sts xCharsForTx+1,r25
 249 0036 8093 0000 		sts xCharsForTx,r24
 103:serial/serial.c **** 
 104:serial/serial.c **** 		/* Calculate the baud rate register value from the equation in the
 105:serial/serial.c **** 		data sheet. */
 106:serial/serial.c **** 		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned
 251               	.LM4:
 252 003a A701      		movw r20,r14
 253 003c 9601      		movw r18,r12
 254 003e 84E0      		ldi r24,4
 255               		1:
 256 0040 220F      		lsl r18
 257 0042 331F      		rol r19
 258 0044 441F      		rol r20
 259 0046 551F      		rol r21
 260 0048 8A95      		dec r24
 261 004a 01F4      		brne 1b
 262 004c 60E0      		ldi r22,0
 263 004e 7DE2      		ldi r23,lo8(45)
 264 0050 81E3      		ldi r24,lo8(49)
 265 0052 91E0      		ldi r25,lo8(1)
 266 0054 0E94 0000 		call __udivmodsi4
 267 0058 DA01      		movw r26,r20
 268 005a C901      		movw r24,r18
 269 005c 0197      		sbiw r24,1
 270 005e A109      		sbc r26,__zero_reg__
 271 0060 B109      		sbc r27,__zero_reg__
 107:serial/serial.c **** 
 108:serial/serial.c **** 		/* Set the baud rate. */	
 109:serial/serial.c **** 		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
 110:serial/serial.c **** 		UBRR0L = ucByte;
 273               	.LM5:
 274 0062 8093 C400 		sts 196,r24
 111:serial/serial.c **** 
 112:serial/serial.c **** 		ulBaudRateCounter >>= ( unsigned long ) 8;
 113:serial/serial.c **** 		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
 276               	.LM6:
 277 0066 892F      		mov r24,r25
 278 0068 9A2F      		mov r25,r26
 279 006a AB2F      		mov r26,r27
 280 006c BB27      		clr r27
 114:serial/serial.c **** 		UBRR0H = ucByte;
 282               	.LM7:
 283 006e 8093 C500 		sts 197,r24
 115:serial/serial.c **** 
 116:serial/serial.c **** 		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
 117:serial/serial.c **** 		later. Also enable the Rx and Tx. */
 118:serial/serial.c **** 		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
 285               	.LM8:
 286 0072 88E9      		ldi r24,lo8(-104)
 287 0074 8093 C100 		sts 193,r24
 119:serial/serial.c **** 
 120:serial/serial.c **** 		/* Set the data bits to 8. */
 121:serial/serial.c **** 		UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
 289               	.LM9:
 290 0078 86E8      		ldi r24,lo8(-122)
 291 007a 8093 C200 		sts 194,r24
 122:serial/serial.c **** 	}
 123:serial/serial.c **** 	portEXIT_CRITICAL();
 293               	.LM10:
 294               	/* #APP */
 295               	 ;  123 "serial/serial.c" 1
 296 007e 0F90      		pop		__tmp_reg__
 297               	 ;  0 "" 2
 298               	 ;  123 "serial/serial.c" 1
 299 0080 0FBE      		out		__SREG__, __tmp_reg__
 300               	 ;  0 "" 2
 124:serial/serial.c **** 	
 125:serial/serial.c **** 	/* Unlike other ports, this serial code does not allow for more than one
 126:serial/serial.c **** 	com port.  We therefore don't return a pointer to a port structure and can
 127:serial/serial.c **** 	instead just return NULL. */
 128:serial/serial.c **** 	return NULL;
 129:serial/serial.c **** }
 302               	.LM11:
 303               	/* #NOAPP */
 304 0082 80E0      		ldi r24,0
 305 0084 90E0      		ldi r25,0
 306               	/* epilogue start */
 307 0086 CF91      		pop r28
 308 0088 FF90      		pop r15
 309 008a EF90      		pop r14
 310 008c DF90      		pop r13
 311 008e CF90      		pop r12
 312 0090 0895      		ret
 314               	.Lscope1:
 316               		.stabd	78,0,0
 321               	.global	xSerialGetChar
 323               	xSerialGetChar:
 324               		.stabd	46,0,0
 130:serial/serial.c **** /*-----------------------------------------------------------*/
 131:serial/serial.c **** 
 132:serial/serial.c **** signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed char *pcRxedChar, TickType_t xBl
 133:serial/serial.c **** {
 326               	.LM12:
 327               	.LFBB2:
 328               	/* prologue: function */
 329               	/* frame size = 0 */
 330               	/* stack size = 0 */
 331               	.L__stack_usage = 0
 134:serial/serial.c **** 	/* Only one port is supported. */
 135:serial/serial.c **** 	( void ) pxPort;
 136:serial/serial.c **** 
 137:serial/serial.c **** 	/* Get the next character from the buffer.  Return false if no characters
 138:serial/serial.c **** 	are available, or arrive before xBlockTime expires. */
 139:serial/serial.c **** 	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
 333               	.LM13:
 334 0092 8091 0000 		lds r24,xRxedChars
 335 0096 9091 0000 		lds r25,xRxedChars+1
 336 009a 0E94 0000 		call xQueueReceive
 337 009e 91E0      		ldi r25,lo8(1)
 338 00a0 8111      		cpse r24,__zero_reg__
 339 00a2 00C0      		rjmp .L3
 340 00a4 90E0      		ldi r25,0
 341               	.L3:
 140:serial/serial.c **** 	{
 141:serial/serial.c **** 		return pdTRUE;
 142:serial/serial.c **** 	}
 143:serial/serial.c **** 	else
 144:serial/serial.c **** 	{
 145:serial/serial.c **** 		return pdFALSE;
 146:serial/serial.c **** 	}
 147:serial/serial.c **** }
 343               	.LM14:
 344 00a6 892F      		mov r24,r25
 345 00a8 0895      		ret
 347               	.Lscope2:
 349               		.stabd	78,0,0
 354               	.global	xSerialPutChar
 356               	xSerialPutChar:
 357               		.stabd	46,0,0
 148:serial/serial.c **** /*-----------------------------------------------------------*/
 149:serial/serial.c **** 
 150:serial/serial.c **** signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlock
 151:serial/serial.c **** {
 359               	.LM15:
 360               	.LFBB3:
 361 00aa CF93      		push r28
 362 00ac DF93      		push r29
 363 00ae 1F92      		push __zero_reg__
 364 00b0 CDB7      		in r28,__SP_L__
 365 00b2 DEB7      		in r29,__SP_H__
 366               	/* prologue: function */
 367               	/* frame size = 1 */
 368               	/* stack size = 3 */
 369               	.L__stack_usage = 3
 370 00b4 6983      		std Y+1,r22
 152:serial/serial.c **** 	/* Only one port is supported. */
 153:serial/serial.c **** 	( void ) pxPort;
 154:serial/serial.c **** 
 155:serial/serial.c **** 	/* Return false if after the block time there is no room on the Tx queue. */
 156:serial/serial.c **** 	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
 372               	.LM16:
 373 00b6 20E0      		ldi r18,0
 374 00b8 BE01      		movw r22,r28
 375 00ba 6F5F      		subi r22,-1
 376 00bc 7F4F      		sbci r23,-1
 377 00be 8091 0000 		lds r24,xCharsForTx
 378 00c2 9091 0000 		lds r25,xCharsForTx+1
 379 00c6 0E94 0000 		call xQueueGenericSend
 380 00ca 8130      		cpi r24,lo8(1)
 381 00cc 01F4      		brne .L7
 382               	.LBB2:
 157:serial/serial.c **** 	{
 158:serial/serial.c **** 		return pdFAIL;
 159:serial/serial.c **** 	}
 160:serial/serial.c **** 
 161:serial/serial.c **** 	vInterruptOn();
 384               	.LM17:
 385 00ce 9091 C100 		lds r25,193
 386 00d2 9062      		ori r25,lo8(32)
 387 00d4 9093 C100 		sts 193,r25
 388               	.LBE2:
 162:serial/serial.c **** 
 163:serial/serial.c **** 	return pdPASS;
 390               	.LM18:
 391 00d8 00C0      		rjmp .L6
 392               	.L7:
 158:serial/serial.c **** 	}
 394               	.LM19:
 395 00da 80E0      		ldi r24,0
 396               	.L6:
 397               	/* epilogue start */
 164:serial/serial.c **** }
 399               	.LM20:
 400 00dc 0F90      		pop __tmp_reg__
 401 00de DF91      		pop r29
 402 00e0 CF91      		pop r28
 403 00e2 0895      		ret
 405               	.Lscope3:
 407               		.stabd	78,0,0
 410               	.global	vSerialClose
 412               	vSerialClose:
 413               		.stabd	46,0,0
 165:serial/serial.c **** /*-----------------------------------------------------------*/
 166:serial/serial.c **** 
 167:serial/serial.c **** void vSerialClose( xComPortHandle xPort )
 168:serial/serial.c **** {
 415               	.LM21:
 416               	.LFBB4:
 417               	/* prologue: function */
 418               	/* frame size = 0 */
 419               	/* stack size = 0 */
 420               	.L__stack_usage = 0
 169:serial/serial.c **** unsigned char ucByte;
 170:serial/serial.c **** 
 171:serial/serial.c **** 	/* The parameter is not used. */
 172:serial/serial.c **** 	( void ) xPort;
 173:serial/serial.c **** 
 174:serial/serial.c **** 	/* Turn off the interrupts.  We may also want to delete the queues and/or
 175:serial/serial.c **** 	re-install the original ISR. */
 176:serial/serial.c **** 
 177:serial/serial.c **** 	portENTER_CRITICAL();
 422               	.LM22:
 423               	/* #APP */
 424               	 ;  177 "serial/serial.c" 1
 425 00e4 0FB6      		in		__tmp_reg__, __SREG__
 426               	 ;  0 "" 2
 427               	 ;  177 "serial/serial.c" 1
 428 00e6 F894      		cli
 429               	 ;  0 "" 2
 430               	 ;  177 "serial/serial.c" 1
 431 00e8 0F92      		push	__tmp_reg__
 432               	 ;  0 "" 2
 433               	/* #NOAPP */
 434               	.LBB3:
 178:serial/serial.c **** 	{
 179:serial/serial.c **** 		vInterruptOff();
 436               	.LM23:
 437 00ea E1EC      		ldi r30,lo8(-63)
 438 00ec F0E0      		ldi r31,0
 439 00ee 8081      		ld r24,Z
 440 00f0 8F7D      		andi r24,lo8(-33)
 441 00f2 8083      		st Z,r24
 442               	.LBE3:
 180:serial/serial.c **** 		ucByte = UCSR0B;
 444               	.LM24:
 445 00f4 8081      		ld r24,Z
 181:serial/serial.c **** 		ucByte &= ~serRX_INT_ENABLE;
 447               	.LM25:
 448 00f6 8F77      		andi r24,lo8(127)
 182:serial/serial.c **** 		UCSR0B = ucByte;
 450               	.LM26:
 451 00f8 8083      		st Z,r24
 183:serial/serial.c **** 	}
 184:serial/serial.c **** 	portEXIT_CRITICAL();
 453               	.LM27:
 454               	/* #APP */
 455               	 ;  184 "serial/serial.c" 1
 456 00fa 0F90      		pop		__tmp_reg__
 457               	 ;  0 "" 2
 458               	 ;  184 "serial/serial.c" 1
 459 00fc 0FBE      		out		__SREG__, __tmp_reg__
 460               	 ;  0 "" 2
 461               	/* #NOAPP */
 462 00fe 0895      		ret
 464               	.Lscope4:
 466               		.stabd	78,0,0
 468               	.global	SIG_UART_RECV
 470               	SIG_UART_RECV:
 471               		.stabd	46,0,0
 185:serial/serial.c **** }
 186:serial/serial.c **** /*-----------------------------------------------------------*/
 187:serial/serial.c **** 
 188:serial/serial.c **** SIGNAL( SIG_UART_RECV )
 189:serial/serial.c **** {
 473               	.LM28:
 474               	.LFBB5:
 475 0100 1F92      		push r1
 476 0102 0F92      		push r0
 477 0104 0FB6      		in r0,__SREG__
 478 0106 0F92      		push r0
 479 0108 1124      		clr __zero_reg__
 480 010a 2F93      		push r18
 481 010c 3F93      		push r19
 482 010e 4F93      		push r20
 483 0110 5F93      		push r21
 484 0112 6F93      		push r22
 485 0114 7F93      		push r23
 486 0116 8F93      		push r24
 487 0118 9F93      		push r25
 488 011a AF93      		push r26
 489 011c BF93      		push r27
 490 011e EF93      		push r30
 491 0120 FF93      		push r31
 492 0122 CF93      		push r28
 493 0124 DF93      		push r29
 494 0126 00D0      		rcall .
 495 0128 CDB7      		in r28,__SP_L__
 496 012a DEB7      		in r29,__SP_H__
 497               	/* prologue: Signal */
 498               	/* frame size = 2 */
 499               	/* stack size = 19 */
 500               	.L__stack_usage = 19
 190:serial/serial.c **** signed char cChar;
 191:serial/serial.c **** signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 502               	.LM29:
 503 012c 1982      		std Y+1,__zero_reg__
 192:serial/serial.c **** 
 193:serial/serial.c **** 	/* Get the character and post it on the queue of Rxed characters.
 194:serial/serial.c **** 	If the post causes a task to wake force a context switch as the woken task
 195:serial/serial.c **** 	may have a higher priority than the task we have interrupted. */
 196:serial/serial.c **** 	cChar = UDR0;
 505               	.LM30:
 506 012e 8091 C600 		lds r24,198
 507 0132 8A83      		std Y+2,r24
 197:serial/serial.c **** 
 198:serial/serial.c **** 	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
 509               	.LM31:
 510 0134 20E0      		ldi r18,0
 511 0136 AE01      		movw r20,r28
 512 0138 4F5F      		subi r20,-1
 513 013a 5F4F      		sbci r21,-1
 514 013c BE01      		movw r22,r28
 515 013e 6E5F      		subi r22,-2
 516 0140 7F4F      		sbci r23,-1
 517 0142 8091 0000 		lds r24,xRxedChars
 518 0146 9091 0000 		lds r25,xRxedChars+1
 519 014a 0E94 0000 		call xQueueGenericSendFromISR
 199:serial/serial.c **** 
 200:serial/serial.c **** 	if( xHigherPriorityTaskWoken != pdFALSE )
 521               	.LM32:
 522 014e 8981      		ldd r24,Y+1
 523 0150 8111      		cpse r24,__zero_reg__
 201:serial/serial.c **** 	{
 202:serial/serial.c **** 		taskYIELD();
 525               	.LM33:
 526 0152 0E94 0000 		call vPortYield
 527               	.L9:
 528               	/* epilogue start */
 203:serial/serial.c **** 	}
 204:serial/serial.c **** }
 530               	.LM34:
 531 0156 0F90      		pop __tmp_reg__
 532 0158 0F90      		pop __tmp_reg__
 533 015a DF91      		pop r29
 534 015c CF91      		pop r28
 535 015e FF91      		pop r31
 536 0160 EF91      		pop r30
 537 0162 BF91      		pop r27
 538 0164 AF91      		pop r26
 539 0166 9F91      		pop r25
 540 0168 8F91      		pop r24
 541 016a 7F91      		pop r23
 542 016c 6F91      		pop r22
 543 016e 5F91      		pop r21
 544 0170 4F91      		pop r20
 545 0172 3F91      		pop r19
 546 0174 2F91      		pop r18
 547 0176 0F90      		pop r0
 548 0178 0FBE      		out __SREG__,r0
 549 017a 0F90      		pop r0
 550 017c 1F90      		pop r1
 551 017e 1895      		reti
 557               	.Lscope5:
 559               		.stabd	78,0,0
 561               	.global	SIG_UART_DATA
 563               	SIG_UART_DATA:
 564               		.stabd	46,0,0
 205:serial/serial.c **** /*-----------------------------------------------------------*/
 206:serial/serial.c **** 
 207:serial/serial.c **** SIGNAL( SIG_UART_DATA )
 208:serial/serial.c **** {
 566               	.LM35:
 567               	.LFBB6:
 568 0180 1F92      		push r1
 569 0182 0F92      		push r0
 570 0184 0FB6      		in r0,__SREG__
 571 0186 0F92      		push r0
 572 0188 1124      		clr __zero_reg__
 573 018a 2F93      		push r18
 574 018c 3F93      		push r19
 575 018e 4F93      		push r20
 576 0190 5F93      		push r21
 577 0192 6F93      		push r22
 578 0194 7F93      		push r23
 579 0196 8F93      		push r24
 580 0198 9F93      		push r25
 581 019a AF93      		push r26
 582 019c BF93      		push r27
 583 019e EF93      		push r30
 584 01a0 FF93      		push r31
 585 01a2 CF93      		push r28
 586 01a4 DF93      		push r29
 587 01a6 00D0      		rcall .
 588 01a8 CDB7      		in r28,__SP_L__
 589 01aa DEB7      		in r29,__SP_H__
 590               	/* prologue: Signal */
 591               	/* frame size = 2 */
 592               	/* stack size = 19 */
 593               	.L__stack_usage = 19
 209:serial/serial.c **** signed char cChar, cTaskWoken;
 210:serial/serial.c **** 
 211:serial/serial.c **** 	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
 595               	.LM36:
 596 01ac AE01      		movw r20,r28
 597 01ae 4F5F      		subi r20,-1
 598 01b0 5F4F      		sbci r21,-1
 599 01b2 BE01      		movw r22,r28
 600 01b4 6E5F      		subi r22,-2
 601 01b6 7F4F      		sbci r23,-1
 602 01b8 8091 0000 		lds r24,xCharsForTx
 603 01bc 9091 0000 		lds r25,xCharsForTx+1
 604 01c0 0E94 0000 		call xQueueReceiveFromISR
 605 01c4 8130      		cpi r24,lo8(1)
 606 01c6 01F4      		brne .L15
 212:serial/serial.c **** 	{
 213:serial/serial.c **** 		/* Send the next character queued for Tx. */
 214:serial/serial.c **** 		UDR0 = cChar;
 608               	.LM37:
 609 01c8 8A81      		ldd r24,Y+2
 610 01ca 8093 C600 		sts 198,r24
 611 01ce 00C0      		rjmp .L14
 612               	.L15:
 613               	.LBB4:
 215:serial/serial.c **** 	}
 216:serial/serial.c **** 	else
 217:serial/serial.c **** 	{
 218:serial/serial.c **** 		/* Queue empty, nothing to send. */
 219:serial/serial.c **** 		vInterruptOff();
 615               	.LM38:
 616 01d0 8091 C100 		lds r24,193
 617 01d4 8F7D      		andi r24,lo8(-33)
 618 01d6 8093 C100 		sts 193,r24
 619               	.L14:
 620               	/* epilogue start */
 621               	.LBE4:
 220:serial/serial.c **** 	}
 221:serial/serial.c **** }
 623               	.LM39:
 624 01da 0F90      		pop __tmp_reg__
 625 01dc 0F90      		pop __tmp_reg__
 626 01de DF91      		pop r29
 627 01e0 CF91      		pop r28
 628 01e2 FF91      		pop r31
 629 01e4 EF91      		pop r30
 630 01e6 BF91      		pop r27
 631 01e8 AF91      		pop r26
 632 01ea 9F91      		pop r25
 633 01ec 8F91      		pop r24
 634 01ee 7F91      		pop r23
 635 01f0 6F91      		pop r22
 636 01f2 5F91      		pop r21
 637 01f4 4F91      		pop r20
 638 01f6 3F91      		pop r19
 639 01f8 2F91      		pop r18
 640 01fa 0F90      		pop r0
 641 01fc 0FBE      		out __SREG__,r0
 642 01fe 0F90      		pop r0
 643 0200 1F90      		pop r1
 644 0202 1895      		reti
 650               	.Lscope6:
 652               		.stabd	78,0,0
 653               		.local	xCharsForTx
 654               		.comm	xCharsForTx,2,1
 655               		.local	xRxedChars
 656               		.comm	xRxedChars,2,1
 660               	.Letext0:
 661               		.ident	"GCC: (GNU) 5.4.0"
 662               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 serial.c
     /tmp/ccdMX2CY.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccdMX2CY.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccdMX2CY.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccdMX2CY.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccdMX2CY.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccdMX2CY.s:204    .text:0000000000000000 xSerialPortInitMinimal
     /tmp/ccdMX2CY.s:654    .bss:0000000000000002 xRxedChars
                             .bss:0000000000000000 xCharsForTx
     /tmp/ccdMX2CY.s:323    .text:0000000000000092 xSerialGetChar
     /tmp/ccdMX2CY.s:356    .text:00000000000000aa xSerialPutChar
     /tmp/ccdMX2CY.s:412    .text:00000000000000e4 vSerialClose
     /tmp/ccdMX2CY.s:470    .text:0000000000000100 SIG_UART_RECV
     /tmp/ccdMX2CY.s:563    .text:0000000000000180 SIG_UART_DATA

UNDEFINED SYMBOLS
xQueueGenericCreate
__udivmodsi4
xQueueReceive
xQueueGenericSend
xQueueGenericSendFromISR
vPortYield
xQueueReceiveFromISR
__do_clear_bss
