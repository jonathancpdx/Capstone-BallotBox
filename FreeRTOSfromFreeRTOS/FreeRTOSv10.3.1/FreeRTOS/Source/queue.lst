   1               		.file	"queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 202               	prvIsQueueEmpty:
 203               		.stabd	46,0,0
   1:../../Source/queue.c **** /*
   2:../../Source/queue.c ****  * FreeRTOS Kernel V10.3.1
   3:../../Source/queue.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../../Source/queue.c ****  *
   5:../../Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../../Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../../Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:../../Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../../Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../../Source/queue.c ****  * subject to the following conditions:
  11:../../Source/queue.c ****  *
  12:../../Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../../Source/queue.c ****  * copies or substantial portions of the Software.
  14:../../Source/queue.c ****  *
  15:../../Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../../Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../../Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../../Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../../Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../../Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../../Source/queue.c ****  *
  22:../../Source/queue.c ****  * http://www.FreeRTOS.org
  23:../../Source/queue.c ****  * http://aws.amazon.com/freertos
  24:../../Source/queue.c ****  *
  25:../../Source/queue.c ****  * 1 tab == 4 spaces!
  26:../../Source/queue.c ****  */
  27:../../Source/queue.c **** 
  28:../../Source/queue.c **** #include <stdlib.h>
  29:../../Source/queue.c **** #include <string.h>
  30:../../Source/queue.c **** 
  31:../../Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:../../Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:../../Source/queue.c **** task.h is included from an application file. */
  34:../../Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:../../Source/queue.c **** 
  36:../../Source/queue.c **** #include "FreeRTOS.h"
  37:../../Source/queue.c **** #include "task.h"
  38:../../Source/queue.c **** #include "queue.h"
  39:../../Source/queue.c **** 
  40:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:../../Source/queue.c **** 	#include "croutine.h"
  42:../../Source/queue.c **** #endif
  43:../../Source/queue.c **** 
  44:../../Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:../../Source/queue.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:../../Source/queue.c **** for the header files above, but not in this file, in order to generate the
  47:../../Source/queue.c **** correct privileged Vs unprivileged linkage and placement. */
  48:../../Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:../../Source/queue.c **** 
  50:../../Source/queue.c **** 
  51:../../Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:../../Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:../../Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:../../Source/queue.c **** 
  55:../../Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:../../Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:../../Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:../../Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:../../Source/queue.c **** structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:../../Source/queue.c **** names to the pcHead and structure member to ensure the readability of the code
  61:../../Source/queue.c **** is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:../../Source/queue.c **** a union as their usage is mutually exclusive dependent on what the queue is
  63:../../Source/queue.c **** being used for. */
  64:../../Source/queue.c **** #define uxQueueType						pcHead
  65:../../Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  66:../../Source/queue.c **** 
  67:../../Source/queue.c **** typedef struct QueuePointers
  68:../../Source/queue.c **** {
  69:../../Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  70:../../Source/queue.c **** 	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the stru
  71:../../Source/queue.c **** } QueuePointers_t;
  72:../../Source/queue.c **** 
  73:../../Source/queue.c **** typedef struct SemaphoreData
  74:../../Source/queue.c **** {
  75:../../Source/queue.c **** 	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
  76:../../Source/queue.c **** 	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex ha
  77:../../Source/queue.c **** } SemaphoreData_t;
  78:../../Source/queue.c **** 
  79:../../Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:../../Source/queue.c **** zero. */
  81:../../Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  82:../../Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  83:../../Source/queue.c **** 
  84:../../Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
  85:../../Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  86:../../Source/queue.c **** 	performed just because a higher priority task has been woken. */
  87:../../Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  88:../../Source/queue.c **** #else
  89:../../Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  90:../../Source/queue.c **** #endif
  91:../../Source/queue.c **** 
  92:../../Source/queue.c **** /*
  93:../../Source/queue.c ****  * Definition of the queue used by the scheduler.
  94:../../Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  95:../../Source/queue.c ****  * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
  96:../../Source/queue.c ****  */
  97:../../Source/queue.c **** typedef struct QueueDefinition 		/* The old naming convention is used to prevent breaking kernel aw
  98:../../Source/queue.c **** {
  99:../../Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 100:../../Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 101:../../Source/queue.c **** 
 102:../../Source/queue.c **** 	union
 103:../../Source/queue.c **** 	{
 104:../../Source/queue.c **** 		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
 105:../../Source/queue.c **** 		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaph
 106:../../Source/queue.c **** 	} u;
 107:../../Source/queue.c **** 
 108:../../Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 109:../../Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 110:../../Source/queue.c **** 
 111:../../Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 112:../../Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 113:../../Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 114:../../Source/queue.c **** 
 115:../../Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 116:../../Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 117:../../Source/queue.c **** 
 118:../../Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 119:../../Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 120:../../Source/queue.c **** 	#endif
 121:../../Source/queue.c **** 
 122:../../Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 123:../../Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 124:../../Source/queue.c **** 	#endif
 125:../../Source/queue.c **** 
 126:../../Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:../../Source/queue.c **** 		UBaseType_t uxQueueNumber;
 128:../../Source/queue.c **** 		uint8_t ucQueueType;
 129:../../Source/queue.c **** 	#endif
 130:../../Source/queue.c **** 
 131:../../Source/queue.c **** } xQUEUE;
 132:../../Source/queue.c **** 
 133:../../Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:../../Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 135:../../Source/queue.c **** typedef xQUEUE Queue_t;
 136:../../Source/queue.c **** 
 137:../../Source/queue.c **** /*-----------------------------------------------------------*/
 138:../../Source/queue.c **** 
 139:../../Source/queue.c **** /*
 140:../../Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:../../Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:../../Source/queue.c ****  */
 143:../../Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:../../Source/queue.c **** 
 145:../../Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 146:../../Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 147:../../Source/queue.c **** 	more user friendly. */
 148:../../Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 149:../../Source/queue.c **** 	{
 150:../../Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 151:../../Source/queue.c **** 		QueueHandle_t xHandle;
 152:../../Source/queue.c **** 	} xQueueRegistryItem;
 153:../../Source/queue.c **** 
 154:../../Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:../../Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 156:../../Source/queue.c **** 	debuggers. */
 157:../../Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 158:../../Source/queue.c **** 
 159:../../Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:../../Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 161:../../Source/queue.c **** 	array position being vacant. */
 162:../../Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:../../Source/queue.c **** 
 164:../../Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:../../Source/queue.c **** 
 166:../../Source/queue.c **** /*
 167:../../Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:../../Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:../../Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:../../Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:../../Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:../../Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:../../Source/queue.c ****  */
 174:../../Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:../../Source/queue.c **** 
 176:../../Source/queue.c **** /*
 177:../../Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:../../Source/queue.c ****  *
 179:../../Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:../../Source/queue.c ****  */
 181:../../Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 182:../../Source/queue.c **** 
 183:../../Source/queue.c **** /*
 184:../../Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:../../Source/queue.c ****  *
 186:../../Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:../../Source/queue.c ****  */
 188:../../Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 189:../../Source/queue.c **** 
 190:../../Source/queue.c **** /*
 191:../../Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:../../Source/queue.c ****  * back of the queue.
 193:../../Source/queue.c ****  */
 194:../../Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 195:../../Source/queue.c **** 
 196:../../Source/queue.c **** /*
 197:../../Source/queue.c ****  * Copies an item out of a queue.
 198:../../Source/queue.c ****  */
 199:../../Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 200:../../Source/queue.c **** 
 201:../../Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 202:../../Source/queue.c **** 	/*
 203:../../Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 204:../../Source/queue.c **** 	 * the queue set that the queue contains data.
 205:../../Source/queue.c **** 	 */
 206:../../Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 207:../../Source/queue.c **** #endif
 208:../../Source/queue.c **** 
 209:../../Source/queue.c **** /*
 210:../../Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 211:../../Source/queue.c ****  * dynamically to fill in the structure's members.
 212:../../Source/queue.c ****  */
 213:../../Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 214:../../Source/queue.c **** 
 215:../../Source/queue.c **** /*
 216:../../Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 217:../../Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 218:../../Source/queue.c ****  * as a mutex.
 219:../../Source/queue.c ****  */
 220:../../Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 221:../../Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 222:../../Source/queue.c **** #endif
 223:../../Source/queue.c **** 
 224:../../Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 225:../../Source/queue.c **** 	/*
 226:../../Source/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 227:../../Source/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 228:../../Source/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 229:../../Source/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 230:../../Source/queue.c **** 	 * that priority.
 231:../../Source/queue.c **** 	 */
 232:../../Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 233:../../Source/queue.c **** #endif
 234:../../Source/queue.c **** /*-----------------------------------------------------------*/
 235:../../Source/queue.c **** 
 236:../../Source/queue.c **** /*
 237:../../Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:../../Source/queue.c ****  * accessing the queue event lists.
 239:../../Source/queue.c ****  */
 240:../../Source/queue.c **** #define prvLockQueue( pxQueue )								\
 241:../../Source/queue.c **** 	taskENTER_CRITICAL();									\
 242:../../Source/queue.c **** 	{														\
 243:../../Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 244:../../Source/queue.c **** 		{													\
 245:../../Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 246:../../Source/queue.c **** 		}													\
 247:../../Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 248:../../Source/queue.c **** 		{													\
 249:../../Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 250:../../Source/queue.c **** 		}													\
 251:../../Source/queue.c **** 	}														\
 252:../../Source/queue.c **** 	taskEXIT_CRITICAL()
 253:../../Source/queue.c **** /*-----------------------------------------------------------*/
 254:../../Source/queue.c **** 
 255:../../Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:../../Source/queue.c **** {
 257:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
 258:../../Source/queue.c **** 
 259:../../Source/queue.c **** 	configASSERT( pxQueue );
 260:../../Source/queue.c **** 
 261:../../Source/queue.c **** 	taskENTER_CRITICAL();
 262:../../Source/queue.c **** 	{
 263:../../Source/queue.c **** 		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint 
 264:../../Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 265:../../Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 266:../../Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
 267:../../Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 268:../../Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 269:../../Source/queue.c **** 
 270:../../Source/queue.c **** 		if( xNewQueue == pdFALSE )
 271:../../Source/queue.c **** 		{
 272:../../Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:../../Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:../../Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:../../Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:../../Source/queue.c **** 			it will be possible to write to it. */
 277:../../Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 278:../../Source/queue.c **** 			{
 279:../../Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 280:../../Source/queue.c **** 				{
 281:../../Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 282:../../Source/queue.c **** 				}
 283:../../Source/queue.c **** 				else
 284:../../Source/queue.c **** 				{
 285:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:../../Source/queue.c **** 				}
 287:../../Source/queue.c **** 			}
 288:../../Source/queue.c **** 			else
 289:../../Source/queue.c **** 			{
 290:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:../../Source/queue.c **** 			}
 292:../../Source/queue.c **** 		}
 293:../../Source/queue.c **** 		else
 294:../../Source/queue.c **** 		{
 295:../../Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:../../Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 297:../../Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 298:../../Source/queue.c **** 		}
 299:../../Source/queue.c **** 	}
 300:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 301:../../Source/queue.c **** 
 302:../../Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:../../Source/queue.c **** 	versions. */
 304:../../Source/queue.c **** 	return pdPASS;
 305:../../Source/queue.c **** }
 306:../../Source/queue.c **** /*-----------------------------------------------------------*/
 307:../../Source/queue.c **** 
 308:../../Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 309:../../Source/queue.c **** 
 310:../../Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 311:../../Source/queue.c **** 	{
 312:../../Source/queue.c **** 	Queue_t *pxNewQueue;
 313:../../Source/queue.c **** 
 314:../../Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 315:../../Source/queue.c **** 
 316:../../Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 317:../../Source/queue.c **** 		supplied. */
 318:../../Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 319:../../Source/queue.c **** 
 320:../../Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 321:../../Source/queue.c **** 		should not be provided if the item size is 0. */
 322:../../Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 323:../../Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 324:../../Source/queue.c **** 
 325:../../Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 326:../../Source/queue.c **** 		{
 327:../../Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 328:../../Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 329:../../Source/queue.c **** 			the real queue and semaphore structures. */
 330:../../Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 331:../../Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 332:../../Source/queue.c **** 			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 333:../../Source/queue.c **** 		}
 334:../../Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 335:../../Source/queue.c **** 
 336:../../Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 337:../../Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 338:../../Source/queue.c **** 		but is already set. */
 339:../../Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structure
 340:../../Source/queue.c **** 
 341:../../Source/queue.c **** 		if( pxNewQueue != NULL )
 342:../../Source/queue.c **** 		{
 343:../../Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 344:../../Source/queue.c **** 			{
 345:../../Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 346:../../Source/queue.c **** 				note this queue was allocated statically in case the queue is
 347:../../Source/queue.c **** 				later deleted. */
 348:../../Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 349:../../Source/queue.c **** 			}
 350:../../Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 351:../../Source/queue.c **** 
 352:../../Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 353:../../Source/queue.c **** 		}
 354:../../Source/queue.c **** 		else
 355:../../Source/queue.c **** 		{
 356:../../Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 357:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 358:../../Source/queue.c **** 		}
 359:../../Source/queue.c **** 
 360:../../Source/queue.c **** 		return pxNewQueue;
 361:../../Source/queue.c **** 	}
 362:../../Source/queue.c **** 
 363:../../Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 364:../../Source/queue.c **** /*-----------------------------------------------------------*/
 365:../../Source/queue.c **** 
 366:../../Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:../../Source/queue.c **** 
 368:../../Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 369:../../Source/queue.c **** 	{
 370:../../Source/queue.c **** 	Queue_t *pxNewQueue;
 371:../../Source/queue.c **** 	size_t xQueueSizeInBytes;
 372:../../Source/queue.c **** 	uint8_t *pucQueueStorage;
 373:../../Source/queue.c **** 
 374:../../Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 375:../../Source/queue.c **** 
 376:../../Source/queue.c **** 		/* Allocate enough space to hold the maximum number of items that
 377:../../Source/queue.c **** 		can be in the queue at any time.  It is valid for uxItemSize to be
 378:../../Source/queue.c **** 		zero in the case the queue is used as a semaphore. */
 379:../../Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as th
 380:../../Source/queue.c **** 
 381:../../Source/queue.c **** 		/* Allocate the queue and storage area.  Justification for MISRA
 382:../../Source/queue.c **** 		deviation as follows:  pvPortMalloc() always ensures returned memory
 383:../../Source/queue.c **** 		blocks are aligned per the requirements of the MCU stack.  In this case
 384:../../Source/queue.c **** 		pvPortMalloc() must return a pointer that is guaranteed to meet the
 385:../../Source/queue.c **** 		alignment requirements of the Queue_t structure - which in this case
 386:../../Source/queue.c **** 		is an int8_t *.  Therefore, whenever the stack alignment requirements
 387:../../Source/queue.c **** 		are greater than or equal to the pointer to char requirements the cast
 388:../../Source/queue.c **** 		is safe.  In other cases alignment requirements are not strict (one or
 389:../../Source/queue.c **** 		two bytes). */
 390:../../Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !
 391:../../Source/queue.c **** 
 392:../../Source/queue.c **** 		if( pxNewQueue != NULL )
 393:../../Source/queue.c **** 		{
 394:../../Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 395:../../Source/queue.c **** 			storage area. */
 396:../../Source/queue.c **** 			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 397:../../Source/queue.c **** 			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, es
 398:../../Source/queue.c **** 
 399:../../Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 400:../../Source/queue.c **** 			{
 401:../../Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 402:../../Source/queue.c **** 				note this task was created dynamically in case it is later
 403:../../Source/queue.c **** 				deleted. */
 404:../../Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 405:../../Source/queue.c **** 			}
 406:../../Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 407:../../Source/queue.c **** 
 408:../../Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 409:../../Source/queue.c **** 		}
 410:../../Source/queue.c **** 		else
 411:../../Source/queue.c **** 		{
 412:../../Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 413:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 414:../../Source/queue.c **** 		}
 415:../../Source/queue.c **** 
 416:../../Source/queue.c **** 		return pxNewQueue;
 417:../../Source/queue.c **** 	}
 418:../../Source/queue.c **** 
 419:../../Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 420:../../Source/queue.c **** /*-----------------------------------------------------------*/
 421:../../Source/queue.c **** 
 422:../../Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 423:../../Source/queue.c **** {
 424:../../Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 425:../../Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 426:../../Source/queue.c **** 	( void ) ucQueueType;
 427:../../Source/queue.c **** 
 428:../../Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 429:../../Source/queue.c **** 	{
 430:../../Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 431:../../Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 432:../../Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 433:../../Source/queue.c **** 		value that is known to be within the memory map. */
 434:../../Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 435:../../Source/queue.c **** 	}
 436:../../Source/queue.c **** 	else
 437:../../Source/queue.c **** 	{
 438:../../Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 439:../../Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 440:../../Source/queue.c **** 	}
 441:../../Source/queue.c **** 
 442:../../Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 443:../../Source/queue.c **** 	defined. */
 444:../../Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 445:../../Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 446:../../Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 447:../../Source/queue.c **** 
 448:../../Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 449:../../Source/queue.c **** 	{
 450:../../Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 451:../../Source/queue.c **** 	}
 452:../../Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 453:../../Source/queue.c **** 
 454:../../Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 455:../../Source/queue.c **** 	{
 456:../../Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 457:../../Source/queue.c **** 	}
 458:../../Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 459:../../Source/queue.c **** 
 460:../../Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 461:../../Source/queue.c **** }
 462:../../Source/queue.c **** /*-----------------------------------------------------------*/
 463:../../Source/queue.c **** 
 464:../../Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 465:../../Source/queue.c **** 
 466:../../Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 467:../../Source/queue.c **** 	{
 468:../../Source/queue.c **** 		if( pxNewQueue != NULL )
 469:../../Source/queue.c **** 		{
 470:../../Source/queue.c **** 			/* The queue create function will set all the queue structure members
 471:../../Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 472:../../Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 473:../../Source/queue.c **** 			in particular the information required for priority inheritance. */
 474:../../Source/queue.c **** 			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 475:../../Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 476:../../Source/queue.c **** 
 477:../../Source/queue.c **** 			/* In case this is a recursive mutex. */
 478:../../Source/queue.c **** 			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 479:../../Source/queue.c **** 
 480:../../Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 481:../../Source/queue.c **** 
 482:../../Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 483:../../Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 484:../../Source/queue.c **** 		}
 485:../../Source/queue.c **** 		else
 486:../../Source/queue.c **** 		{
 487:../../Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 488:../../Source/queue.c **** 		}
 489:../../Source/queue.c **** 	}
 490:../../Source/queue.c **** 
 491:../../Source/queue.c **** #endif /* configUSE_MUTEXES */
 492:../../Source/queue.c **** /*-----------------------------------------------------------*/
 493:../../Source/queue.c **** 
 494:../../Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 495:../../Source/queue.c **** 
 496:../../Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 497:../../Source/queue.c **** 	{
 498:../../Source/queue.c **** 	QueueHandle_t xNewQueue;
 499:../../Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 500:../../Source/queue.c **** 
 501:../../Source/queue.c **** 		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 502:../../Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 503:../../Source/queue.c **** 
 504:../../Source/queue.c **** 		return xNewQueue;
 505:../../Source/queue.c **** 	}
 506:../../Source/queue.c **** 
 507:../../Source/queue.c **** #endif /* configUSE_MUTEXES */
 508:../../Source/queue.c **** /*-----------------------------------------------------------*/
 509:../../Source/queue.c **** 
 510:../../Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 511:../../Source/queue.c **** 
 512:../../Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 513:../../Source/queue.c **** 	{
 514:../../Source/queue.c **** 	QueueHandle_t xNewQueue;
 515:../../Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 516:../../Source/queue.c **** 
 517:../../Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 518:../../Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 519:../../Source/queue.c **** 		( void ) ucQueueType;
 520:../../Source/queue.c **** 
 521:../../Source/queue.c **** 		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueTy
 522:../../Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 523:../../Source/queue.c **** 
 524:../../Source/queue.c **** 		return xNewQueue;
 525:../../Source/queue.c **** 	}
 526:../../Source/queue.c **** 
 527:../../Source/queue.c **** #endif /* configUSE_MUTEXES */
 528:../../Source/queue.c **** /*-----------------------------------------------------------*/
 529:../../Source/queue.c **** 
 530:../../Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 531:../../Source/queue.c **** 
 532:../../Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 533:../../Source/queue.c **** 	{
 534:../../Source/queue.c **** 	TaskHandle_t pxReturn;
 535:../../Source/queue.c **** 	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 536:../../Source/queue.c **** 
 537:../../Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 538:../../Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 539:../../Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 540:../../Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 541:../../Source/queue.c **** 		following critical section exiting and the function returning. */
 542:../../Source/queue.c **** 		taskENTER_CRITICAL();
 543:../../Source/queue.c **** 		{
 544:../../Source/queue.c **** 			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 545:../../Source/queue.c **** 			{
 546:../../Source/queue.c **** 				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 547:../../Source/queue.c **** 			}
 548:../../Source/queue.c **** 			else
 549:../../Source/queue.c **** 			{
 550:../../Source/queue.c **** 				pxReturn = NULL;
 551:../../Source/queue.c **** 			}
 552:../../Source/queue.c **** 		}
 553:../../Source/queue.c **** 		taskEXIT_CRITICAL();
 554:../../Source/queue.c **** 
 555:../../Source/queue.c **** 		return pxReturn;
 556:../../Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 557:../../Source/queue.c **** 
 558:../../Source/queue.c **** #endif
 559:../../Source/queue.c **** /*-----------------------------------------------------------*/
 560:../../Source/queue.c **** 
 561:../../Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 562:../../Source/queue.c **** 
 563:../../Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 564:../../Source/queue.c **** 	{
 565:../../Source/queue.c **** 	TaskHandle_t pxReturn;
 566:../../Source/queue.c **** 
 567:../../Source/queue.c **** 		configASSERT( xSemaphore );
 568:../../Source/queue.c **** 
 569:../../Source/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 570:../../Source/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 571:../../Source/queue.c **** 		not required here. */
 572:../../Source/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 573:../../Source/queue.c **** 		{
 574:../../Source/queue.c **** 			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 575:../../Source/queue.c **** 		}
 576:../../Source/queue.c **** 		else
 577:../../Source/queue.c **** 		{
 578:../../Source/queue.c **** 			pxReturn = NULL;
 579:../../Source/queue.c **** 		}
 580:../../Source/queue.c **** 
 581:../../Source/queue.c **** 		return pxReturn;
 582:../../Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 583:../../Source/queue.c **** 
 584:../../Source/queue.c **** #endif
 585:../../Source/queue.c **** /*-----------------------------------------------------------*/
 586:../../Source/queue.c **** 
 587:../../Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 588:../../Source/queue.c **** 
 589:../../Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 590:../../Source/queue.c **** 	{
 591:../../Source/queue.c **** 	BaseType_t xReturn;
 592:../../Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 593:../../Source/queue.c **** 
 594:../../Source/queue.c **** 		configASSERT( pxMutex );
 595:../../Source/queue.c **** 
 596:../../Source/queue.c **** 		/* If this is the task that holds the mutex then xMutexHolder will not
 597:../../Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 598:../../Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 599:../../Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 600:../../Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 601:../../Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 602:../../Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 603:../../Source/queue.c **** 		{
 604:../../Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 605:../../Source/queue.c **** 
 606:../../Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 607:../../Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 608:../../Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 609:../../Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 610:../../Source/queue.c **** 			uxRecursiveCallCount member. */
 611:../../Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 612:../../Source/queue.c **** 
 613:../../Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 614:../../Source/queue.c **** 			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 615:../../Source/queue.c **** 			{
 616:../../Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 617:../../Source/queue.c **** 				task that might be waiting to access the mutex. */
 618:../../Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 619:../../Source/queue.c **** 			}
 620:../../Source/queue.c **** 			else
 621:../../Source/queue.c **** 			{
 622:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 623:../../Source/queue.c **** 			}
 624:../../Source/queue.c **** 
 625:../../Source/queue.c **** 			xReturn = pdPASS;
 626:../../Source/queue.c **** 		}
 627:../../Source/queue.c **** 		else
 628:../../Source/queue.c **** 		{
 629:../../Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 630:../../Source/queue.c **** 			holder. */
 631:../../Source/queue.c **** 			xReturn = pdFAIL;
 632:../../Source/queue.c **** 
 633:../../Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 634:../../Source/queue.c **** 		}
 635:../../Source/queue.c **** 
 636:../../Source/queue.c **** 		return xReturn;
 637:../../Source/queue.c **** 	}
 638:../../Source/queue.c **** 
 639:../../Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 640:../../Source/queue.c **** /*-----------------------------------------------------------*/
 641:../../Source/queue.c **** 
 642:../../Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 643:../../Source/queue.c **** 
 644:../../Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 645:../../Source/queue.c **** 	{
 646:../../Source/queue.c **** 	BaseType_t xReturn;
 647:../../Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 648:../../Source/queue.c **** 
 649:../../Source/queue.c **** 		configASSERT( pxMutex );
 650:../../Source/queue.c **** 
 651:../../Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 652:../../Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 653:../../Source/queue.c **** 
 654:../../Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 655:../../Source/queue.c **** 
 656:../../Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 657:../../Source/queue.c **** 		{
 658:../../Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 659:../../Source/queue.c **** 			xReturn = pdPASS;
 660:../../Source/queue.c **** 		}
 661:../../Source/queue.c **** 		else
 662:../../Source/queue.c **** 		{
 663:../../Source/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 664:../../Source/queue.c **** 
 665:../../Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 666:../../Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 667:../../Source/queue.c **** 			before reaching here. */
 668:../../Source/queue.c **** 			if( xReturn != pdFAIL )
 669:../../Source/queue.c **** 			{
 670:../../Source/queue.c **** 				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 671:../../Source/queue.c **** 			}
 672:../../Source/queue.c **** 			else
 673:../../Source/queue.c **** 			{
 674:../../Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 675:../../Source/queue.c **** 			}
 676:../../Source/queue.c **** 		}
 677:../../Source/queue.c **** 
 678:../../Source/queue.c **** 		return xReturn;
 679:../../Source/queue.c **** 	}
 680:../../Source/queue.c **** 
 681:../../Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 682:../../Source/queue.c **** /*-----------------------------------------------------------*/
 683:../../Source/queue.c **** 
 684:../../Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 685:../../Source/queue.c **** 
 686:../../Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 687:../../Source/queue.c **** 	{
 688:../../Source/queue.c **** 	QueueHandle_t xHandle;
 689:../../Source/queue.c **** 
 690:../../Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 691:../../Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 692:../../Source/queue.c **** 
 693:../../Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 694:../../Source/queue.c **** 
 695:../../Source/queue.c **** 		if( xHandle != NULL )
 696:../../Source/queue.c **** 		{
 697:../../Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 698:../../Source/queue.c **** 
 699:../../Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 700:../../Source/queue.c **** 		}
 701:../../Source/queue.c **** 		else
 702:../../Source/queue.c **** 		{
 703:../../Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 704:../../Source/queue.c **** 		}
 705:../../Source/queue.c **** 
 706:../../Source/queue.c **** 		return xHandle;
 707:../../Source/queue.c **** 	}
 708:../../Source/queue.c **** 
 709:../../Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 710:../../Source/queue.c **** /*-----------------------------------------------------------*/
 711:../../Source/queue.c **** 
 712:../../Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 713:../../Source/queue.c **** 
 714:../../Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 715:../../Source/queue.c **** 	{
 716:../../Source/queue.c **** 	QueueHandle_t xHandle;
 717:../../Source/queue.c **** 
 718:../../Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 719:../../Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 720:../../Source/queue.c **** 
 721:../../Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 722:../../Source/queue.c **** 
 723:../../Source/queue.c **** 		if( xHandle != NULL )
 724:../../Source/queue.c **** 		{
 725:../../Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 726:../../Source/queue.c **** 
 727:../../Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 728:../../Source/queue.c **** 		}
 729:../../Source/queue.c **** 		else
 730:../../Source/queue.c **** 		{
 731:../../Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 732:../../Source/queue.c **** 		}
 733:../../Source/queue.c **** 
 734:../../Source/queue.c **** 		return xHandle;
 735:../../Source/queue.c **** 	}
 736:../../Source/queue.c **** 
 737:../../Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 738:../../Source/queue.c **** /*-----------------------------------------------------------*/
 739:../../Source/queue.c **** 
 740:../../Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 741:../../Source/queue.c **** {
 742:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 743:../../Source/queue.c **** TimeOut_t xTimeOut;
 744:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
 745:../../Source/queue.c **** 
 746:../../Source/queue.c **** 	configASSERT( pxQueue );
 747:../../Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 748:../../Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 749:../../Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 750:../../Source/queue.c **** 	{
 751:../../Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 752:../../Source/queue.c **** 	}
 753:../../Source/queue.c **** 	#endif
 754:../../Source/queue.c **** 
 755:../../Source/queue.c **** 
 756:../../Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to
 757:../../Source/queue.c **** 	allow return statements within the function itself.  This is done in the
 758:../../Source/queue.c **** 	interest of execution time efficiency. */
 759:../../Source/queue.c **** 	for( ;; )
 760:../../Source/queue.c **** 	{
 761:../../Source/queue.c **** 		taskENTER_CRITICAL();
 762:../../Source/queue.c **** 		{
 763:../../Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 764:../../Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 765:../../Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 766:../../Source/queue.c **** 			queue is full. */
 767:../../Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 768:../../Source/queue.c **** 			{
 769:../../Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 770:../../Source/queue.c **** 
 771:../../Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 772:../../Source/queue.c **** 				{
 773:../../Source/queue.c **** 				const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 774:../../Source/queue.c **** 
 775:../../Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 776:../../Source/queue.c **** 
 777:../../Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 778:../../Source/queue.c **** 					{
 779:../../Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
 780:../../Source/queue.c **** 						{
 781:../../Source/queue.c **** 							/* Do not notify the queue set as an existing item
 782:../../Source/queue.c **** 							was overwritten in the queue so the number of items
 783:../../Source/queue.c **** 							in the queue has not changed. */
 784:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 785:../../Source/queue.c **** 						}
 786:../../Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 787:../../Source/queue.c **** 						{
 788:../../Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 789:../../Source/queue.c **** 							to the queue set caused a higher priority task to
 790:../../Source/queue.c **** 							unblock. A context switch is required. */
 791:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 792:../../Source/queue.c **** 						}
 793:../../Source/queue.c **** 						else
 794:../../Source/queue.c **** 						{
 795:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 796:../../Source/queue.c **** 						}
 797:../../Source/queue.c **** 					}
 798:../../Source/queue.c **** 					else
 799:../../Source/queue.c **** 					{
 800:../../Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 801:../../Source/queue.c **** 						queue then unblock it now. */
 802:../../Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 803:../../Source/queue.c **** 						{
 804:../../Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 805:../../Source/queue.c **** 							{
 806:../../Source/queue.c **** 								/* The unblocked task has a priority higher than
 807:../../Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 808:../../Source/queue.c **** 								do this from within the critical section - the
 809:../../Source/queue.c **** 								kernel takes care of that. */
 810:../../Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 811:../../Source/queue.c **** 							}
 812:../../Source/queue.c **** 							else
 813:../../Source/queue.c **** 							{
 814:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 815:../../Source/queue.c **** 							}
 816:../../Source/queue.c **** 						}
 817:../../Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 818:../../Source/queue.c **** 						{
 819:../../Source/queue.c **** 							/* This path is a special case that will only get
 820:../../Source/queue.c **** 							executed if the task was holding multiple mutexes
 821:../../Source/queue.c **** 							and the mutexes were given back in an order that is
 822:../../Source/queue.c **** 							different to that in which they were taken. */
 823:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 824:../../Source/queue.c **** 						}
 825:../../Source/queue.c **** 						else
 826:../../Source/queue.c **** 						{
 827:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 828:../../Source/queue.c **** 						}
 829:../../Source/queue.c **** 					}
 830:../../Source/queue.c **** 				}
 831:../../Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 832:../../Source/queue.c **** 				{
 833:../../Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 834:../../Source/queue.c **** 
 835:../../Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 836:../../Source/queue.c **** 					queue then unblock it now. */
 837:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 838:../../Source/queue.c **** 					{
 839:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 840:../../Source/queue.c **** 						{
 841:../../Source/queue.c **** 							/* The unblocked task has a priority higher than
 842:../../Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 843:../../Source/queue.c **** 							this from within the critical section - the kernel
 844:../../Source/queue.c **** 							takes care of that. */
 845:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 846:../../Source/queue.c **** 						}
 847:../../Source/queue.c **** 						else
 848:../../Source/queue.c **** 						{
 849:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 850:../../Source/queue.c **** 						}
 851:../../Source/queue.c **** 					}
 852:../../Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 853:../../Source/queue.c **** 					{
 854:../../Source/queue.c **** 						/* This path is a special case that will only get
 855:../../Source/queue.c **** 						executed if the task was holding multiple mutexes and
 856:../../Source/queue.c **** 						the mutexes were given back in an order that is
 857:../../Source/queue.c **** 						different to that in which they were taken. */
 858:../../Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 859:../../Source/queue.c **** 					}
 860:../../Source/queue.c **** 					else
 861:../../Source/queue.c **** 					{
 862:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 863:../../Source/queue.c **** 					}
 864:../../Source/queue.c **** 				}
 865:../../Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 866:../../Source/queue.c **** 
 867:../../Source/queue.c **** 				taskEXIT_CRITICAL();
 868:../../Source/queue.c **** 				return pdPASS;
 869:../../Source/queue.c **** 			}
 870:../../Source/queue.c **** 			else
 871:../../Source/queue.c **** 			{
 872:../../Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 873:../../Source/queue.c **** 				{
 874:../../Source/queue.c **** 					/* The queue was full and no block time is specified (or
 875:../../Source/queue.c **** 					the block time has expired) so leave now. */
 876:../../Source/queue.c **** 					taskEXIT_CRITICAL();
 877:../../Source/queue.c **** 
 878:../../Source/queue.c **** 					/* Return to the original privilege level before exiting
 879:../../Source/queue.c **** 					the function. */
 880:../../Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 881:../../Source/queue.c **** 					return errQUEUE_FULL;
 882:../../Source/queue.c **** 				}
 883:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 884:../../Source/queue.c **** 				{
 885:../../Source/queue.c **** 					/* The queue was full and a block time was specified so
 886:../../Source/queue.c **** 					configure the timeout structure. */
 887:../../Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 888:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 889:../../Source/queue.c **** 				}
 890:../../Source/queue.c **** 				else
 891:../../Source/queue.c **** 				{
 892:../../Source/queue.c **** 					/* Entry time was already set. */
 893:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 894:../../Source/queue.c **** 				}
 895:../../Source/queue.c **** 			}
 896:../../Source/queue.c **** 		}
 897:../../Source/queue.c **** 		taskEXIT_CRITICAL();
 898:../../Source/queue.c **** 
 899:../../Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 900:../../Source/queue.c **** 		now the critical section has been exited. */
 901:../../Source/queue.c **** 
 902:../../Source/queue.c **** 		vTaskSuspendAll();
 903:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 904:../../Source/queue.c **** 
 905:../../Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 906:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 907:../../Source/queue.c **** 		{
 908:../../Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 909:../../Source/queue.c **** 			{
 910:../../Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 911:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 912:../../Source/queue.c **** 
 913:../../Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 914:../../Source/queue.c **** 				event list.  It is possible that interrupts occurring now
 915:../../Source/queue.c **** 				remove this task from the event list again - but as the
 916:../../Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 917:../../Source/queue.c **** 				ready last instead of the actual ready list. */
 918:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 919:../../Source/queue.c **** 
 920:../../Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 921:../../Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 922:../../Source/queue.c **** 				task is already in a ready list before it yields - in which
 923:../../Source/queue.c **** 				case the yield will not cause a context switch unless there
 924:../../Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 925:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 926:../../Source/queue.c **** 				{
 927:../../Source/queue.c **** 					portYIELD_WITHIN_API();
 928:../../Source/queue.c **** 				}
 929:../../Source/queue.c **** 			}
 930:../../Source/queue.c **** 			else
 931:../../Source/queue.c **** 			{
 932:../../Source/queue.c **** 				/* Try again. */
 933:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 934:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 935:../../Source/queue.c **** 			}
 936:../../Source/queue.c **** 		}
 937:../../Source/queue.c **** 		else
 938:../../Source/queue.c **** 		{
 939:../../Source/queue.c **** 			/* The timeout has expired. */
 940:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
 941:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 942:../../Source/queue.c **** 
 943:../../Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 944:../../Source/queue.c **** 			return errQUEUE_FULL;
 945:../../Source/queue.c **** 		}
 946:../../Source/queue.c **** 	} /*lint -restore */
 947:../../Source/queue.c **** }
 948:../../Source/queue.c **** /*-----------------------------------------------------------*/
 949:../../Source/queue.c **** 
 950:../../Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 951:../../Source/queue.c **** {
 952:../../Source/queue.c **** BaseType_t xReturn;
 953:../../Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 954:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
 955:../../Source/queue.c **** 
 956:../../Source/queue.c **** 	configASSERT( pxQueue );
 957:../../Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 958:../../Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 959:../../Source/queue.c **** 
 960:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 961:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 962:../../Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 963:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 964:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 965:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 966:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 967:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 968:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 969:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 970:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 971:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 972:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 973:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 974:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 975:../../Source/queue.c **** 
 976:../../Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 977:../../Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 978:../../Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 979:../../Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 980:../../Source/queue.c **** 	post). */
 981:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 982:../../Source/queue.c **** 	{
 983:../../Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 984:../../Source/queue.c **** 		{
 985:../../Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 986:../../Source/queue.c **** 			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 987:../../Source/queue.c **** 
 988:../../Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 989:../../Source/queue.c **** 
 990:../../Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 991:../../Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 992:../../Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 993:../../Source/queue.c **** 			called here even though the disinherit function does not check if
 994:../../Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 995:../../Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 996:../../Source/queue.c **** 
 997:../../Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 998:../../Source/queue.c **** 			be done when the queue is unlocked later. */
 999:../../Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1000:../../Source/queue.c **** 			{
1001:../../Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1002:../../Source/queue.c **** 				{
1003:../../Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1004:../../Source/queue.c **** 					{
1005:../../Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
1006:../../Source/queue.c **** 						{
1007:../../Source/queue.c **** 							/* Do not notify the queue set as an existing item
1008:../../Source/queue.c **** 							was overwritten in the queue so the number of items
1009:../../Source/queue.c **** 							in the queue has not changed. */
1010:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1011:../../Source/queue.c **** 						}
1012:../../Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1013:../../Source/queue.c **** 						{
1014:../../Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1015:../../Source/queue.c **** 							to the queue set caused a higher priority task to
1016:../../Source/queue.c **** 							unblock.  A context switch is required. */
1017:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1018:../../Source/queue.c **** 							{
1019:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1020:../../Source/queue.c **** 							}
1021:../../Source/queue.c **** 							else
1022:../../Source/queue.c **** 							{
1023:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1024:../../Source/queue.c **** 							}
1025:../../Source/queue.c **** 						}
1026:../../Source/queue.c **** 						else
1027:../../Source/queue.c **** 						{
1028:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1029:../../Source/queue.c **** 						}
1030:../../Source/queue.c **** 					}
1031:../../Source/queue.c **** 					else
1032:../../Source/queue.c **** 					{
1033:../../Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1034:../../Source/queue.c **** 						{
1035:../../Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1036:../../Source/queue.c **** 							{
1037:../../Source/queue.c **** 								/* The task waiting has a higher priority so
1038:../../Source/queue.c **** 								record that a context switch is required. */
1039:../../Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1040:../../Source/queue.c **** 								{
1041:../../Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1042:../../Source/queue.c **** 								}
1043:../../Source/queue.c **** 								else
1044:../../Source/queue.c **** 								{
1045:../../Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1046:../../Source/queue.c **** 								}
1047:../../Source/queue.c **** 							}
1048:../../Source/queue.c **** 							else
1049:../../Source/queue.c **** 							{
1050:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1051:../../Source/queue.c **** 							}
1052:../../Source/queue.c **** 						}
1053:../../Source/queue.c **** 						else
1054:../../Source/queue.c **** 						{
1055:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1056:../../Source/queue.c **** 						}
1057:../../Source/queue.c **** 					}
1058:../../Source/queue.c **** 				}
1059:../../Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1060:../../Source/queue.c **** 				{
1061:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1062:../../Source/queue.c **** 					{
1063:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1064:../../Source/queue.c **** 						{
1065:../../Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1066:../../Source/queue.c **** 							context	switch is required. */
1067:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1068:../../Source/queue.c **** 							{
1069:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1070:../../Source/queue.c **** 							}
1071:../../Source/queue.c **** 							else
1072:../../Source/queue.c **** 							{
1073:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1074:../../Source/queue.c **** 							}
1075:../../Source/queue.c **** 						}
1076:../../Source/queue.c **** 						else
1077:../../Source/queue.c **** 						{
1078:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1079:../../Source/queue.c **** 						}
1080:../../Source/queue.c **** 					}
1081:../../Source/queue.c **** 					else
1082:../../Source/queue.c **** 					{
1083:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1084:../../Source/queue.c **** 					}
1085:../../Source/queue.c **** 					
1086:../../Source/queue.c **** 					/* Not used in this path. */
1087:../../Source/queue.c **** 					( void ) uxPreviousMessagesWaiting;
1088:../../Source/queue.c **** 				}
1089:../../Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1090:../../Source/queue.c **** 			}
1091:../../Source/queue.c **** 			else
1092:../../Source/queue.c **** 			{
1093:../../Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1094:../../Source/queue.c **** 				knows that data was posted while it was locked. */
1095:../../Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1096:../../Source/queue.c **** 			}
1097:../../Source/queue.c **** 
1098:../../Source/queue.c **** 			xReturn = pdPASS;
1099:../../Source/queue.c **** 		}
1100:../../Source/queue.c **** 		else
1101:../../Source/queue.c **** 		{
1102:../../Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1103:../../Source/queue.c **** 			xReturn = errQUEUE_FULL;
1104:../../Source/queue.c **** 		}
1105:../../Source/queue.c **** 	}
1106:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1107:../../Source/queue.c **** 
1108:../../Source/queue.c **** 	return xReturn;
1109:../../Source/queue.c **** }
1110:../../Source/queue.c **** /*-----------------------------------------------------------*/
1111:../../Source/queue.c **** 
1112:../../Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1113:../../Source/queue.c **** {
1114:../../Source/queue.c **** BaseType_t xReturn;
1115:../../Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1116:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1117:../../Source/queue.c **** 
1118:../../Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1119:../../Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1120:../../Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1121:../../Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1122:../../Source/queue.c **** 	post). */
1123:../../Source/queue.c **** 
1124:../../Source/queue.c **** 	configASSERT( pxQueue );
1125:../../Source/queue.c **** 
1126:../../Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1127:../../Source/queue.c **** 	if the item size is not 0. */
1128:../../Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1129:../../Source/queue.c **** 
1130:../../Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1131:../../Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1132:../../Source/queue.c **** 	interrupts, only tasks. */
1133:../../Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutex
1134:../../Source/queue.c **** 
1135:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1136:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1137:../../Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1138:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1139:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1140:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1141:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1142:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1143:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1144:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1145:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1146:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1147:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1148:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1149:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1150:../../Source/queue.c **** 
1151:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1152:../../Source/queue.c **** 	{
1153:../../Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1154:../../Source/queue.c **** 
1155:../../Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1156:../../Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1157:../../Source/queue.c **** 		space'. */
1158:../../Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
1159:../../Source/queue.c **** 		{
1160:../../Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
1161:../../Source/queue.c **** 
1162:../../Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1163:../../Source/queue.c **** 
1164:../../Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1165:../../Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1166:../../Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1167:../../Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1168:../../Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1169:../../Source/queue.c **** 			messages (semaphores) available. */
1170:../../Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1171:../../Source/queue.c **** 
1172:../../Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1173:../../Source/queue.c **** 			be done when the queue is unlocked later. */
1174:../../Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1175:../../Source/queue.c **** 			{
1176:../../Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1177:../../Source/queue.c **** 				{
1178:../../Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1179:../../Source/queue.c **** 					{
1180:../../Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1181:../../Source/queue.c **** 						{
1182:../../Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1183:../../Source/queue.c **** 							posting	to the queue set caused a higher priority
1184:../../Source/queue.c **** 							task to	unblock.  A context switch is required. */
1185:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1186:../../Source/queue.c **** 							{
1187:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1188:../../Source/queue.c **** 							}
1189:../../Source/queue.c **** 							else
1190:../../Source/queue.c **** 							{
1191:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1192:../../Source/queue.c **** 							}
1193:../../Source/queue.c **** 						}
1194:../../Source/queue.c **** 						else
1195:../../Source/queue.c **** 						{
1196:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1197:../../Source/queue.c **** 						}
1198:../../Source/queue.c **** 					}
1199:../../Source/queue.c **** 					else
1200:../../Source/queue.c **** 					{
1201:../../Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1202:../../Source/queue.c **** 						{
1203:../../Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1204:../../Source/queue.c **** 							{
1205:../../Source/queue.c **** 								/* The task waiting has a higher priority so
1206:../../Source/queue.c **** 								record that a context switch is required. */
1207:../../Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1208:../../Source/queue.c **** 								{
1209:../../Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1210:../../Source/queue.c **** 								}
1211:../../Source/queue.c **** 								else
1212:../../Source/queue.c **** 								{
1213:../../Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1214:../../Source/queue.c **** 								}
1215:../../Source/queue.c **** 							}
1216:../../Source/queue.c **** 							else
1217:../../Source/queue.c **** 							{
1218:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1219:../../Source/queue.c **** 							}
1220:../../Source/queue.c **** 						}
1221:../../Source/queue.c **** 						else
1222:../../Source/queue.c **** 						{
1223:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1224:../../Source/queue.c **** 						}
1225:../../Source/queue.c **** 					}
1226:../../Source/queue.c **** 				}
1227:../../Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1228:../../Source/queue.c **** 				{
1229:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1230:../../Source/queue.c **** 					{
1231:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1232:../../Source/queue.c **** 						{
1233:../../Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1234:../../Source/queue.c **** 							context	switch is required. */
1235:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1236:../../Source/queue.c **** 							{
1237:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1238:../../Source/queue.c **** 							}
1239:../../Source/queue.c **** 							else
1240:../../Source/queue.c **** 							{
1241:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1242:../../Source/queue.c **** 							}
1243:../../Source/queue.c **** 						}
1244:../../Source/queue.c **** 						else
1245:../../Source/queue.c **** 						{
1246:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1247:../../Source/queue.c **** 						}
1248:../../Source/queue.c **** 					}
1249:../../Source/queue.c **** 					else
1250:../../Source/queue.c **** 					{
1251:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1252:../../Source/queue.c **** 					}
1253:../../Source/queue.c **** 				}
1254:../../Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1255:../../Source/queue.c **** 			}
1256:../../Source/queue.c **** 			else
1257:../../Source/queue.c **** 			{
1258:../../Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1259:../../Source/queue.c **** 				knows that data was posted while it was locked. */
1260:../../Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1261:../../Source/queue.c **** 			}
1262:../../Source/queue.c **** 
1263:../../Source/queue.c **** 			xReturn = pdPASS;
1264:../../Source/queue.c **** 		}
1265:../../Source/queue.c **** 		else
1266:../../Source/queue.c **** 		{
1267:../../Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1268:../../Source/queue.c **** 			xReturn = errQUEUE_FULL;
1269:../../Source/queue.c **** 		}
1270:../../Source/queue.c **** 	}
1271:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1272:../../Source/queue.c **** 
1273:../../Source/queue.c **** 	return xReturn;
1274:../../Source/queue.c **** }
1275:../../Source/queue.c **** /*-----------------------------------------------------------*/
1276:../../Source/queue.c **** 
1277:../../Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1278:../../Source/queue.c **** {
1279:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1280:../../Source/queue.c **** TimeOut_t xTimeOut;
1281:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1282:../../Source/queue.c **** 
1283:../../Source/queue.c **** 	/* Check the pointer is not NULL. */
1284:../../Source/queue.c **** 	configASSERT( ( pxQueue ) );
1285:../../Source/queue.c **** 
1286:../../Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1287:../../Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1288:../../Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1289:../../Source/queue.c **** 
1290:../../Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1291:../../Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1292:../../Source/queue.c **** 	{
1293:../../Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1294:../../Source/queue.c **** 	}
1295:../../Source/queue.c **** 	#endif
1296:../../Source/queue.c **** 
1297:../../Source/queue.c **** 
1298:../../Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1299:../../Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1300:../../Source/queue.c **** 	interest of execution time efficiency. */
1301:../../Source/queue.c **** 	for( ;; )
1302:../../Source/queue.c **** 	{
1303:../../Source/queue.c **** 		taskENTER_CRITICAL();
1304:../../Source/queue.c **** 		{
1305:../../Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1306:../../Source/queue.c **** 
1307:../../Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1308:../../Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1309:../../Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1310:../../Source/queue.c **** 			{
1311:../../Source/queue.c **** 				/* Data available, remove one item. */
1312:../../Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1313:../../Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1314:../../Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1315:../../Source/queue.c **** 
1316:../../Source/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1317:../../Source/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1318:../../Source/queue.c **** 				task. */
1319:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1320:../../Source/queue.c **** 				{
1321:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1322:../../Source/queue.c **** 					{
1323:../../Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1324:../../Source/queue.c **** 					}
1325:../../Source/queue.c **** 					else
1326:../../Source/queue.c **** 					{
1327:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1328:../../Source/queue.c **** 					}
1329:../../Source/queue.c **** 				}
1330:../../Source/queue.c **** 				else
1331:../../Source/queue.c **** 				{
1332:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1333:../../Source/queue.c **** 				}
1334:../../Source/queue.c **** 
1335:../../Source/queue.c **** 				taskEXIT_CRITICAL();
1336:../../Source/queue.c **** 				return pdPASS;
1337:../../Source/queue.c **** 			}
1338:../../Source/queue.c **** 			else
1339:../../Source/queue.c **** 			{
1340:../../Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1341:../../Source/queue.c **** 				{
1342:../../Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1343:../../Source/queue.c **** 					the block time has expired) so leave now. */
1344:../../Source/queue.c **** 					taskEXIT_CRITICAL();
1345:../../Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1346:../../Source/queue.c **** 					return errQUEUE_EMPTY;
1347:../../Source/queue.c **** 				}
1348:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1349:../../Source/queue.c **** 				{
1350:../../Source/queue.c **** 					/* The queue was empty and a block time was specified so
1351:../../Source/queue.c **** 					configure the timeout structure. */
1352:../../Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1353:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1354:../../Source/queue.c **** 				}
1355:../../Source/queue.c **** 				else
1356:../../Source/queue.c **** 				{
1357:../../Source/queue.c **** 					/* Entry time was already set. */
1358:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1359:../../Source/queue.c **** 				}
1360:../../Source/queue.c **** 			}
1361:../../Source/queue.c **** 		}
1362:../../Source/queue.c **** 		taskEXIT_CRITICAL();
1363:../../Source/queue.c **** 
1364:../../Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1365:../../Source/queue.c **** 		now the critical section has been exited. */
1366:../../Source/queue.c **** 
1367:../../Source/queue.c **** 		vTaskSuspendAll();
1368:../../Source/queue.c **** 		prvLockQueue( pxQueue );
1369:../../Source/queue.c **** 
1370:../../Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1371:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1372:../../Source/queue.c **** 		{
1373:../../Source/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1374:../../Source/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1375:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1376:../../Source/queue.c **** 			{
1377:../../Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1378:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1379:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1380:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1381:../../Source/queue.c **** 				{
1382:../../Source/queue.c **** 					portYIELD_WITHIN_API();
1383:../../Source/queue.c **** 				}
1384:../../Source/queue.c **** 				else
1385:../../Source/queue.c **** 				{
1386:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1387:../../Source/queue.c **** 				}
1388:../../Source/queue.c **** 			}
1389:../../Source/queue.c **** 			else
1390:../../Source/queue.c **** 			{
1391:../../Source/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1392:../../Source/queue.c **** 				data. */
1393:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1394:../../Source/queue.c **** 				( void ) xTaskResumeAll();
1395:../../Source/queue.c **** 			}
1396:../../Source/queue.c **** 		}
1397:../../Source/queue.c **** 		else
1398:../../Source/queue.c **** 		{
1399:../../Source/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1400:../../Source/queue.c **** 			back and attempt to read the data. */
1401:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
1402:../../Source/queue.c **** 			( void ) xTaskResumeAll();
1403:../../Source/queue.c **** 
1404:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1405:../../Source/queue.c **** 			{
1406:../../Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1407:../../Source/queue.c **** 				return errQUEUE_EMPTY;
1408:../../Source/queue.c **** 			}
1409:../../Source/queue.c **** 			else
1410:../../Source/queue.c **** 			{
1411:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1412:../../Source/queue.c **** 			}
1413:../../Source/queue.c **** 		}
1414:../../Source/queue.c **** 	} /*lint -restore */
1415:../../Source/queue.c **** }
1416:../../Source/queue.c **** /*-----------------------------------------------------------*/
1417:../../Source/queue.c **** 
1418:../../Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1419:../../Source/queue.c **** {
1420:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1421:../../Source/queue.c **** TimeOut_t xTimeOut;
1422:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1423:../../Source/queue.c **** 
1424:../../Source/queue.c **** #if( configUSE_MUTEXES == 1 )
1425:../../Source/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
1426:../../Source/queue.c **** #endif
1427:../../Source/queue.c **** 
1428:../../Source/queue.c **** 	/* Check the queue pointer is not NULL. */
1429:../../Source/queue.c **** 	configASSERT( ( pxQueue ) );
1430:../../Source/queue.c **** 
1431:../../Source/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1432:../../Source/queue.c **** 	0. */
1433:../../Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1434:../../Source/queue.c **** 
1435:../../Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1436:../../Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1437:../../Source/queue.c **** 	{
1438:../../Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1439:../../Source/queue.c **** 	}
1440:../../Source/queue.c **** 	#endif
1441:../../Source/queue.c **** 
1442:../../Source/queue.c **** 
1443:../../Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1444:../../Source/queue.c **** 	statements within the function itself.  This is done in the interest
1445:../../Source/queue.c **** 	of execution time efficiency. */
1446:../../Source/queue.c **** 	for( ;; )
1447:../../Source/queue.c **** 	{
1448:../../Source/queue.c **** 		taskENTER_CRITICAL();
1449:../../Source/queue.c **** 		{
1450:../../Source/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1451:../../Source/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1452:../../Source/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
1453:../../Source/queue.c **** 
1454:../../Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1455:../../Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1456:../../Source/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1457:../../Source/queue.c **** 			{
1458:../../Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1459:../../Source/queue.c **** 
1460:../../Source/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1461:../../Source/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1462:../../Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
1463:../../Source/queue.c **** 
1464:../../Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1465:../../Source/queue.c **** 				{
1466:../../Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1467:../../Source/queue.c **** 					{
1468:../../Source/queue.c **** 						/* Record the information required to implement
1469:../../Source/queue.c **** 						priority inheritance should it become necessary. */
1470:../../Source/queue.c **** 						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1471:../../Source/queue.c **** 					}
1472:../../Source/queue.c **** 					else
1473:../../Source/queue.c **** 					{
1474:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1475:../../Source/queue.c **** 					}
1476:../../Source/queue.c **** 				}
1477:../../Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1478:../../Source/queue.c **** 
1479:../../Source/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1480:../../Source/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1481:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1482:../../Source/queue.c **** 				{
1483:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1484:../../Source/queue.c **** 					{
1485:../../Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1486:../../Source/queue.c **** 					}
1487:../../Source/queue.c **** 					else
1488:../../Source/queue.c **** 					{
1489:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1490:../../Source/queue.c **** 					}
1491:../../Source/queue.c **** 				}
1492:../../Source/queue.c **** 				else
1493:../../Source/queue.c **** 				{
1494:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1495:../../Source/queue.c **** 				}
1496:../../Source/queue.c **** 
1497:../../Source/queue.c **** 				taskEXIT_CRITICAL();
1498:../../Source/queue.c **** 				return pdPASS;
1499:../../Source/queue.c **** 			}
1500:../../Source/queue.c **** 			else
1501:../../Source/queue.c **** 			{
1502:../../Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1503:../../Source/queue.c **** 				{
1504:../../Source/queue.c **** 					/* For inheritance to have occurred there must have been an
1505:../../Source/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1506:../../Source/queue.c **** 					if it were 0 the function would have exited. */
1507:../../Source/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1508:../../Source/queue.c **** 					{
1509:../../Source/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
1510:../../Source/queue.c **** 					}
1511:../../Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1512:../../Source/queue.c **** 
1513:../../Source/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1514:../../Source/queue.c **** 					(or the block time has expired) so exit now. */
1515:../../Source/queue.c **** 					taskEXIT_CRITICAL();
1516:../../Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1517:../../Source/queue.c **** 					return errQUEUE_EMPTY;
1518:../../Source/queue.c **** 				}
1519:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1520:../../Source/queue.c **** 				{
1521:../../Source/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1522:../../Source/queue.c **** 					so configure the timeout structure ready to block. */
1523:../../Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1524:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1525:../../Source/queue.c **** 				}
1526:../../Source/queue.c **** 				else
1527:../../Source/queue.c **** 				{
1528:../../Source/queue.c **** 					/* Entry time was already set. */
1529:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1530:../../Source/queue.c **** 				}
1531:../../Source/queue.c **** 			}
1532:../../Source/queue.c **** 		}
1533:../../Source/queue.c **** 		taskEXIT_CRITICAL();
1534:../../Source/queue.c **** 
1535:../../Source/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1536:../../Source/queue.c **** 		now the critical section has been exited. */
1537:../../Source/queue.c **** 
1538:../../Source/queue.c **** 		vTaskSuspendAll();
1539:../../Source/queue.c **** 		prvLockQueue( pxQueue );
1540:../../Source/queue.c **** 
1541:../../Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1542:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1543:../../Source/queue.c **** 		{
1544:../../Source/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1545:../../Source/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1546:../../Source/queue.c **** 			become available.  As semaphores are implemented with queues the
1547:../../Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1548:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1549:../../Source/queue.c **** 			{
1550:../../Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1551:../../Source/queue.c **** 
1552:../../Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1553:../../Source/queue.c **** 				{
1554:../../Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1555:../../Source/queue.c **** 					{
1556:../../Source/queue.c **** 						taskENTER_CRITICAL();
1557:../../Source/queue.c **** 						{
1558:../../Source/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
1559:../../Source/queue.c **** 						}
1560:../../Source/queue.c **** 						taskEXIT_CRITICAL();
1561:../../Source/queue.c **** 					}
1562:../../Source/queue.c **** 					else
1563:../../Source/queue.c **** 					{
1564:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1565:../../Source/queue.c **** 					}
1566:../../Source/queue.c **** 				}
1567:../../Source/queue.c **** 				#endif
1568:../../Source/queue.c **** 
1569:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1570:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1571:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1572:../../Source/queue.c **** 				{
1573:../../Source/queue.c **** 					portYIELD_WITHIN_API();
1574:../../Source/queue.c **** 				}
1575:../../Source/queue.c **** 				else
1576:../../Source/queue.c **** 				{
1577:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1578:../../Source/queue.c **** 				}
1579:../../Source/queue.c **** 			}
1580:../../Source/queue.c **** 			else
1581:../../Source/queue.c **** 			{
1582:../../Source/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1583:../../Source/queue.c **** 				attempt to take the semaphore again. */
1584:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1585:../../Source/queue.c **** 				( void ) xTaskResumeAll();
1586:../../Source/queue.c **** 			}
1587:../../Source/queue.c **** 		}
1588:../../Source/queue.c **** 		else
1589:../../Source/queue.c **** 		{
1590:../../Source/queue.c **** 			/* Timed out. */
1591:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
1592:../../Source/queue.c **** 			( void ) xTaskResumeAll();
1593:../../Source/queue.c **** 
1594:../../Source/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1595:../../Source/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1596:../../Source/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1597:../../Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1598:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1599:../../Source/queue.c **** 			{
1600:../../Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1601:../../Source/queue.c **** 				{
1602:../../Source/queue.c **** 					/* xInheritanceOccurred could only have be set if
1603:../../Source/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1604:../../Source/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1605:../../Source/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
1606:../../Source/queue.c **** 					{
1607:../../Source/queue.c **** 						taskENTER_CRITICAL();
1608:../../Source/queue.c **** 						{
1609:../../Source/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1610:../../Source/queue.c **** 
1611:../../Source/queue.c **** 							/* This task blocking on the mutex caused another
1612:../../Source/queue.c **** 							task to inherit this task's priority.  Now this task
1613:../../Source/queue.c **** 							has timed out the priority should be disinherited
1614:../../Source/queue.c **** 							again, but only as low as the next highest priority
1615:../../Source/queue.c **** 							task that is waiting for the same mutex. */
1616:../../Source/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
1617:../../Source/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPri
1618:../../Source/queue.c **** 						}
1619:../../Source/queue.c **** 						taskEXIT_CRITICAL();
1620:../../Source/queue.c **** 					}
1621:../../Source/queue.c **** 				}
1622:../../Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1623:../../Source/queue.c **** 
1624:../../Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1625:../../Source/queue.c **** 				return errQUEUE_EMPTY;
1626:../../Source/queue.c **** 			}
1627:../../Source/queue.c **** 			else
1628:../../Source/queue.c **** 			{
1629:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1630:../../Source/queue.c **** 			}
1631:../../Source/queue.c **** 		}
1632:../../Source/queue.c **** 	} /*lint -restore */
1633:../../Source/queue.c **** }
1634:../../Source/queue.c **** /*-----------------------------------------------------------*/
1635:../../Source/queue.c **** 
1636:../../Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1637:../../Source/queue.c **** {
1638:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1639:../../Source/queue.c **** TimeOut_t xTimeOut;
1640:../../Source/queue.c **** int8_t *pcOriginalReadPosition;
1641:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1642:../../Source/queue.c **** 
1643:../../Source/queue.c **** 	/* Check the pointer is not NULL. */
1644:../../Source/queue.c **** 	configASSERT( ( pxQueue ) );
1645:../../Source/queue.c **** 
1646:../../Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1647:../../Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1648:../../Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1649:../../Source/queue.c **** 
1650:../../Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1651:../../Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1652:../../Source/queue.c **** 	{
1653:../../Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1654:../../Source/queue.c **** 	}
1655:../../Source/queue.c **** 	#endif
1656:../../Source/queue.c **** 
1657:../../Source/queue.c **** 
1658:../../Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1659:../../Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1660:../../Source/queue.c **** 	interest of execution time efficiency. */
1661:../../Source/queue.c **** 	for( ;; )
1662:../../Source/queue.c **** 	{
1663:../../Source/queue.c **** 		taskENTER_CRITICAL();
1664:../../Source/queue.c **** 		{
1665:../../Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1666:../../Source/queue.c **** 
1667:../../Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1668:../../Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1669:../../Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1670:../../Source/queue.c **** 			{
1671:../../Source/queue.c **** 				/* Remember the read position so it can be reset after the data
1672:../../Source/queue.c **** 				is read from the queue as this function is only peeking the
1673:../../Source/queue.c **** 				data, not removing it. */
1674:../../Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1675:../../Source/queue.c **** 
1676:../../Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1677:../../Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1678:../../Source/queue.c **** 
1679:../../Source/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1680:../../Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1681:../../Source/queue.c **** 
1682:../../Source/queue.c **** 				/* The data is being left in the queue, so see if there are
1683:../../Source/queue.c **** 				any other tasks waiting for the data. */
1684:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1685:../../Source/queue.c **** 				{
1686:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1687:../../Source/queue.c **** 					{
1688:../../Source/queue.c **** 						/* The task waiting has a higher priority than this task. */
1689:../../Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1690:../../Source/queue.c **** 					}
1691:../../Source/queue.c **** 					else
1692:../../Source/queue.c **** 					{
1693:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1694:../../Source/queue.c **** 					}
1695:../../Source/queue.c **** 				}
1696:../../Source/queue.c **** 				else
1697:../../Source/queue.c **** 				{
1698:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1699:../../Source/queue.c **** 				}
1700:../../Source/queue.c **** 
1701:../../Source/queue.c **** 				taskEXIT_CRITICAL();
1702:../../Source/queue.c **** 				return pdPASS;
1703:../../Source/queue.c **** 			}
1704:../../Source/queue.c **** 			else
1705:../../Source/queue.c **** 			{
1706:../../Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1707:../../Source/queue.c **** 				{
1708:../../Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1709:../../Source/queue.c **** 					the block time has expired) so leave now. */
1710:../../Source/queue.c **** 					taskEXIT_CRITICAL();
1711:../../Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1712:../../Source/queue.c **** 					return errQUEUE_EMPTY;
1713:../../Source/queue.c **** 				}
1714:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1715:../../Source/queue.c **** 				{
1716:../../Source/queue.c **** 					/* The queue was empty and a block time was specified so
1717:../../Source/queue.c **** 					configure the timeout structure ready to enter the blocked
1718:../../Source/queue.c **** 					state. */
1719:../../Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1720:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1721:../../Source/queue.c **** 				}
1722:../../Source/queue.c **** 				else
1723:../../Source/queue.c **** 				{
1724:../../Source/queue.c **** 					/* Entry time was already set. */
1725:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1726:../../Source/queue.c **** 				}
1727:../../Source/queue.c **** 			}
1728:../../Source/queue.c **** 		}
1729:../../Source/queue.c **** 		taskEXIT_CRITICAL();
1730:../../Source/queue.c **** 
1731:../../Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1732:../../Source/queue.c **** 		now the critical section has been exited. */
1733:../../Source/queue.c **** 
1734:../../Source/queue.c **** 		vTaskSuspendAll();
1735:../../Source/queue.c **** 		prvLockQueue( pxQueue );
1736:../../Source/queue.c **** 
1737:../../Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1738:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1739:../../Source/queue.c **** 		{
1740:../../Source/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1741:../../Source/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1742:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1743:../../Source/queue.c **** 			{
1744:../../Source/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1745:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1746:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1747:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1748:../../Source/queue.c **** 				{
1749:../../Source/queue.c **** 					portYIELD_WITHIN_API();
1750:../../Source/queue.c **** 				}
1751:../../Source/queue.c **** 				else
1752:../../Source/queue.c **** 				{
1753:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1754:../../Source/queue.c **** 				}
1755:../../Source/queue.c **** 			}
1756:../../Source/queue.c **** 			else
1757:../../Source/queue.c **** 			{
1758:../../Source/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1759:../../Source/queue.c **** 				state, instead return to try and obtain the data. */
1760:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1761:../../Source/queue.c **** 				( void ) xTaskResumeAll();
1762:../../Source/queue.c **** 			}
1763:../../Source/queue.c **** 		}
1764:../../Source/queue.c **** 		else
1765:../../Source/queue.c **** 		{
1766:../../Source/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1767:../../Source/queue.c **** 			exit, otherwise go back and try to read the data again. */
1768:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
1769:../../Source/queue.c **** 			( void ) xTaskResumeAll();
1770:../../Source/queue.c **** 
1771:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1772:../../Source/queue.c **** 			{
1773:../../Source/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1774:../../Source/queue.c **** 				return errQUEUE_EMPTY;
1775:../../Source/queue.c **** 			}
1776:../../Source/queue.c **** 			else
1777:../../Source/queue.c **** 			{
1778:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1779:../../Source/queue.c **** 			}
1780:../../Source/queue.c **** 		}
1781:../../Source/queue.c **** 	} /*lint -restore */
1782:../../Source/queue.c **** }
1783:../../Source/queue.c **** /*-----------------------------------------------------------*/
1784:../../Source/queue.c **** 
1785:../../Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1786:../../Source/queue.c **** {
1787:../../Source/queue.c **** BaseType_t xReturn;
1788:../../Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1789:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1790:../../Source/queue.c **** 
1791:../../Source/queue.c **** 	configASSERT( pxQueue );
1792:../../Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1793:../../Source/queue.c **** 
1794:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1795:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1796:../../Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1797:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1798:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1799:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1800:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1801:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1802:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1803:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1804:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1805:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1806:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1807:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1808:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1809:../../Source/queue.c **** 
1810:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1811:../../Source/queue.c **** 	{
1812:../../Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1813:../../Source/queue.c **** 
1814:../../Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1815:../../Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1816:../../Source/queue.c **** 		{
1817:../../Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
1818:../../Source/queue.c **** 
1819:../../Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1820:../../Source/queue.c **** 
1821:../../Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1822:../../Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1823:../../Source/queue.c **** 
1824:../../Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1825:../../Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1826:../../Source/queue.c **** 			will know that an ISR has removed data while the queue was
1827:../../Source/queue.c **** 			locked. */
1828:../../Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
1829:../../Source/queue.c **** 			{
1830:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1831:../../Source/queue.c **** 				{
1832:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1833:../../Source/queue.c **** 					{
1834:../../Source/queue.c **** 						/* The task waiting has a higher priority than us so
1835:../../Source/queue.c **** 						force a context switch. */
1836:../../Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
1837:../../Source/queue.c **** 						{
1838:../../Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
1839:../../Source/queue.c **** 						}
1840:../../Source/queue.c **** 						else
1841:../../Source/queue.c **** 						{
1842:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1843:../../Source/queue.c **** 						}
1844:../../Source/queue.c **** 					}
1845:../../Source/queue.c **** 					else
1846:../../Source/queue.c **** 					{
1847:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1848:../../Source/queue.c **** 					}
1849:../../Source/queue.c **** 				}
1850:../../Source/queue.c **** 				else
1851:../../Source/queue.c **** 				{
1852:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1853:../../Source/queue.c **** 				}
1854:../../Source/queue.c **** 			}
1855:../../Source/queue.c **** 			else
1856:../../Source/queue.c **** 			{
1857:../../Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1858:../../Source/queue.c **** 				knows that data was removed while it was locked. */
1859:../../Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
1860:../../Source/queue.c **** 			}
1861:../../Source/queue.c **** 
1862:../../Source/queue.c **** 			xReturn = pdPASS;
1863:../../Source/queue.c **** 		}
1864:../../Source/queue.c **** 		else
1865:../../Source/queue.c **** 		{
1866:../../Source/queue.c **** 			xReturn = pdFAIL;
1867:../../Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1868:../../Source/queue.c **** 		}
1869:../../Source/queue.c **** 	}
1870:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1871:../../Source/queue.c **** 
1872:../../Source/queue.c **** 	return xReturn;
1873:../../Source/queue.c **** }
1874:../../Source/queue.c **** /*-----------------------------------------------------------*/
1875:../../Source/queue.c **** 
1876:../../Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1877:../../Source/queue.c **** {
1878:../../Source/queue.c **** BaseType_t xReturn;
1879:../../Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1880:../../Source/queue.c **** int8_t *pcOriginalReadPosition;
1881:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1882:../../Source/queue.c **** 
1883:../../Source/queue.c **** 	configASSERT( pxQueue );
1884:../../Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1885:../../Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1886:../../Source/queue.c **** 
1887:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1888:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1889:../../Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1890:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1891:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1892:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1893:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1894:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1895:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1896:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1897:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1898:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1899:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1900:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1901:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1902:../../Source/queue.c **** 
1903:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1904:../../Source/queue.c **** 	{
1905:../../Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1906:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1907:../../Source/queue.c **** 		{
1908:../../Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1909:../../Source/queue.c **** 
1910:../../Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1911:../../Source/queue.c **** 			actually being removed from the queue. */
1912:../../Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1913:../../Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1914:../../Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1915:../../Source/queue.c **** 
1916:../../Source/queue.c **** 			xReturn = pdPASS;
1917:../../Source/queue.c **** 		}
1918:../../Source/queue.c **** 		else
1919:../../Source/queue.c **** 		{
1920:../../Source/queue.c **** 			xReturn = pdFAIL;
1921:../../Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1922:../../Source/queue.c **** 		}
1923:../../Source/queue.c **** 	}
1924:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1925:../../Source/queue.c **** 
1926:../../Source/queue.c **** 	return xReturn;
1927:../../Source/queue.c **** }
1928:../../Source/queue.c **** /*-----------------------------------------------------------*/
1929:../../Source/queue.c **** 
1930:../../Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1931:../../Source/queue.c **** {
1932:../../Source/queue.c **** UBaseType_t uxReturn;
1933:../../Source/queue.c **** 
1934:../../Source/queue.c **** 	configASSERT( xQueue );
1935:../../Source/queue.c **** 
1936:../../Source/queue.c **** 	taskENTER_CRITICAL();
1937:../../Source/queue.c **** 	{
1938:../../Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1939:../../Source/queue.c **** 	}
1940:../../Source/queue.c **** 	taskEXIT_CRITICAL();
1941:../../Source/queue.c **** 
1942:../../Source/queue.c **** 	return uxReturn;
1943:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1944:../../Source/queue.c **** /*-----------------------------------------------------------*/
1945:../../Source/queue.c **** 
1946:../../Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1947:../../Source/queue.c **** {
1948:../../Source/queue.c **** UBaseType_t uxReturn;
1949:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1950:../../Source/queue.c **** 
1951:../../Source/queue.c **** 	configASSERT( pxQueue );
1952:../../Source/queue.c **** 
1953:../../Source/queue.c **** 	taskENTER_CRITICAL();
1954:../../Source/queue.c **** 	{
1955:../../Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1956:../../Source/queue.c **** 	}
1957:../../Source/queue.c **** 	taskEXIT_CRITICAL();
1958:../../Source/queue.c **** 
1959:../../Source/queue.c **** 	return uxReturn;
1960:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1961:../../Source/queue.c **** /*-----------------------------------------------------------*/
1962:../../Source/queue.c **** 
1963:../../Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1964:../../Source/queue.c **** {
1965:../../Source/queue.c **** UBaseType_t uxReturn;
1966:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1967:../../Source/queue.c **** 
1968:../../Source/queue.c **** 	configASSERT( pxQueue );
1969:../../Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
1970:../../Source/queue.c **** 
1971:../../Source/queue.c **** 	return uxReturn;
1972:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1973:../../Source/queue.c **** /*-----------------------------------------------------------*/
1974:../../Source/queue.c **** 
1975:../../Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1976:../../Source/queue.c **** {
1977:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1978:../../Source/queue.c **** 
1979:../../Source/queue.c **** 	configASSERT( pxQueue );
1980:../../Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1981:../../Source/queue.c **** 
1982:../../Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1983:../../Source/queue.c **** 	{
1984:../../Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1985:../../Source/queue.c **** 	}
1986:../../Source/queue.c **** 	#endif
1987:../../Source/queue.c **** 
1988:../../Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1989:../../Source/queue.c **** 	{
1990:../../Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1991:../../Source/queue.c **** 		again. */
1992:../../Source/queue.c **** 		vPortFree( pxQueue );
1993:../../Source/queue.c **** 	}
1994:../../Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1995:../../Source/queue.c **** 	{
1996:../../Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1997:../../Source/queue.c **** 		check before attempting to free the memory. */
1998:../../Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1999:../../Source/queue.c **** 		{
2000:../../Source/queue.c **** 			vPortFree( pxQueue );
2001:../../Source/queue.c **** 		}
2002:../../Source/queue.c **** 		else
2003:../../Source/queue.c **** 		{
2004:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2005:../../Source/queue.c **** 		}
2006:../../Source/queue.c **** 	}
2007:../../Source/queue.c **** 	#else
2008:../../Source/queue.c **** 	{
2009:../../Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
2010:../../Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
2011:../../Source/queue.c **** 		( void ) pxQueue;
2012:../../Source/queue.c **** 	}
2013:../../Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2014:../../Source/queue.c **** }
2015:../../Source/queue.c **** /*-----------------------------------------------------------*/
2016:../../Source/queue.c **** 
2017:../../Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2018:../../Source/queue.c **** 
2019:../../Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2020:../../Source/queue.c **** 	{
2021:../../Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2022:../../Source/queue.c **** 	}
2023:../../Source/queue.c **** 
2024:../../Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2025:../../Source/queue.c **** /*-----------------------------------------------------------*/
2026:../../Source/queue.c **** 
2027:../../Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2028:../../Source/queue.c **** 
2029:../../Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
2030:../../Source/queue.c **** 	{
2031:../../Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2032:../../Source/queue.c **** 	}
2033:../../Source/queue.c **** 
2034:../../Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2035:../../Source/queue.c **** /*-----------------------------------------------------------*/
2036:../../Source/queue.c **** 
2037:../../Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2038:../../Source/queue.c **** 
2039:../../Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2040:../../Source/queue.c **** 	{
2041:../../Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
2042:../../Source/queue.c **** 	}
2043:../../Source/queue.c **** 
2044:../../Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2045:../../Source/queue.c **** /*-----------------------------------------------------------*/
2046:../../Source/queue.c **** 
2047:../../Source/queue.c **** #if( configUSE_MUTEXES == 1 )
2048:../../Source/queue.c **** 
2049:../../Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2050:../../Source/queue.c **** 	{
2051:../../Source/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2052:../../Source/queue.c **** 
2053:../../Source/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2054:../../Source/queue.c **** 		priority, but the waiting task times out, then the holder should
2055:../../Source/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2056:../../Source/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2057:../../Source/queue.c **** 		return the priority of the highest priority task that is waiting for the
2058:../../Source/queue.c **** 		mutex. */
2059:../../Source/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
2060:../../Source/queue.c **** 		{
2061:../../Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET
2062:../../Source/queue.c **** 		}
2063:../../Source/queue.c **** 		else
2064:../../Source/queue.c **** 		{
2065:../../Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2066:../../Source/queue.c **** 		}
2067:../../Source/queue.c **** 
2068:../../Source/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
2069:../../Source/queue.c **** 	}
2070:../../Source/queue.c **** 
2071:../../Source/queue.c **** #endif /* configUSE_MUTEXES */
2072:../../Source/queue.c **** /*-----------------------------------------------------------*/
2073:../../Source/queue.c **** 
2074:../../Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2075:../../Source/queue.c **** {
2076:../../Source/queue.c **** BaseType_t xReturn = pdFALSE;
2077:../../Source/queue.c **** UBaseType_t uxMessagesWaiting;
2078:../../Source/queue.c **** 
2079:../../Source/queue.c **** 	/* This function is called from a critical section. */
2080:../../Source/queue.c **** 
2081:../../Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
2082:../../Source/queue.c **** 
2083:../../Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
2084:../../Source/queue.c **** 	{
2085:../../Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2086:../../Source/queue.c **** 		{
2087:../../Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2088:../../Source/queue.c **** 			{
2089:../../Source/queue.c **** 				/* The mutex is no longer being held. */
2090:../../Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2091:../../Source/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
2092:../../Source/queue.c **** 			}
2093:../../Source/queue.c **** 			else
2094:../../Source/queue.c **** 			{
2095:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2096:../../Source/queue.c **** 			}
2097:../../Source/queue.c **** 		}
2098:../../Source/queue.c **** 		#endif /* configUSE_MUTEXES */
2099:../../Source/queue.c **** 	}
2100:../../Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
2101:../../Source/queue.c **** 	{
2102:../../Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
2103:../../Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
2104:../../Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
2105:../../Source/queue.c **** 		{
2106:../../Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
2107:../../Source/queue.c **** 		}
2108:../../Source/queue.c **** 		else
2109:../../Source/queue.c **** 		{
2110:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2111:../../Source/queue.c **** 		}
2112:../../Source/queue.c **** 	}
2113:../../Source/queue.c **** 	else
2114:../../Source/queue.c **** 	{
2115:../../Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxIt
2116:../../Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
2117:../../Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
2118:../../Source/queue.c **** 		{
2119:../../Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
2120:../../Source/queue.c **** 		}
2121:../../Source/queue.c **** 		else
2122:../../Source/queue.c **** 		{
2123:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2124:../../Source/queue.c **** 		}
2125:../../Source/queue.c **** 
2126:../../Source/queue.c **** 		if( xPosition == queueOVERWRITE )
2127:../../Source/queue.c **** 		{
2128:../../Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
2129:../../Source/queue.c **** 			{
2130:../../Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
2131:../../Source/queue.c **** 				one from the recorded number of items in the queue so when
2132:../../Source/queue.c **** 				one is added again below the number of recorded items remains
2133:../../Source/queue.c **** 				correct. */
2134:../../Source/queue.c **** 				--uxMessagesWaiting;
2135:../../Source/queue.c **** 			}
2136:../../Source/queue.c **** 			else
2137:../../Source/queue.c **** 			{
2138:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2139:../../Source/queue.c **** 			}
2140:../../Source/queue.c **** 		}
2141:../../Source/queue.c **** 		else
2142:../../Source/queue.c **** 		{
2143:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2144:../../Source/queue.c **** 		}
2145:../../Source/queue.c **** 	}
2146:../../Source/queue.c **** 
2147:../../Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
2148:../../Source/queue.c **** 
2149:../../Source/queue.c **** 	return xReturn;
2150:../../Source/queue.c **** }
2151:../../Source/queue.c **** /*-----------------------------------------------------------*/
2152:../../Source/queue.c **** 
2153:../../Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2154:../../Source/queue.c **** {
2155:../../Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
2156:../../Source/queue.c **** 	{
2157:../../Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char typ
2158:../../Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
2159:../../Source/queue.c **** 		{
2160:../../Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2161:../../Source/queue.c **** 		}
2162:../../Source/queue.c **** 		else
2163:../../Source/queue.c **** 		{
2164:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2165:../../Source/queue.c **** 		}
2166:../../Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue
2167:../../Source/queue.c **** 	}
2168:../../Source/queue.c **** }
2169:../../Source/queue.c **** /*-----------------------------------------------------------*/
2170:../../Source/queue.c **** 
2171:../../Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2172:../../Source/queue.c **** {
2173:../../Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2174:../../Source/queue.c **** 
2175:../../Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2176:../../Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2177:../../Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2178:../../Source/queue.c **** 	updated. */
2179:../../Source/queue.c **** 	taskENTER_CRITICAL();
2180:../../Source/queue.c **** 	{
2181:../../Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
2182:../../Source/queue.c **** 
2183:../../Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
2184:../../Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
2185:../../Source/queue.c **** 		{
2186:../../Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2187:../../Source/queue.c **** 			blocked waiting for data to become available? */
2188:../../Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2189:../../Source/queue.c **** 			{
2190:../../Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
2191:../../Source/queue.c **** 				{
2192:../../Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2193:../../Source/queue.c **** 					{
2194:../../Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
2195:../../Source/queue.c **** 						the queue set caused a higher priority task to unblock.
2196:../../Source/queue.c **** 						A context switch is required. */
2197:../../Source/queue.c **** 						vTaskMissedYield();
2198:../../Source/queue.c **** 					}
2199:../../Source/queue.c **** 					else
2200:../../Source/queue.c **** 					{
2201:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2202:../../Source/queue.c **** 					}
2203:../../Source/queue.c **** 				}
2204:../../Source/queue.c **** 				else
2205:../../Source/queue.c **** 				{
2206:../../Source/queue.c **** 					/* Tasks that are removed from the event list will get
2207:../../Source/queue.c **** 					added to the pending ready list as the scheduler is still
2208:../../Source/queue.c **** 					suspended. */
2209:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2210:../../Source/queue.c **** 					{
2211:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2212:../../Source/queue.c **** 						{
2213:../../Source/queue.c **** 							/* The task waiting has a higher priority so record that a
2214:../../Source/queue.c **** 							context	switch is required. */
2215:../../Source/queue.c **** 							vTaskMissedYield();
2216:../../Source/queue.c **** 						}
2217:../../Source/queue.c **** 						else
2218:../../Source/queue.c **** 						{
2219:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2220:../../Source/queue.c **** 						}
2221:../../Source/queue.c **** 					}
2222:../../Source/queue.c **** 					else
2223:../../Source/queue.c **** 					{
2224:../../Source/queue.c **** 						break;
2225:../../Source/queue.c **** 					}
2226:../../Source/queue.c **** 				}
2227:../../Source/queue.c **** 			}
2228:../../Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2229:../../Source/queue.c **** 			{
2230:../../Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
2231:../../Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2232:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2233:../../Source/queue.c **** 				{
2234:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2235:../../Source/queue.c **** 					{
2236:../../Source/queue.c **** 						/* The task waiting has a higher priority so record that
2237:../../Source/queue.c **** 						a context switch is required. */
2238:../../Source/queue.c **** 						vTaskMissedYield();
2239:../../Source/queue.c **** 					}
2240:../../Source/queue.c **** 					else
2241:../../Source/queue.c **** 					{
2242:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2243:../../Source/queue.c **** 					}
2244:../../Source/queue.c **** 				}
2245:../../Source/queue.c **** 				else
2246:../../Source/queue.c **** 				{
2247:../../Source/queue.c **** 					break;
2248:../../Source/queue.c **** 				}
2249:../../Source/queue.c **** 			}
2250:../../Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2251:../../Source/queue.c **** 
2252:../../Source/queue.c **** 			--cTxLock;
2253:../../Source/queue.c **** 		}
2254:../../Source/queue.c **** 
2255:../../Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
2256:../../Source/queue.c **** 	}
2257:../../Source/queue.c **** 	taskEXIT_CRITICAL();
2258:../../Source/queue.c **** 
2259:../../Source/queue.c **** 	/* Do the same for the Rx lock. */
2260:../../Source/queue.c **** 	taskENTER_CRITICAL();
2261:../../Source/queue.c **** 	{
2262:../../Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
2263:../../Source/queue.c **** 
2264:../../Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
2265:../../Source/queue.c **** 		{
2266:../../Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2267:../../Source/queue.c **** 			{
2268:../../Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2269:../../Source/queue.c **** 				{
2270:../../Source/queue.c **** 					vTaskMissedYield();
2271:../../Source/queue.c **** 				}
2272:../../Source/queue.c **** 				else
2273:../../Source/queue.c **** 				{
2274:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2275:../../Source/queue.c **** 				}
2276:../../Source/queue.c **** 
2277:../../Source/queue.c **** 				--cRxLock;
2278:../../Source/queue.c **** 			}
2279:../../Source/queue.c **** 			else
2280:../../Source/queue.c **** 			{
2281:../../Source/queue.c **** 				break;
2282:../../Source/queue.c **** 			}
2283:../../Source/queue.c **** 		}
2284:../../Source/queue.c **** 
2285:../../Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
2286:../../Source/queue.c **** 	}
2287:../../Source/queue.c **** 	taskEXIT_CRITICAL();
2288:../../Source/queue.c **** }
2289:../../Source/queue.c **** /*-----------------------------------------------------------*/
2290:../../Source/queue.c **** 
2291:../../Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2292:../../Source/queue.c **** {
 205               	.LM0:
 206               	.LFBB1:
 207               	/* prologue: function */
 208               	/* frame size = 0 */
 209               	/* stack size = 0 */
 210               	.L__stack_usage = 0
2293:../../Source/queue.c **** BaseType_t xReturn;
2294:../../Source/queue.c **** 
2295:../../Source/queue.c **** 	taskENTER_CRITICAL();
 212               	.LM1:
 213               	/* #APP */
 214               	 ;  2295 "../../Source/queue.c" 1
 215 0000 0FB6      		in		__tmp_reg__, __SREG__
 216               	 ;  0 "" 2
 217               	 ;  2295 "../../Source/queue.c" 1
 218 0002 F894      		cli
 219               	 ;  0 "" 2
 220               	 ;  2295 "../../Source/queue.c" 1
 221 0004 0F92      		push	__tmp_reg__
 222               	 ;  0 "" 2
2296:../../Source/queue.c **** 	{
2297:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 224               	.LM2:
 225               	/* #NOAPP */
 226 0006 FC01      		movw r30,r24
 227 0008 928D      		ldd r25,Z+26
2298:../../Source/queue.c **** 		{
2299:../../Source/queue.c **** 			xReturn = pdTRUE;
2300:../../Source/queue.c **** 		}
2301:../../Source/queue.c **** 		else
2302:../../Source/queue.c **** 		{
2303:../../Source/queue.c **** 			xReturn = pdFALSE;
2304:../../Source/queue.c **** 		}
2305:../../Source/queue.c **** 	}
2306:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 229               	.LM3:
 230               	/* #APP */
 231               	 ;  2306 "../../Source/queue.c" 1
 232 000a 0F90      		pop		__tmp_reg__
 233               	 ;  0 "" 2
 234               	 ;  2306 "../../Source/queue.c" 1
 235 000c 0FBE      		out		__SREG__, __tmp_reg__
 236               	 ;  0 "" 2
2307:../../Source/queue.c **** 
2308:../../Source/queue.c **** 	return xReturn;
 238               	.LM4:
 239               	/* #NOAPP */
 240 000e 81E0      		ldi r24,lo8(1)
 241 0010 9111      		cpse r25,__zero_reg__
 242 0012 80E0      		ldi r24,0
 243               	.L2:
2309:../../Source/queue.c **** }
 245               	.LM5:
 246 0014 0895      		ret
 248               	.Lscope1:
 250               		.stabd	78,0,0
 256               	prvCopyDataToQueue:
 257               		.stabd	46,0,0
2075:../../Source/queue.c **** BaseType_t xReturn = pdFALSE;
 259               	.LM6:
 260               	.LFBB2:
 261 0016 0F93      		push r16
 262 0018 1F93      		push r17
 263 001a CF93      		push r28
 264 001c DF93      		push r29
 265               	/* prologue: function */
 266               	/* frame size = 0 */
 267               	/* stack size = 4 */
 268               	.L__stack_usage = 4
 269 001e EC01      		movw r28,r24
 270 0020 042F      		mov r16,r20
2081:../../Source/queue.c **** 
 272               	.LM7:
 273 0022 1A8D      		ldd r17,Y+26
2083:../../Source/queue.c **** 	{
 275               	.LM8:
 276 0024 4C8D      		ldd r20,Y+28
 277 0026 4423      		tst r20
 278 0028 01F0      		breq .L8
 279 002a 50E0      		ldi r21,0
2100:../../Source/queue.c **** 	{
 281               	.LM9:
 282 002c 0111      		cpse r16,__zero_reg__
 283 002e 00C0      		rjmp .L9
2102:../../Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
 285               	.LM10:
 286 0030 8A81      		ldd r24,Y+2
 287 0032 9B81      		ldd r25,Y+3
 288 0034 0E94 0000 		call memcpy
2103:../../Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
 290               	.LM11:
 291 0038 2C8D      		ldd r18,Y+28
 292 003a 8A81      		ldd r24,Y+2
 293 003c 9B81      		ldd r25,Y+3
 294 003e 820F      		add r24,r18
 295 0040 911D      		adc r25,__zero_reg__
 296 0042 9B83      		std Y+3,r25
 297 0044 8A83      		std Y+2,r24
2104:../../Source/queue.c **** 		{
 299               	.LM12:
 300 0046 2C81      		ldd r18,Y+4
 301 0048 3D81      		ldd r19,Y+5
 302 004a 8217      		cp r24,r18
 303 004c 9307      		cpc r25,r19
 304 004e 00F0      		brlo .L8
2106:../../Source/queue.c **** 		}
 306               	.LM13:
 307 0050 8881      		ld r24,Y
 308 0052 9981      		ldd r25,Y+1
 309 0054 9B83      		std Y+3,r25
 310 0056 8A83      		std Y+2,r24
 311 0058 00C0      		rjmp .L8
 312               	.L9:
2115:../../Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 314               	.LM14:
 315 005a 8E81      		ldd r24,Y+6
 316 005c 9F81      		ldd r25,Y+7
 317 005e 0E94 0000 		call memcpy
2116:../../Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
 319               	.LM15:
 320 0062 8C8D      		ldd r24,Y+28
 321 0064 90E0      		ldi r25,0
 322 0066 9195      		neg r25
 323 0068 8195      		neg r24
 324 006a 9109      		sbc r25,__zero_reg__
 325 006c 2E81      		ldd r18,Y+6
 326 006e 3F81      		ldd r19,Y+7
 327 0070 280F      		add r18,r24
 328 0072 391F      		adc r19,r25
 329 0074 3F83      		std Y+7,r19
 330 0076 2E83      		std Y+6,r18
2117:../../Source/queue.c **** 		{
 332               	.LM16:
 333 0078 4881      		ld r20,Y
 334 007a 5981      		ldd r21,Y+1
 335 007c 2417      		cp r18,r20
 336 007e 3507      		cpc r19,r21
 337 0080 00F4      		brsh .L10
2119:../../Source/queue.c **** 		}
 339               	.LM17:
 340 0082 2C81      		ldd r18,Y+4
 341 0084 3D81      		ldd r19,Y+5
 342 0086 820F      		add r24,r18
 343 0088 931F      		adc r25,r19
 344 008a 9F83      		std Y+7,r25
 345 008c 8E83      		std Y+6,r24
 346               	.L10:
2126:../../Source/queue.c **** 		{
 348               	.LM18:
 349 008e 0230      		cpi r16,lo8(2)
 350 0090 01F4      		brne .L8
2128:../../Source/queue.c **** 			{
 352               	.LM19:
 353 0092 1111      		cpse r17,__zero_reg__
2134:../../Source/queue.c **** 			}
 355               	.LM20:
 356 0094 1150      		subi r17,lo8(-(-1))
 357               	.L8:
2147:../../Source/queue.c **** 
 359               	.LM21:
 360 0096 1F5F      		subi r17,lo8(-(1))
 361 0098 1A8F      		std Y+26,r17
2150:../../Source/queue.c **** /*-----------------------------------------------------------*/
 363               	.LM22:
 364 009a 80E0      		ldi r24,0
 365               	/* epilogue start */
 366 009c DF91      		pop r29
 367 009e CF91      		pop r28
 368 00a0 1F91      		pop r17
 369 00a2 0F91      		pop r16
 370 00a4 0895      		ret
 375               	.Lscope2:
 377               		.stabd	78,0,0
 382               	prvCopyDataFromQueue:
 383               		.stabd	46,0,0
2154:../../Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 385               	.LM23:
 386               	.LFBB3:
 387               	/* prologue: function */
 388               	/* frame size = 0 */
 389               	/* stack size = 0 */
 390               	.L__stack_usage = 0
 391 00a6 FC01      		movw r30,r24
 392 00a8 CB01      		movw r24,r22
2155:../../Source/queue.c **** 	{
 394               	.LM24:
 395 00aa 448D      		ldd r20,Z+28
 396 00ac 4423      		tst r20
 397 00ae 01F0      		breq .L17
2157:../../Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
 399               	.LM25:
 400 00b0 50E0      		ldi r21,0
 401 00b2 2681      		ldd r18,Z+6
 402 00b4 3781      		ldd r19,Z+7
 403 00b6 240F      		add r18,r20
 404 00b8 351F      		adc r19,r21
 405 00ba 3783      		std Z+7,r19
 406 00bc 2683      		std Z+6,r18
2158:../../Source/queue.c **** 		{
 408               	.LM26:
 409 00be 6481      		ldd r22,Z+4
 410 00c0 7581      		ldd r23,Z+5
 411 00c2 2617      		cp r18,r22
 412 00c4 3707      		cpc r19,r23
 413 00c6 00F0      		brlo .L19
2160:../../Source/queue.c **** 		}
 415               	.LM27:
 416 00c8 2081      		ld r18,Z
 417 00ca 3181      		ldd r19,Z+1
 418 00cc 3783      		std Z+7,r19
 419 00ce 2683      		std Z+6,r18
 420               	.L19:
2166:../../Source/queue.c **** 	}
 422               	.LM28:
 423 00d0 6681      		ldd r22,Z+6
 424 00d2 7781      		ldd r23,Z+7
 425 00d4 0C94 0000 		jmp memcpy
 426               	.L17:
 427 00d8 0895      		ret
 429               	.Lscope3:
 431               		.stabd	78,0,0
 435               	prvUnlockQueue:
 436               		.stabd	46,0,0
2172:../../Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 438               	.LM29:
 439               	.LFBB4:
 440 00da EF92      		push r14
 441 00dc FF92      		push r15
 442 00de 1F93      		push r17
 443 00e0 CF93      		push r28
 444 00e2 DF93      		push r29
 445               	/* prologue: function */
 446               	/* frame size = 0 */
 447               	/* stack size = 5 */
 448               	.L__stack_usage = 5
 449 00e4 EC01      		movw r28,r24
2179:../../Source/queue.c **** 	{
 451               	.LM30:
 452               	/* #APP */
 453               	 ;  2179 "../../Source/queue.c" 1
 454 00e6 0FB6      		in		__tmp_reg__, __SREG__
 455               	 ;  0 "" 2
 456               	 ;  2179 "../../Source/queue.c" 1
 457 00e8 F894      		cli
 458               	 ;  0 "" 2
 459               	 ;  2179 "../../Source/queue.c" 1
 460 00ea 0F92      		push	__tmp_reg__
 461               	 ;  0 "" 2
 462               	/* #NOAPP */
 463               	.LBB2:
2181:../../Source/queue.c **** 
 465               	.LM31:
 466 00ec 1E8D      		ldd r17,Y+30
2234:../../Source/queue.c **** 					{
 468               	.LM32:
 469 00ee 7C01      		movw r14,r24
 470 00f0 81E1      		ldi r24,17
 471 00f2 E80E      		add r14,r24
 472 00f4 F11C      		adc r15,__zero_reg__
 473               	.L21:
2184:../../Source/queue.c **** 		{
 475               	.LM33:
 476 00f6 1116      		cp __zero_reg__,r17
 477 00f8 04F4      		brge .L22
2232:../../Source/queue.c **** 				{
 479               	.LM34:
 480 00fa 8989      		ldd r24,Y+17
 481 00fc 8823      		tst r24
 482 00fe 01F0      		breq .L22
2234:../../Source/queue.c **** 					{
 484               	.LM35:
 485 0100 C701      		movw r24,r14
 486 0102 0E94 0000 		call xTaskRemoveFromEventList
 487 0106 8111      		cpse r24,__zero_reg__
2238:../../Source/queue.c **** 					}
 489               	.LM36:
 490 0108 0E94 0000 		call vTaskMissedYield
 491               	.L23:
 492 010c 1150      		subi r17,lo8(-(-1))
 493 010e 00C0      		rjmp .L21
 494               	.L22:
2255:../../Source/queue.c **** 	}
 496               	.LM37:
 497 0110 8FEF      		ldi r24,lo8(-1)
 498 0112 8E8F      		std Y+30,r24
 499               	.LBE2:
2257:../../Source/queue.c **** 
 501               	.LM38:
 502               	/* #APP */
 503               	 ;  2257 "../../Source/queue.c" 1
 504 0114 0F90      		pop		__tmp_reg__
 505               	 ;  0 "" 2
 506               	 ;  2257 "../../Source/queue.c" 1
 507 0116 0FBE      		out		__SREG__, __tmp_reg__
 508               	 ;  0 "" 2
2260:../../Source/queue.c **** 	{
 510               	.LM39:
 511               	 ;  2260 "../../Source/queue.c" 1
 512 0118 0FB6      		in		__tmp_reg__, __SREG__
 513               	 ;  0 "" 2
 514               	 ;  2260 "../../Source/queue.c" 1
 515 011a F894      		cli
 516               	 ;  0 "" 2
 517               	 ;  2260 "../../Source/queue.c" 1
 518 011c 0F92      		push	__tmp_reg__
 519               	 ;  0 "" 2
 520               	/* #NOAPP */
 521               	.LBB3:
2262:../../Source/queue.c **** 
 523               	.LM40:
 524 011e 1D8D      		ldd r17,Y+29
2268:../../Source/queue.c **** 				{
 526               	.LM41:
 527 0120 7E01      		movw r14,r28
 528 0122 88E0      		ldi r24,8
 529 0124 E80E      		add r14,r24
 530 0126 F11C      		adc r15,__zero_reg__
 531               	.L25:
2264:../../Source/queue.c **** 		{
 533               	.LM42:
 534 0128 1116      		cp __zero_reg__,r17
 535 012a 04F4      		brge .L26
2266:../../Source/queue.c **** 			{
 537               	.LM43:
 538 012c 8885      		ldd r24,Y+8
 539 012e 8823      		tst r24
 540 0130 01F0      		breq .L26
2268:../../Source/queue.c **** 				{
 542               	.LM44:
 543 0132 C701      		movw r24,r14
 544 0134 0E94 0000 		call xTaskRemoveFromEventList
 545 0138 8111      		cpse r24,__zero_reg__
2270:../../Source/queue.c **** 				}
 547               	.LM45:
 548 013a 0E94 0000 		call vTaskMissedYield
 549               	.L27:
 550 013e 1150      		subi r17,lo8(-(-1))
 551 0140 00C0      		rjmp .L25
 552               	.L26:
2285:../../Source/queue.c **** 	}
 554               	.LM46:
 555 0142 8FEF      		ldi r24,lo8(-1)
 556 0144 8D8F      		std Y+29,r24
 557               	.LBE3:
2287:../../Source/queue.c **** }
 559               	.LM47:
 560               	/* #APP */
 561               	 ;  2287 "../../Source/queue.c" 1
 562 0146 0F90      		pop		__tmp_reg__
 563               	 ;  0 "" 2
 564               	 ;  2287 "../../Source/queue.c" 1
 565 0148 0FBE      		out		__SREG__, __tmp_reg__
 566               	 ;  0 "" 2
 567               	/* epilogue start */
2288:../../Source/queue.c **** /*-----------------------------------------------------------*/
 569               	.LM48:
 570               	/* #NOAPP */
 571 014a DF91      		pop r29
 572 014c CF91      		pop r28
 573 014e 1F91      		pop r17
 574 0150 FF90      		pop r15
 575 0152 EF90      		pop r14
 576 0154 0895      		ret
 584               	.Lscope4:
 586               		.stabd	78,0,0
 590               	.global	xQueueGenericReset
 592               	xQueueGenericReset:
 593               		.stabd	46,0,0
 256:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
 595               	.LM49:
 596               	.LFBB5:
 597 0156 CF93      		push r28
 598 0158 DF93      		push r29
 599               	/* prologue: function */
 600               	/* frame size = 0 */
 601               	/* stack size = 2 */
 602               	.L__stack_usage = 2
 603 015a EC01      		movw r28,r24
 261:../../Source/queue.c **** 	{
 605               	.LM50:
 606               	/* #APP */
 607               	 ;  261 "../../Source/queue.c" 1
 608 015c 0FB6      		in		__tmp_reg__, __SREG__
 609               	 ;  0 "" 2
 610               	 ;  261 "../../Source/queue.c" 1
 611 015e F894      		cli
 612               	 ;  0 "" 2
 613               	 ;  261 "../../Source/queue.c" 1
 614 0160 0F92      		push	__tmp_reg__
 615               	 ;  0 "" 2
 263:../../Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 617               	.LM51:
 618               	/* #NOAPP */
 619 0162 4881      		ld r20,Y
 620 0164 5981      		ldd r21,Y+1
 621 0166 8B8D      		ldd r24,Y+27
 622 0168 7C8D      		ldd r23,Y+28
 623 016a 9A01      		movw r18,r20
 624 016c 879F      		mul r24,r23
 625 016e 200D      		add r18,r0
 626 0170 311D      		adc r19,r1
 627 0172 1124      		clr __zero_reg__
 628 0174 3D83      		std Y+5,r19
 629 0176 2C83      		std Y+4,r18
 264:../../Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 631               	.LM52:
 632 0178 1A8E      		std Y+26,__zero_reg__
 265:../../Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
 634               	.LM53:
 635 017a 5B83      		std Y+3,r21
 636 017c 4A83      		std Y+2,r20
 266:../../Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 638               	.LM54:
 639 017e 90E0      		ldi r25,0
 640 0180 0197      		sbiw r24,1
 641 0182 789F      		mul r23,r24
 642 0184 9001      		movw r18,r0
 643 0186 799F      		mul r23,r25
 644 0188 300D      		add r19,r0
 645 018a 1124      		clr __zero_reg__
 646 018c CA01      		movw r24,r20
 647 018e 820F      		add r24,r18
 648 0190 931F      		adc r25,r19
 649 0192 9F83      		std Y+7,r25
 650 0194 8E83      		std Y+6,r24
 267:../../Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 652               	.LM55:
 653 0196 8FEF      		ldi r24,lo8(-1)
 654 0198 8D8F      		std Y+29,r24
 268:../../Source/queue.c **** 
 656               	.LM56:
 657 019a 8E8F      		std Y+30,r24
 270:../../Source/queue.c **** 		{
 659               	.LM57:
 660 019c 6111      		cpse r22,__zero_reg__
 661 019e 00C0      		rjmp .L42
 277:../../Source/queue.c **** 			{
 663               	.LM58:
 664 01a0 8885      		ldd r24,Y+8
 665 01a2 8823      		tst r24
 666 01a4 01F0      		breq .L44
 279:../../Source/queue.c **** 				{
 668               	.LM59:
 669 01a6 CE01      		movw r24,r28
 670 01a8 0896      		adiw r24,8
 671 01aa 0E94 0000 		call xTaskRemoveFromEventList
 672 01ae 8823      		tst r24
 673 01b0 01F0      		breq .L44
 281:../../Source/queue.c **** 				}
 675               	.LM60:
 676 01b2 0E94 0000 		call vPortYield
 677 01b6 00C0      		rjmp .L44
 678               	.L42:
 296:../../Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 680               	.LM61:
 681 01b8 CE01      		movw r24,r28
 682 01ba 0896      		adiw r24,8
 683 01bc 0E94 0000 		call vListInitialise
 297:../../Source/queue.c **** 		}
 685               	.LM62:
 686 01c0 CE01      		movw r24,r28
 687 01c2 4196      		adiw r24,17
 688 01c4 0E94 0000 		call vListInitialise
 689               	.L44:
 300:../../Source/queue.c **** 
 691               	.LM63:
 692               	/* #APP */
 693               	 ;  300 "../../Source/queue.c" 1
 694 01c8 0F90      		pop		__tmp_reg__
 695               	 ;  0 "" 2
 696               	 ;  300 "../../Source/queue.c" 1
 697 01ca 0FBE      		out		__SREG__, __tmp_reg__
 698               	 ;  0 "" 2
 305:../../Source/queue.c **** /*-----------------------------------------------------------*/
 700               	.LM64:
 701               	/* #NOAPP */
 702 01cc 81E0      		ldi r24,lo8(1)
 703               	/* epilogue start */
 704 01ce DF91      		pop r29
 705 01d0 CF91      		pop r28
 706 01d2 0895      		ret
 708               	.Lscope5:
 710               		.stabd	78,0,0
 715               	.global	xQueueGenericCreate
 717               	xQueueGenericCreate:
 718               		.stabd	46,0,0
 369:../../Source/queue.c **** 	Queue_t *pxNewQueue;
 720               	.LM65:
 721               	.LFBB6:
 722 01d4 0F93      		push r16
 723 01d6 1F93      		push r17
 724 01d8 CF93      		push r28
 725 01da DF93      		push r29
 726               	/* prologue: function */
 727               	/* frame size = 0 */
 728               	/* stack size = 4 */
 729               	.L__stack_usage = 4
 730 01dc 082F      		mov r16,r24
 731 01de 162F      		mov r17,r22
 390:../../Source/queue.c **** 
 733               	.LM66:
 734 01e0 869F      		mul r24,r22
 735 01e2 C001      		movw r24,r0
 736 01e4 1124      		clr __zero_reg__
 737 01e6 4F96      		adiw r24,31
 738 01e8 0E94 0000 		call pvPortMalloc
 739 01ec EC01      		movw r28,r24
 392:../../Source/queue.c **** 		{
 741               	.LM67:
 742 01ee 0097      		sbiw r24,0
 743 01f0 01F0      		breq .L50
 744               	.LBB6:
 745               	.LBB7:
 428:../../Source/queue.c **** 	{
 747               	.LM68:
 748 01f2 1111      		cpse r17,__zero_reg__
 749 01f4 00C0      		rjmp .L51
 434:../../Source/queue.c **** 	}
 751               	.LM69:
 752 01f6 9983      		std Y+1,r25
 753 01f8 8883      		st Y,r24
 754 01fa 00C0      		rjmp .L52
 755               	.L51:
 439:../../Source/queue.c **** 	}
 757               	.LM70:
 758 01fc 4F96      		adiw r24,31
 759 01fe 9983      		std Y+1,r25
 760 0200 8883      		st Y,r24
 761               	.L52:
 444:../../Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 763               	.LM71:
 764 0202 0B8F      		std Y+27,r16
 445:../../Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 766               	.LM72:
 767 0204 1C8F      		std Y+28,r17
 446:../../Source/queue.c **** 
 769               	.LM73:
 770 0206 61E0      		ldi r22,lo8(1)
 771 0208 CE01      		movw r24,r28
 772 020a 0E94 0000 		call xQueueGenericReset
 773               	.L50:
 774               	.LBE7:
 775               	.LBE6:
 417:../../Source/queue.c **** 
 777               	.LM74:
 778 020e CE01      		movw r24,r28
 779               	/* epilogue start */
 780 0210 DF91      		pop r29
 781 0212 CF91      		pop r28
 782 0214 1F91      		pop r17
 783 0216 0F91      		pop r16
 784 0218 0895      		ret
 786               	.Lscope6:
 788               		.stabd	78,0,0
 794               	.global	xQueueGenericSend
 796               	xQueueGenericSend:
 797               		.stabd	46,0,0
 741:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 799               	.LM75:
 800               	.LFBB7:
 801 021a AF92      		push r10
 802 021c BF92      		push r11
 803 021e CF92      		push r12
 804 0220 DF92      		push r13
 805 0222 FF92      		push r15
 806 0224 0F93      		push r16
 807 0226 1F93      		push r17
 808 0228 CF93      		push r28
 809 022a DF93      		push r29
 810 022c 00D0      		rcall .
 811 022e 00D0      		rcall .
 812 0230 1F92      		push __zero_reg__
 813 0232 CDB7      		in r28,__SP_L__
 814 0234 DEB7      		in r29,__SP_H__
 815               	/* prologue: function */
 816               	/* frame size = 5 */
 817               	/* stack size = 14 */
 818               	.L__stack_usage = 14
 819 0236 8C01      		movw r16,r24
 820 0238 6B01      		movw r12,r22
 821 023a 5D83      		std Y+5,r21
 822 023c 4C83      		std Y+4,r20
 823 023e F22E      		mov r15,r18
 742:../../Source/queue.c **** TimeOut_t xTimeOut;
 825               	.LM76:
 826 0240 80E0      		ldi r24,0
 911:../../Source/queue.c **** 
 828               	.LM77:
 829 0242 5801      		movw r10,r16
 830 0244 98E0      		ldi r25,8
 831 0246 A90E      		add r10,r25
 832 0248 B11C      		adc r11,__zero_reg__
 833               	.L57:
 761:../../Source/queue.c **** 		{
 835               	.LM78:
 836               	/* #APP */
 837               	 ;  761 "../../Source/queue.c" 1
 838 024a 0FB6      		in		__tmp_reg__, __SREG__
 839               	 ;  0 "" 2
 840               	 ;  761 "../../Source/queue.c" 1
 841 024c F894      		cli
 842               	 ;  0 "" 2
 843               	 ;  761 "../../Source/queue.c" 1
 844 024e 0F92      		push	__tmp_reg__
 845               	 ;  0 "" 2
 767:../../Source/queue.c **** 			{
 847               	.LM79:
 848               	/* #NOAPP */
 849 0250 F801      		movw r30,r16
 850 0252 228D      		ldd r18,Z+26
 851 0254 938D      		ldd r25,Z+27
 852 0256 2917      		cp r18,r25
 853 0258 00F0      		brlo .L58
 767:../../Source/queue.c **** 			{
 855               	.LM80:
 856 025a F2E0      		ldi r31,lo8(2)
 857 025c FF12      		cpse r15,r31
 858 025e 00C0      		rjmp .L59
 859               	.L58:
 833:../../Source/queue.c **** 
 861               	.LM81:
 862 0260 4F2D      		mov r20,r15
 863 0262 B601      		movw r22,r12
 864 0264 C801      		movw r24,r16
 865 0266 0E94 0000 		call prvCopyDataToQueue
 837:../../Source/queue.c **** 					{
 867               	.LM82:
 868 026a F801      		movw r30,r16
 869 026c 9189      		ldd r25,Z+17
 870 026e 9923      		tst r25
 871 0270 01F0      		breq .L72
 839:../../Source/queue.c **** 						{
 873               	.LM83:
 874 0272 C801      		movw r24,r16
 875 0274 4196      		adiw r24,17
 876 0276 0E94 0000 		call xTaskRemoveFromEventList
 877               	.L72:
 878 027a 8111      		cpse r24,__zero_reg__
 845:../../Source/queue.c **** 						}
 880               	.LM84:
 881 027c 0E94 0000 		call vPortYield
 882               	.L62:
 867:../../Source/queue.c **** 				return pdPASS;
 884               	.LM85:
 885               	/* #APP */
 886               	 ;  867 "../../Source/queue.c" 1
 887 0280 0F90      		pop		__tmp_reg__
 888               	 ;  0 "" 2
 889               	 ;  867 "../../Source/queue.c" 1
 890 0282 0FBE      		out		__SREG__, __tmp_reg__
 891               	 ;  0 "" 2
 868:../../Source/queue.c **** 			}
 893               	.LM86:
 894               	/* #NOAPP */
 895 0284 81E0      		ldi r24,lo8(1)
 896 0286 00C0      		rjmp .L64
 897               	.L59:
 872:../../Source/queue.c **** 				{
 899               	.LM87:
 900 0288 2C81      		ldd r18,Y+4
 901 028a 3D81      		ldd r19,Y+5
 902 028c 232B      		or r18,r19
 903 028e 01F4      		brne .L65
 876:../../Source/queue.c **** 
 905               	.LM88:
 906               	/* #APP */
 907               	 ;  876 "../../Source/queue.c" 1
 908 0290 0F90      		pop		__tmp_reg__
 909               	 ;  0 "" 2
 910               	 ;  876 "../../Source/queue.c" 1
 911 0292 0FBE      		out		__SREG__, __tmp_reg__
 912               	 ;  0 "" 2
 913               	/* #NOAPP */
 914 0294 00C0      		rjmp .L73
 915               	.L65:
 883:../../Source/queue.c **** 				{
 917               	.LM89:
 918 0296 8111      		cpse r24,__zero_reg__
 919 0298 00C0      		rjmp .L66
 887:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 921               	.LM90:
 922 029a CE01      		movw r24,r28
 923 029c 0196      		adiw r24,1
 924 029e 0E94 0000 		call vTaskInternalSetTimeOutState
 925               	.L66:
 897:../../Source/queue.c **** 
 927               	.LM91:
 928               	/* #APP */
 929               	 ;  897 "../../Source/queue.c" 1
 930 02a2 0F90      		pop		__tmp_reg__
 931               	 ;  0 "" 2
 932               	 ;  897 "../../Source/queue.c" 1
 933 02a4 0FBE      		out		__SREG__, __tmp_reg__
 934               	 ;  0 "" 2
 902:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 936               	.LM92:
 937               	/* #NOAPP */
 938 02a6 0E94 0000 		call vTaskSuspendAll
 903:../../Source/queue.c **** 
 940               	.LM93:
 941               	/* #APP */
 942               	 ;  903 "../../Source/queue.c" 1
 943 02aa 0FB6      		in		__tmp_reg__, __SREG__
 944               	 ;  0 "" 2
 945               	 ;  903 "../../Source/queue.c" 1
 946 02ac F894      		cli
 947               	 ;  0 "" 2
 948               	 ;  903 "../../Source/queue.c" 1
 949 02ae 0F92      		push	__tmp_reg__
 950               	 ;  0 "" 2
 951               	/* #NOAPP */
 952 02b0 F801      		movw r30,r16
 953 02b2 858D      		ldd r24,Z+29
 954 02b4 8F3F      		cpi r24,lo8(-1)
 955 02b6 01F4      		brne .L67
 903:../../Source/queue.c **** 
 957               	.LM94:
 958 02b8 158E      		std Z+29,__zero_reg__
 959               	.L67:
 903:../../Source/queue.c **** 
 961               	.LM95:
 962 02ba F801      		movw r30,r16
 963 02bc 868D      		ldd r24,Z+30
 964 02be 8F3F      		cpi r24,lo8(-1)
 965 02c0 01F4      		brne .L68
 903:../../Source/queue.c **** 
 967               	.LM96:
 968 02c2 168E      		std Z+30,__zero_reg__
 969               	.L68:
 903:../../Source/queue.c **** 
 971               	.LM97:
 972               	/* #APP */
 973               	 ;  903 "../../Source/queue.c" 1
 974 02c4 0F90      		pop		__tmp_reg__
 975               	 ;  0 "" 2
 976               	 ;  903 "../../Source/queue.c" 1
 977 02c6 0FBE      		out		__SREG__, __tmp_reg__
 978               	 ;  0 "" 2
 906:../../Source/queue.c **** 		{
 980               	.LM98:
 981               	/* #NOAPP */
 982 02c8 BE01      		movw r22,r28
 983 02ca 6C5F      		subi r22,-4
 984 02cc 7F4F      		sbci r23,-1
 985 02ce CE01      		movw r24,r28
 986 02d0 0196      		adiw r24,1
 987 02d2 0E94 0000 		call xTaskCheckForTimeOut
 988 02d6 8111      		cpse r24,__zero_reg__
 989 02d8 00C0      		rjmp .L69
 990               	.LBB10:
 991               	.LBB11:
2310:../../Source/queue.c **** /*-----------------------------------------------------------*/
2311:../../Source/queue.c **** 
2312:../../Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2313:../../Source/queue.c **** {
2314:../../Source/queue.c **** BaseType_t xReturn;
2315:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
2316:../../Source/queue.c **** 
2317:../../Source/queue.c **** 	configASSERT( pxQueue );
2318:../../Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2319:../../Source/queue.c **** 	{
2320:../../Source/queue.c **** 		xReturn = pdTRUE;
2321:../../Source/queue.c **** 	}
2322:../../Source/queue.c **** 	else
2323:../../Source/queue.c **** 	{
2324:../../Source/queue.c **** 		xReturn = pdFALSE;
2325:../../Source/queue.c **** 	}
2326:../../Source/queue.c **** 
2327:../../Source/queue.c **** 	return xReturn;
2328:../../Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2329:../../Source/queue.c **** /*-----------------------------------------------------------*/
2330:../../Source/queue.c **** 
2331:../../Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2332:../../Source/queue.c **** {
2333:../../Source/queue.c **** BaseType_t xReturn;
2334:../../Source/queue.c **** 
2335:../../Source/queue.c **** 	taskENTER_CRITICAL();
 993               	.LM99:
 994               	/* #APP */
 995               	 ;  2335 "../../Source/queue.c" 1
 996 02da 0FB6      		in		__tmp_reg__, __SREG__
 997               	 ;  0 "" 2
 998               	 ;  2335 "../../Source/queue.c" 1
 999 02dc F894      		cli
 1000               	 ;  0 "" 2
 1001               	 ;  2335 "../../Source/queue.c" 1
 1002 02de 0F92      		push	__tmp_reg__
 1003               	 ;  0 "" 2
2336:../../Source/queue.c **** 	{
2337:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1005               	.LM100:
 1006               	/* #NOAPP */
 1007 02e0 F801      		movw r30,r16
 1008 02e2 928D      		ldd r25,Z+26
2338:../../Source/queue.c **** 		{
2339:../../Source/queue.c **** 			xReturn = pdTRUE;
2340:../../Source/queue.c **** 		}
2341:../../Source/queue.c **** 		else
2342:../../Source/queue.c **** 		{
2343:../../Source/queue.c **** 			xReturn = pdFALSE;
2344:../../Source/queue.c **** 		}
2345:../../Source/queue.c **** 	}
2346:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 1010               	.LM101:
 1011               	/* #APP */
 1012               	 ;  2346 "../../Source/queue.c" 1
 1013 02e4 0F90      		pop		__tmp_reg__
 1014               	 ;  0 "" 2
 1015               	 ;  2346 "../../Source/queue.c" 1
 1016 02e6 0FBE      		out		__SREG__, __tmp_reg__
 1017               	 ;  0 "" 2
 1018               	/* #NOAPP */
 1019               	.LBE11:
 1020               	.LBE10:
 908:../../Source/queue.c **** 			{
 1022               	.LM102:
 1023 02e8 838D      		ldd r24,Z+27
 1024 02ea 9813      		cpse r25,r24
 1025 02ec 00C0      		rjmp .L70
 911:../../Source/queue.c **** 
 1027               	.LM103:
 1028 02ee 6C81      		ldd r22,Y+4
 1029 02f0 7D81      		ldd r23,Y+5
 1030 02f2 C501      		movw r24,r10
 1031 02f4 0E94 0000 		call vTaskPlaceOnEventList
 918:../../Source/queue.c **** 
 1033               	.LM104:
 1034 02f8 C801      		movw r24,r16
 1035 02fa 0E94 0000 		call prvUnlockQueue
 925:../../Source/queue.c **** 				{
 1037               	.LM105:
 1038 02fe 0E94 0000 		call xTaskResumeAll
 1039 0302 8823      		tst r24
 1040 0304 01F0      		breq .L74
 1041               	.L71:
 1042 0306 81E0      		ldi r24,lo8(1)
 1043 0308 00C0      		rjmp .L57
 1044               	.L74:
 927:../../Source/queue.c **** 				}
 1046               	.LM106:
 1047 030a 0E94 0000 		call vPortYield
 1048 030e 00C0      		rjmp .L71
 1049               	.L70:
 933:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 1051               	.LM107:
 1052 0310 C801      		movw r24,r16
 1053 0312 0E94 0000 		call prvUnlockQueue
 934:../../Source/queue.c **** 			}
 1055               	.LM108:
 1056 0316 0E94 0000 		call xTaskResumeAll
 1057 031a 00C0      		rjmp .L71
 1058               	.L69:
 940:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 1060               	.LM109:
 1061 031c C801      		movw r24,r16
 1062 031e 0E94 0000 		call prvUnlockQueue
 941:../../Source/queue.c **** 
 1064               	.LM110:
 1065 0322 0E94 0000 		call xTaskResumeAll
 1066               	.L73:
 944:../../Source/queue.c **** 		}
 1068               	.LM111:
 1069 0326 80E0      		ldi r24,0
 1070               	.L64:
 1071               	/* epilogue start */
 947:../../Source/queue.c **** /*-----------------------------------------------------------*/
 1073               	.LM112:
 1074 0328 0F90      		pop __tmp_reg__
 1075 032a 0F90      		pop __tmp_reg__
 1076 032c 0F90      		pop __tmp_reg__
 1077 032e 0F90      		pop __tmp_reg__
 1078 0330 0F90      		pop __tmp_reg__
 1079 0332 DF91      		pop r29
 1080 0334 CF91      		pop r28
 1081 0336 1F91      		pop r17
 1082 0338 0F91      		pop r16
 1083 033a FF90      		pop r15
 1084 033c DF90      		pop r13
 1085 033e CF90      		pop r12
 1086 0340 BF90      		pop r11
 1087 0342 AF90      		pop r10
 1088 0344 0895      		ret
 1095               	.Lscope7:
 1097               		.stabd	78,0,0
 1103               	.global	xQueueGenericSendFromISR
 1105               	xQueueGenericSendFromISR:
 1106               		.stabd	46,0,0
 951:../../Source/queue.c **** BaseType_t xReturn;
 1108               	.LM113:
 1109               	.LFBB8:
 1110 0346 EF92      		push r14
 1111 0348 FF92      		push r15
 1112 034a 1F93      		push r17
 1113 034c CF93      		push r28
 1114 034e DF93      		push r29
 1115               	/* prologue: function */
 1116               	/* frame size = 0 */
 1117               	/* stack size = 5 */
 1118               	.L__stack_usage = 5
 1119 0350 EC01      		movw r28,r24
 983:../../Source/queue.c **** 		{
 1121               	.LM114:
 1122 0352 9A8D      		ldd r25,Y+26
 1123 0354 8B8D      		ldd r24,Y+27
 1124 0356 9817      		cp r25,r24
 1125 0358 00F0      		brlo .L76
 983:../../Source/queue.c **** 		{
 1127               	.LM115:
 1128 035a 2230      		cpi r18,lo8(2)
 1129 035c 01F4      		brne .L81
 1130               	.L76:
 1131 035e 7A01      		movw r14,r20
 1132               	.LBB12:
 985:../../Source/queue.c **** 			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1134               	.LM116:
 1135 0360 1E8D      		ldd r17,Y+30
 986:../../Source/queue.c **** 
 1137               	.LM117:
 1138 0362 8A8D      		ldd r24,Y+26
 995:../../Source/queue.c **** 
 1140               	.LM118:
 1141 0364 422F      		mov r20,r18
 1142 0366 CE01      		movw r24,r28
 1143 0368 0E94 0000 		call prvCopyDataToQueue
 999:../../Source/queue.c **** 			{
 1145               	.LM119:
 1146 036c 1F3F      		cpi r17,lo8(-1)
 1147 036e 01F4      		brne .L78
1061:../../Source/queue.c **** 					{
 1149               	.LM120:
 1150 0370 8989      		ldd r24,Y+17
 1151 0372 8823      		tst r24
 1152 0374 01F0      		breq .L88
1063:../../Source/queue.c **** 						{
 1154               	.LM121:
 1155 0376 CE01      		movw r24,r28
 1156 0378 4196      		adiw r24,17
 1157 037a 0E94 0000 		call xTaskRemoveFromEventList
 1158 037e 8823      		tst r24
 1159 0380 01F0      		breq .L88
1067:../../Source/queue.c **** 							{
 1161               	.LM122:
 1162 0382 E114      		cp r14,__zero_reg__
 1163 0384 F104      		cpc r15,__zero_reg__
 1164 0386 01F0      		breq .L88
1069:../../Source/queue.c **** 							}
 1166               	.LM123:
 1167 0388 81E0      		ldi r24,lo8(1)
 1168 038a F701      		movw r30,r14
 1169 038c 8083      		st Z,r24
 1170 038e 00C0      		rjmp .L77
 1171               	.L78:
1095:../../Source/queue.c **** 			}
 1173               	.LM124:
 1174 0390 1F5F      		subi r17,lo8(-(1))
 1175 0392 1E8F      		std Y+30,r17
 1176               	.L88:
1098:../../Source/queue.c **** 		}
 1178               	.LM125:
 1179 0394 81E0      		ldi r24,lo8(1)
 1180 0396 00C0      		rjmp .L77
 1181               	.L81:
 1182               	.LBE12:
1103:../../Source/queue.c **** 		}
 1184               	.LM126:
 1185 0398 80E0      		ldi r24,0
 1186               	.L77:
 1187               	/* epilogue start */
1109:../../Source/queue.c **** /*-----------------------------------------------------------*/
 1189               	.LM127:
 1190 039a DF91      		pop r29
 1191 039c CF91      		pop r28
 1192 039e 1F91      		pop r17
 1193 03a0 FF90      		pop r15
 1194 03a2 EF90      		pop r14
 1195 03a4 0895      		ret
 1204               	.Lscope8:
 1206               		.stabd	78,0,0
 1210               	.global	xQueueGiveFromISR
 1212               	xQueueGiveFromISR:
 1213               		.stabd	46,0,0
1113:../../Source/queue.c **** BaseType_t xReturn;
 1215               	.LM128:
 1216               	.LFBB9:
 1217 03a6 CF93      		push r28
 1218 03a8 DF93      		push r29
 1219               	/* prologue: function */
 1220               	/* frame size = 0 */
 1221               	/* stack size = 2 */
 1222               	.L__stack_usage = 2
 1223 03aa FC01      		movw r30,r24
 1224               	.LBB13:
1153:../../Source/queue.c **** 
 1226               	.LM129:
 1227 03ac 928D      		ldd r25,Z+26
1158:../../Source/queue.c **** 		{
 1229               	.LM130:
 1230 03ae 838D      		ldd r24,Z+27
 1231 03b0 9817      		cp r25,r24
 1232 03b2 00F4      		brsh .L94
 1233               	.LBB14:
1160:../../Source/queue.c **** 
 1235               	.LM131:
 1236 03b4 868D      		ldd r24,Z+30
1170:../../Source/queue.c **** 
 1238               	.LM132:
 1239 03b6 9F5F      		subi r25,lo8(-(1))
 1240 03b8 928F      		std Z+26,r25
1174:../../Source/queue.c **** 			{
 1242               	.LM133:
 1243 03ba 8F3F      		cpi r24,lo8(-1)
 1244 03bc 01F4      		brne .L91
1229:../../Source/queue.c **** 					{
 1246               	.LM134:
 1247 03be 8189      		ldd r24,Z+17
 1248 03c0 8823      		tst r24
 1249 03c2 01F0      		breq .L101
 1250 03c4 EB01      		movw r28,r22
 1251 03c6 CF01      		movw r24,r30
1231:../../Source/queue.c **** 						{
 1253               	.LM135:
 1254 03c8 4196      		adiw r24,17
 1255 03ca 0E94 0000 		call xTaskRemoveFromEventList
 1256 03ce 8823      		tst r24
 1257 03d0 01F0      		breq .L101
1235:../../Source/queue.c **** 							{
 1259               	.LM136:
 1260 03d2 2097      		sbiw r28,0
 1261 03d4 01F0      		breq .L101
1237:../../Source/queue.c **** 							}
 1263               	.LM137:
 1264 03d6 81E0      		ldi r24,lo8(1)
 1265 03d8 8883      		st Y,r24
 1266 03da 00C0      		rjmp .L90
 1267               	.L91:
1260:../../Source/queue.c **** 			}
 1269               	.LM138:
 1270 03dc 8F5F      		subi r24,lo8(-(1))
 1271 03de 868F      		std Z+30,r24
 1272               	.L101:
1263:../../Source/queue.c **** 		}
 1274               	.LM139:
 1275 03e0 81E0      		ldi r24,lo8(1)
 1276 03e2 00C0      		rjmp .L90
 1277               	.L94:
 1278               	.LBE14:
1268:../../Source/queue.c **** 		}
 1280               	.LM140:
 1281 03e4 80E0      		ldi r24,0
 1282               	.L90:
 1283               	/* epilogue start */
 1284               	.LBE13:
1274:../../Source/queue.c **** /*-----------------------------------------------------------*/
 1286               	.LM141:
 1287 03e6 DF91      		pop r29
 1288 03e8 CF91      		pop r28
 1289 03ea 0895      		ret
 1300               	.Lscope9:
 1302               		.stabd	78,0,0
 1307               	.global	xQueueReceive
 1309               	xQueueReceive:
 1310               		.stabd	46,0,0
1278:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1312               	.LM142:
 1313               	.LFBB10:
 1314 03ec AF92      		push r10
 1315 03ee BF92      		push r11
 1316 03f0 CF92      		push r12
 1317 03f2 DF92      		push r13
 1318 03f4 FF92      		push r15
 1319 03f6 0F93      		push r16
 1320 03f8 1F93      		push r17
 1321 03fa CF93      		push r28
 1322 03fc DF93      		push r29
 1323 03fe 00D0      		rcall .
 1324 0400 00D0      		rcall .
 1325 0402 1F92      		push __zero_reg__
 1326 0404 CDB7      		in r28,__SP_L__
 1327 0406 DEB7      		in r29,__SP_H__
 1328               	/* prologue: function */
 1329               	/* frame size = 5 */
 1330               	/* stack size = 14 */
 1331               	.L__stack_usage = 14
 1332 0408 8C01      		movw r16,r24
 1333 040a 6B01      		movw r12,r22
 1334 040c 5D83      		std Y+5,r21
 1335 040e 4C83      		std Y+4,r20
1279:../../Source/queue.c **** TimeOut_t xTimeOut;
 1337               	.LM143:
 1338 0410 80E0      		ldi r24,0
1378:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1340               	.LM144:
 1341 0412 5801      		movw r10,r16
 1342 0414 91E1      		ldi r25,17
 1343 0416 A90E      		add r10,r25
 1344 0418 B11C      		adc r11,__zero_reg__
 1345               	.L103:
1303:../../Source/queue.c **** 		{
 1347               	.LM145:
 1348               	/* #APP */
 1349               	 ;  1303 "../../Source/queue.c" 1
 1350 041a 0FB6      		in		__tmp_reg__, __SREG__
 1351               	 ;  0 "" 2
 1352               	 ;  1303 "../../Source/queue.c" 1
 1353 041c F894      		cli
 1354               	 ;  0 "" 2
 1355               	 ;  1303 "../../Source/queue.c" 1
 1356 041e 0F92      		push	__tmp_reg__
 1357               	 ;  0 "" 2
 1358               	/* #NOAPP */
 1359               	.LBB15:
1305:../../Source/queue.c **** 
 1361               	.LM146:
 1362 0420 F801      		movw r30,r16
 1363 0422 F28C      		ldd r15,Z+26
1309:../../Source/queue.c **** 			{
 1365               	.LM147:
 1366 0424 FF20      		tst r15
 1367 0426 01F0      		breq .L104
1312:../../Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
 1369               	.LM148:
 1370 0428 B601      		movw r22,r12
 1371 042a C801      		movw r24,r16
 1372 042c 0E94 0000 		call prvCopyDataFromQueue
1314:../../Source/queue.c **** 
 1374               	.LM149:
 1375 0430 FA94      		dec r15
 1376 0432 F801      		movw r30,r16
 1377 0434 F28E      		std Z+26,r15
1319:../../Source/queue.c **** 				{
 1379               	.LM150:
 1380 0436 8085      		ldd r24,Z+8
 1381 0438 8823      		tst r24
 1382 043a 01F0      		breq .L106
1321:../../Source/queue.c **** 					{
 1384               	.LM151:
 1385 043c C801      		movw r24,r16
 1386 043e 0896      		adiw r24,8
 1387 0440 0E94 0000 		call xTaskRemoveFromEventList
 1388 0444 8111      		cpse r24,__zero_reg__
1323:../../Source/queue.c **** 					}
 1390               	.LM152:
 1391 0446 0E94 0000 		call vPortYield
 1392               	.L106:
1335:../../Source/queue.c **** 				return pdPASS;
 1394               	.LM153:
 1395               	/* #APP */
 1396               	 ;  1335 "../../Source/queue.c" 1
 1397 044a 0F90      		pop		__tmp_reg__
 1398               	 ;  0 "" 2
 1399               	 ;  1335 "../../Source/queue.c" 1
 1400 044c 0FBE      		out		__SREG__, __tmp_reg__
 1401               	 ;  0 "" 2
1336:../../Source/queue.c **** 			}
 1403               	.LM154:
 1404               	/* #NOAPP */
 1405 044e 81E0      		ldi r24,lo8(1)
 1406 0450 00C0      		rjmp .L108
 1407               	.L104:
1340:../../Source/queue.c **** 				{
 1409               	.LM155:
 1410 0452 2C81      		ldd r18,Y+4
 1411 0454 3D81      		ldd r19,Y+5
 1412 0456 232B      		or r18,r19
 1413 0458 01F4      		brne .L109
1344:../../Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1415               	.LM156:
 1416               	/* #APP */
 1417               	 ;  1344 "../../Source/queue.c" 1
 1418 045a 0F90      		pop		__tmp_reg__
 1419               	 ;  0 "" 2
 1420               	 ;  1344 "../../Source/queue.c" 1
 1421 045c 0FBE      		out		__SREG__, __tmp_reg__
 1422               	 ;  0 "" 2
 1423               	/* #NOAPP */
 1424 045e 00C0      		rjmp .L123
 1425               	.L109:
1348:../../Source/queue.c **** 				{
 1427               	.LM157:
 1428 0460 8111      		cpse r24,__zero_reg__
 1429 0462 00C0      		rjmp .L110
1352:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1431               	.LM158:
 1432 0464 CE01      		movw r24,r28
 1433 0466 0196      		adiw r24,1
 1434 0468 0E94 0000 		call vTaskInternalSetTimeOutState
 1435               	.L110:
 1436               	.LBE15:
1362:../../Source/queue.c **** 
 1438               	.LM159:
 1439               	/* #APP */
 1440               	 ;  1362 "../../Source/queue.c" 1
 1441 046c 0F90      		pop		__tmp_reg__
 1442               	 ;  0 "" 2
 1443               	 ;  1362 "../../Source/queue.c" 1
 1444 046e 0FBE      		out		__SREG__, __tmp_reg__
 1445               	 ;  0 "" 2
1367:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 1447               	.LM160:
 1448               	/* #NOAPP */
 1449 0470 0E94 0000 		call vTaskSuspendAll
1368:../../Source/queue.c **** 
 1451               	.LM161:
 1452               	/* #APP */
 1453               	 ;  1368 "../../Source/queue.c" 1
 1454 0474 0FB6      		in		__tmp_reg__, __SREG__
 1455               	 ;  0 "" 2
 1456               	 ;  1368 "../../Source/queue.c" 1
 1457 0476 F894      		cli
 1458               	 ;  0 "" 2
 1459               	 ;  1368 "../../Source/queue.c" 1
 1460 0478 0F92      		push	__tmp_reg__
 1461               	 ;  0 "" 2
 1462               	/* #NOAPP */
 1463 047a F801      		movw r30,r16
 1464 047c 858D      		ldd r24,Z+29
 1465 047e 8F3F      		cpi r24,lo8(-1)
 1466 0480 01F4      		brne .L111
1368:../../Source/queue.c **** 
 1468               	.LM162:
 1469 0482 158E      		std Z+29,__zero_reg__
 1470               	.L111:
1368:../../Source/queue.c **** 
 1472               	.LM163:
 1473 0484 F801      		movw r30,r16
 1474 0486 868D      		ldd r24,Z+30
 1475 0488 8F3F      		cpi r24,lo8(-1)
 1476 048a 01F4      		brne .L112
1368:../../Source/queue.c **** 
 1478               	.LM164:
 1479 048c 168E      		std Z+30,__zero_reg__
 1480               	.L112:
1368:../../Source/queue.c **** 
 1482               	.LM165:
 1483               	/* #APP */
 1484               	 ;  1368 "../../Source/queue.c" 1
 1485 048e 0F90      		pop		__tmp_reg__
 1486               	 ;  0 "" 2
 1487               	 ;  1368 "../../Source/queue.c" 1
 1488 0490 0FBE      		out		__SREG__, __tmp_reg__
 1489               	 ;  0 "" 2
1371:../../Source/queue.c **** 		{
 1491               	.LM166:
 1492               	/* #NOAPP */
 1493 0492 BE01      		movw r22,r28
 1494 0494 6C5F      		subi r22,-4
 1495 0496 7F4F      		sbci r23,-1
 1496 0498 CE01      		movw r24,r28
 1497 049a 0196      		adiw r24,1
 1498 049c 0E94 0000 		call xTaskCheckForTimeOut
 1499 04a0 8111      		cpse r24,__zero_reg__
 1500 04a2 00C0      		rjmp .L113
1375:../../Source/queue.c **** 			{
 1502               	.LM167:
 1503 04a4 C801      		movw r24,r16
 1504 04a6 0E94 0000 		call prvIsQueueEmpty
 1505 04aa 8823      		tst r24
 1506 04ac 01F0      		breq .L114
1378:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1508               	.LM168:
 1509 04ae 6C81      		ldd r22,Y+4
 1510 04b0 7D81      		ldd r23,Y+5
 1511 04b2 C501      		movw r24,r10
 1512 04b4 0E94 0000 		call vTaskPlaceOnEventList
1379:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1514               	.LM169:
 1515 04b8 C801      		movw r24,r16
 1516 04ba 0E94 0000 		call prvUnlockQueue
1380:../../Source/queue.c **** 				{
 1518               	.LM170:
 1519 04be 0E94 0000 		call xTaskResumeAll
 1520 04c2 8823      		tst r24
 1521 04c4 01F0      		breq .L124
 1522               	.L116:
 1523 04c6 81E0      		ldi r24,lo8(1)
 1524 04c8 00C0      		rjmp .L103
 1525               	.L124:
1382:../../Source/queue.c **** 				}
 1527               	.LM171:
 1528 04ca 0E94 0000 		call vPortYield
 1529 04ce 00C0      		rjmp .L116
 1530               	.L114:
1393:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 1532               	.LM172:
 1533 04d0 C801      		movw r24,r16
 1534 04d2 0E94 0000 		call prvUnlockQueue
1394:../../Source/queue.c **** 			}
 1536               	.LM173:
 1537 04d6 0E94 0000 		call xTaskResumeAll
 1538 04da 00C0      		rjmp .L116
 1539               	.L113:
1401:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 1541               	.LM174:
 1542 04dc C801      		movw r24,r16
 1543 04de 0E94 0000 		call prvUnlockQueue
1402:../../Source/queue.c **** 
 1545               	.LM175:
 1546 04e2 0E94 0000 		call xTaskResumeAll
1404:../../Source/queue.c **** 			{
 1548               	.LM176:
 1549 04e6 C801      		movw r24,r16
 1550 04e8 0E94 0000 		call prvIsQueueEmpty
 1551 04ec 8823      		tst r24
 1552 04ee 01F0      		breq .L116
 1553               	.L123:
1407:../../Source/queue.c **** 			}
 1555               	.LM177:
 1556 04f0 80E0      		ldi r24,0
 1557               	.L108:
 1558               	/* epilogue start */
1415:../../Source/queue.c **** /*-----------------------------------------------------------*/
 1560               	.LM178:
 1561 04f2 0F90      		pop __tmp_reg__
 1562 04f4 0F90      		pop __tmp_reg__
 1563 04f6 0F90      		pop __tmp_reg__
 1564 04f8 0F90      		pop __tmp_reg__
 1565 04fa 0F90      		pop __tmp_reg__
 1566 04fc DF91      		pop r29
 1567 04fe CF91      		pop r28
 1568 0500 1F91      		pop r17
 1569 0502 0F91      		pop r16
 1570 0504 FF90      		pop r15
 1571 0506 DF90      		pop r13
 1572 0508 CF90      		pop r12
 1573 050a BF90      		pop r11
 1574 050c AF90      		pop r10
 1575 050e 0895      		ret
 1584               	.Lscope10:
 1586               		.stabd	78,0,0
 1590               	.global	xQueueSemaphoreTake
 1592               	xQueueSemaphoreTake:
 1593               		.stabd	46,0,0
1419:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1595               	.LM179:
 1596               	.LFBB11:
 1597 0510 EF92      		push r14
 1598 0512 FF92      		push r15
 1599 0514 0F93      		push r16
 1600 0516 1F93      		push r17
 1601 0518 CF93      		push r28
 1602 051a DF93      		push r29
 1603 051c 00D0      		rcall .
 1604 051e 00D0      		rcall .
 1605 0520 1F92      		push __zero_reg__
 1606 0522 CDB7      		in r28,__SP_L__
 1607 0524 DEB7      		in r29,__SP_H__
 1608               	/* prologue: function */
 1609               	/* frame size = 5 */
 1610               	/* stack size = 11 */
 1611               	.L__stack_usage = 11
 1612 0526 8C01      		movw r16,r24
 1613 0528 7D83      		std Y+5,r23
 1614 052a 6C83      		std Y+4,r22
1420:../../Source/queue.c **** TimeOut_t xTimeOut;
 1616               	.LM180:
 1617 052c 90E0      		ldi r25,0
1569:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1619               	.LM181:
 1620 052e 7801      		movw r14,r16
 1621 0530 81E1      		ldi r24,17
 1622 0532 E80E      		add r14,r24
 1623 0534 F11C      		adc r15,__zero_reg__
 1624               	.L126:
1448:../../Source/queue.c **** 		{
 1626               	.LM182:
 1627               	/* #APP */
 1628               	 ;  1448 "../../Source/queue.c" 1
 1629 0536 0FB6      		in		__tmp_reg__, __SREG__
 1630               	 ;  0 "" 2
 1631               	 ;  1448 "../../Source/queue.c" 1
 1632 0538 F894      		cli
 1633               	 ;  0 "" 2
 1634               	 ;  1448 "../../Source/queue.c" 1
 1635 053a 0F92      		push	__tmp_reg__
 1636               	 ;  0 "" 2
 1637               	/* #NOAPP */
 1638               	.LBB16:
1452:../../Source/queue.c **** 
 1640               	.LM183:
 1641 053c F801      		movw r30,r16
 1642 053e 828D      		ldd r24,Z+26
1456:../../Source/queue.c **** 			{
 1644               	.LM184:
 1645 0540 8823      		tst r24
 1646 0542 01F0      		breq .L127
1462:../../Source/queue.c **** 
 1648               	.LM185:
 1649 0544 8150      		subi r24,lo8(-(-1))
 1650 0546 828F      		std Z+26,r24
1481:../../Source/queue.c **** 				{
 1652               	.LM186:
 1653 0548 8085      		ldd r24,Z+8
 1654 054a 8823      		tst r24
 1655 054c 01F0      		breq .L129
1483:../../Source/queue.c **** 					{
 1657               	.LM187:
 1658 054e C801      		movw r24,r16
 1659 0550 0896      		adiw r24,8
 1660 0552 0E94 0000 		call xTaskRemoveFromEventList
 1661 0556 8111      		cpse r24,__zero_reg__
1485:../../Source/queue.c **** 					}
 1663               	.LM188:
 1664 0558 0E94 0000 		call vPortYield
 1665               	.L129:
1497:../../Source/queue.c **** 				return pdPASS;
 1667               	.LM189:
 1668               	/* #APP */
 1669               	 ;  1497 "../../Source/queue.c" 1
 1670 055c 0F90      		pop		__tmp_reg__
 1671               	 ;  0 "" 2
 1672               	 ;  1497 "../../Source/queue.c" 1
 1673 055e 0FBE      		out		__SREG__, __tmp_reg__
 1674               	 ;  0 "" 2
1498:../../Source/queue.c **** 			}
 1676               	.LM190:
 1677               	/* #NOAPP */
 1678 0560 81E0      		ldi r24,lo8(1)
 1679 0562 00C0      		rjmp .L131
 1680               	.L127:
1502:../../Source/queue.c **** 				{
 1682               	.LM191:
 1683 0564 2C81      		ldd r18,Y+4
 1684 0566 3D81      		ldd r19,Y+5
 1685 0568 232B      		or r18,r19
 1686 056a 01F4      		brne .L132
1515:../../Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1688               	.LM192:
 1689               	/* #APP */
 1690               	 ;  1515 "../../Source/queue.c" 1
 1691 056c 0F90      		pop		__tmp_reg__
 1692               	 ;  0 "" 2
 1693               	 ;  1515 "../../Source/queue.c" 1
 1694 056e 0FBE      		out		__SREG__, __tmp_reg__
 1695               	 ;  0 "" 2
 1696               	/* #NOAPP */
 1697 0570 00C0      		rjmp .L146
 1698               	.L132:
1519:../../Source/queue.c **** 				{
 1700               	.LM193:
 1701 0572 9111      		cpse r25,__zero_reg__
 1702 0574 00C0      		rjmp .L133
1523:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1704               	.LM194:
 1705 0576 CE01      		movw r24,r28
 1706 0578 0196      		adiw r24,1
 1707 057a 0E94 0000 		call vTaskInternalSetTimeOutState
 1708               	.L133:
 1709               	.LBE16:
1533:../../Source/queue.c **** 
 1711               	.LM195:
 1712               	/* #APP */
 1713               	 ;  1533 "../../Source/queue.c" 1
 1714 057e 0F90      		pop		__tmp_reg__
 1715               	 ;  0 "" 2
 1716               	 ;  1533 "../../Source/queue.c" 1
 1717 0580 0FBE      		out		__SREG__, __tmp_reg__
 1718               	 ;  0 "" 2
1538:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 1720               	.LM196:
 1721               	/* #NOAPP */
 1722 0582 0E94 0000 		call vTaskSuspendAll
1539:../../Source/queue.c **** 
 1724               	.LM197:
 1725               	/* #APP */
 1726               	 ;  1539 "../../Source/queue.c" 1
 1727 0586 0FB6      		in		__tmp_reg__, __SREG__
 1728               	 ;  0 "" 2
 1729               	 ;  1539 "../../Source/queue.c" 1
 1730 0588 F894      		cli
 1731               	 ;  0 "" 2
 1732               	 ;  1539 "../../Source/queue.c" 1
 1733 058a 0F92      		push	__tmp_reg__
 1734               	 ;  0 "" 2
 1735               	/* #NOAPP */
 1736 058c F801      		movw r30,r16
 1737 058e 858D      		ldd r24,Z+29
 1738 0590 8F3F      		cpi r24,lo8(-1)
 1739 0592 01F4      		brne .L134
1539:../../Source/queue.c **** 
 1741               	.LM198:
 1742 0594 158E      		std Z+29,__zero_reg__
 1743               	.L134:
1539:../../Source/queue.c **** 
 1745               	.LM199:
 1746 0596 F801      		movw r30,r16
 1747 0598 868D      		ldd r24,Z+30
 1748 059a 8F3F      		cpi r24,lo8(-1)
 1749 059c 01F4      		brne .L135
1539:../../Source/queue.c **** 
 1751               	.LM200:
 1752 059e 168E      		std Z+30,__zero_reg__
 1753               	.L135:
1539:../../Source/queue.c **** 
 1755               	.LM201:
 1756               	/* #APP */
 1757               	 ;  1539 "../../Source/queue.c" 1
 1758 05a0 0F90      		pop		__tmp_reg__
 1759               	 ;  0 "" 2
 1760               	 ;  1539 "../../Source/queue.c" 1
 1761 05a2 0FBE      		out		__SREG__, __tmp_reg__
 1762               	 ;  0 "" 2
1542:../../Source/queue.c **** 		{
 1764               	.LM202:
 1765               	/* #NOAPP */
 1766 05a4 BE01      		movw r22,r28
 1767 05a6 6C5F      		subi r22,-4
 1768 05a8 7F4F      		sbci r23,-1
 1769 05aa CE01      		movw r24,r28
 1770 05ac 0196      		adiw r24,1
 1771 05ae 0E94 0000 		call xTaskCheckForTimeOut
 1772 05b2 8111      		cpse r24,__zero_reg__
 1773 05b4 00C0      		rjmp .L136
1548:../../Source/queue.c **** 			{
 1775               	.LM203:
 1776 05b6 C801      		movw r24,r16
 1777 05b8 0E94 0000 		call prvIsQueueEmpty
 1778 05bc 8823      		tst r24
 1779 05be 01F0      		breq .L137
1569:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1781               	.LM204:
 1782 05c0 6C81      		ldd r22,Y+4
 1783 05c2 7D81      		ldd r23,Y+5
 1784 05c4 C701      		movw r24,r14
 1785 05c6 0E94 0000 		call vTaskPlaceOnEventList
1570:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1787               	.LM205:
 1788 05ca C801      		movw r24,r16
 1789 05cc 0E94 0000 		call prvUnlockQueue
1571:../../Source/queue.c **** 				{
 1791               	.LM206:
 1792 05d0 0E94 0000 		call xTaskResumeAll
 1793 05d4 8823      		tst r24
 1794 05d6 01F0      		breq .L147
 1795               	.L139:
 1796 05d8 91E0      		ldi r25,lo8(1)
 1797 05da 00C0      		rjmp .L126
 1798               	.L147:
1573:../../Source/queue.c **** 				}
 1800               	.LM207:
 1801 05dc 0E94 0000 		call vPortYield
 1802 05e0 00C0      		rjmp .L139
 1803               	.L137:
1584:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 1805               	.LM208:
 1806 05e2 C801      		movw r24,r16
 1807 05e4 0E94 0000 		call prvUnlockQueue
1585:../../Source/queue.c **** 			}
 1809               	.LM209:
 1810 05e8 0E94 0000 		call xTaskResumeAll
 1811 05ec 00C0      		rjmp .L139
 1812               	.L136:
1591:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 1814               	.LM210:
 1815 05ee C801      		movw r24,r16
 1816 05f0 0E94 0000 		call prvUnlockQueue
1592:../../Source/queue.c **** 
 1818               	.LM211:
 1819 05f4 0E94 0000 		call xTaskResumeAll
1598:../../Source/queue.c **** 			{
 1821               	.LM212:
 1822 05f8 C801      		movw r24,r16
 1823 05fa 0E94 0000 		call prvIsQueueEmpty
 1824 05fe 8823      		tst r24
 1825 0600 01F0      		breq .L139
 1826               	.L146:
1625:../../Source/queue.c **** 			}
 1828               	.LM213:
 1829 0602 80E0      		ldi r24,0
 1830               	.L131:
 1831               	/* epilogue start */
1633:../../Source/queue.c **** /*-----------------------------------------------------------*/
 1833               	.LM214:
 1834 0604 0F90      		pop __tmp_reg__
 1835 0606 0F90      		pop __tmp_reg__
 1836 0608 0F90      		pop __tmp_reg__
 1837 060a 0F90      		pop __tmp_reg__
 1838 060c 0F90      		pop __tmp_reg__
 1839 060e DF91      		pop r29
 1840 0610 CF91      		pop r28
 1841 0612 1F91      		pop r17
 1842 0614 0F91      		pop r16
 1843 0616 FF90      		pop r15
 1844 0618 EF90      		pop r14
 1845 061a 0895      		ret
 1854               	.Lscope11:
 1856               		.stabd	78,0,0
 1861               	.global	xQueuePeek
 1863               	xQueuePeek:
 1864               		.stabd	46,0,0
1637:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1866               	.LM215:
 1867               	.LFBB12:
 1868 061c CF92      		push r12
 1869 061e DF92      		push r13
 1870 0620 EF92      		push r14
 1871 0622 FF92      		push r15
 1872 0624 0F93      		push r16
 1873 0626 1F93      		push r17
 1874 0628 CF93      		push r28
 1875 062a DF93      		push r29
 1876 062c 00D0      		rcall .
 1877 062e 00D0      		rcall .
 1878 0630 1F92      		push __zero_reg__
 1879 0632 CDB7      		in r28,__SP_L__
 1880 0634 DEB7      		in r29,__SP_H__
 1881               	/* prologue: function */
 1882               	/* frame size = 5 */
 1883               	/* stack size = 13 */
 1884               	.L__stack_usage = 13
 1885 0636 8C01      		movw r16,r24
 1886 0638 7B01      		movw r14,r22
 1887 063a 5D83      		std Y+5,r21
 1888 063c 4C83      		std Y+4,r20
1638:../../Source/queue.c **** TimeOut_t xTimeOut;
 1890               	.LM216:
 1891 063e 80E0      		ldi r24,0
1745:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1893               	.LM217:
 1894 0640 6801      		movw r12,r16
 1895 0642 91E1      		ldi r25,17
 1896 0644 C90E      		add r12,r25
 1897 0646 D11C      		adc r13,__zero_reg__
 1898               	.L149:
1663:../../Source/queue.c **** 		{
 1900               	.LM218:
 1901               	/* #APP */
 1902               	 ;  1663 "../../Source/queue.c" 1
 1903 0648 0FB6      		in		__tmp_reg__, __SREG__
 1904               	 ;  0 "" 2
 1905               	 ;  1663 "../../Source/queue.c" 1
 1906 064a F894      		cli
 1907               	 ;  0 "" 2
 1908               	 ;  1663 "../../Source/queue.c" 1
 1909 064c 0F92      		push	__tmp_reg__
 1910               	 ;  0 "" 2
 1911               	/* #NOAPP */
 1912               	.LBB17:
1665:../../Source/queue.c **** 
 1914               	.LM219:
 1915 064e F801      		movw r30,r16
 1916 0650 928D      		ldd r25,Z+26
1669:../../Source/queue.c **** 			{
 1918               	.LM220:
 1919 0652 9923      		tst r25
 1920 0654 01F0      		breq .L150
1674:../../Source/queue.c **** 
 1922               	.LM221:
 1923 0656 C680      		ldd r12,Z+6
 1924 0658 D780      		ldd r13,Z+7
1676:../../Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
 1926               	.LM222:
 1927 065a B701      		movw r22,r14
 1928 065c C801      		movw r24,r16
 1929 065e 0E94 0000 		call prvCopyDataFromQueue
1680:../../Source/queue.c **** 
 1931               	.LM223:
 1932 0662 F801      		movw r30,r16
 1933 0664 D782      		std Z+7,r13
 1934 0666 C682      		std Z+6,r12
1684:../../Source/queue.c **** 				{
 1936               	.LM224:
 1937 0668 8189      		ldd r24,Z+17
 1938 066a 8823      		tst r24
 1939 066c 01F0      		breq .L152
1686:../../Source/queue.c **** 					{
 1941               	.LM225:
 1942 066e C801      		movw r24,r16
 1943 0670 4196      		adiw r24,17
 1944 0672 0E94 0000 		call xTaskRemoveFromEventList
 1945 0676 8111      		cpse r24,__zero_reg__
1689:../../Source/queue.c **** 					}
 1947               	.LM226:
 1948 0678 0E94 0000 		call vPortYield
 1949               	.L152:
1701:../../Source/queue.c **** 				return pdPASS;
 1951               	.LM227:
 1952               	/* #APP */
 1953               	 ;  1701 "../../Source/queue.c" 1
 1954 067c 0F90      		pop		__tmp_reg__
 1955               	 ;  0 "" 2
 1956               	 ;  1701 "../../Source/queue.c" 1
 1957 067e 0FBE      		out		__SREG__, __tmp_reg__
 1958               	 ;  0 "" 2
1702:../../Source/queue.c **** 			}
 1960               	.LM228:
 1961               	/* #NOAPP */
 1962 0680 81E0      		ldi r24,lo8(1)
 1963 0682 00C0      		rjmp .L154
 1964               	.L150:
1706:../../Source/queue.c **** 				{
 1966               	.LM229:
 1967 0684 2C81      		ldd r18,Y+4
 1968 0686 3D81      		ldd r19,Y+5
 1969 0688 232B      		or r18,r19
 1970 068a 01F4      		brne .L155
1710:../../Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
 1972               	.LM230:
 1973               	/* #APP */
 1974               	 ;  1710 "../../Source/queue.c" 1
 1975 068c 0F90      		pop		__tmp_reg__
 1976               	 ;  0 "" 2
 1977               	 ;  1710 "../../Source/queue.c" 1
 1978 068e 0FBE      		out		__SREG__, __tmp_reg__
 1979               	 ;  0 "" 2
 1980               	/* #NOAPP */
 1981 0690 00C0      		rjmp .L169
 1982               	.L155:
1714:../../Source/queue.c **** 				{
 1984               	.LM231:
 1985 0692 8111      		cpse r24,__zero_reg__
 1986 0694 00C0      		rjmp .L156
1719:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1988               	.LM232:
 1989 0696 CE01      		movw r24,r28
 1990 0698 0196      		adiw r24,1
 1991 069a 0E94 0000 		call vTaskInternalSetTimeOutState
 1992               	.L156:
 1993               	.LBE17:
1729:../../Source/queue.c **** 
 1995               	.LM233:
 1996               	/* #APP */
 1997               	 ;  1729 "../../Source/queue.c" 1
 1998 069e 0F90      		pop		__tmp_reg__
 1999               	 ;  0 "" 2
 2000               	 ;  1729 "../../Source/queue.c" 1
 2001 06a0 0FBE      		out		__SREG__, __tmp_reg__
 2002               	 ;  0 "" 2
1734:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 2004               	.LM234:
 2005               	/* #NOAPP */
 2006 06a2 0E94 0000 		call vTaskSuspendAll
1735:../../Source/queue.c **** 
 2008               	.LM235:
 2009               	/* #APP */
 2010               	 ;  1735 "../../Source/queue.c" 1
 2011 06a6 0FB6      		in		__tmp_reg__, __SREG__
 2012               	 ;  0 "" 2
 2013               	 ;  1735 "../../Source/queue.c" 1
 2014 06a8 F894      		cli
 2015               	 ;  0 "" 2
 2016               	 ;  1735 "../../Source/queue.c" 1
 2017 06aa 0F92      		push	__tmp_reg__
 2018               	 ;  0 "" 2
 2019               	/* #NOAPP */
 2020 06ac F801      		movw r30,r16
 2021 06ae 858D      		ldd r24,Z+29
 2022 06b0 8F3F      		cpi r24,lo8(-1)
 2023 06b2 01F4      		brne .L157
1735:../../Source/queue.c **** 
 2025               	.LM236:
 2026 06b4 158E      		std Z+29,__zero_reg__
 2027               	.L157:
1735:../../Source/queue.c **** 
 2029               	.LM237:
 2030 06b6 F801      		movw r30,r16
 2031 06b8 868D      		ldd r24,Z+30
 2032 06ba 8F3F      		cpi r24,lo8(-1)
 2033 06bc 01F4      		brne .L158
1735:../../Source/queue.c **** 
 2035               	.LM238:
 2036 06be 168E      		std Z+30,__zero_reg__
 2037               	.L158:
1735:../../Source/queue.c **** 
 2039               	.LM239:
 2040               	/* #APP */
 2041               	 ;  1735 "../../Source/queue.c" 1
 2042 06c0 0F90      		pop		__tmp_reg__
 2043               	 ;  0 "" 2
 2044               	 ;  1735 "../../Source/queue.c" 1
 2045 06c2 0FBE      		out		__SREG__, __tmp_reg__
 2046               	 ;  0 "" 2
1738:../../Source/queue.c **** 		{
 2048               	.LM240:
 2049               	/* #NOAPP */
 2050 06c4 BE01      		movw r22,r28
 2051 06c6 6C5F      		subi r22,-4
 2052 06c8 7F4F      		sbci r23,-1
 2053 06ca CE01      		movw r24,r28
 2054 06cc 0196      		adiw r24,1
 2055 06ce 0E94 0000 		call xTaskCheckForTimeOut
 2056 06d2 8111      		cpse r24,__zero_reg__
 2057 06d4 00C0      		rjmp .L159
1742:../../Source/queue.c **** 			{
 2059               	.LM241:
 2060 06d6 C801      		movw r24,r16
 2061 06d8 0E94 0000 		call prvIsQueueEmpty
 2062 06dc 8823      		tst r24
 2063 06de 01F0      		breq .L160
1745:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 2065               	.LM242:
 2066 06e0 6C81      		ldd r22,Y+4
 2067 06e2 7D81      		ldd r23,Y+5
 2068 06e4 C601      		movw r24,r12
 2069 06e6 0E94 0000 		call vTaskPlaceOnEventList
1746:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2071               	.LM243:
 2072 06ea C801      		movw r24,r16
 2073 06ec 0E94 0000 		call prvUnlockQueue
1747:../../Source/queue.c **** 				{
 2075               	.LM244:
 2076 06f0 0E94 0000 		call xTaskResumeAll
 2077 06f4 8823      		tst r24
 2078 06f6 01F0      		breq .L170
 2079               	.L162:
 2080 06f8 81E0      		ldi r24,lo8(1)
 2081 06fa 00C0      		rjmp .L149
 2082               	.L170:
1749:../../Source/queue.c **** 				}
 2084               	.LM245:
 2085 06fc 0E94 0000 		call vPortYield
 2086 0700 00C0      		rjmp .L162
 2087               	.L160:
1760:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 2089               	.LM246:
 2090 0702 C801      		movw r24,r16
 2091 0704 0E94 0000 		call prvUnlockQueue
1761:../../Source/queue.c **** 			}
 2093               	.LM247:
 2094 0708 0E94 0000 		call xTaskResumeAll
 2095 070c 00C0      		rjmp .L162
 2096               	.L159:
1768:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 2098               	.LM248:
 2099 070e C801      		movw r24,r16
 2100 0710 0E94 0000 		call prvUnlockQueue
1769:../../Source/queue.c **** 
 2102               	.LM249:
 2103 0714 0E94 0000 		call xTaskResumeAll
1771:../../Source/queue.c **** 			{
 2105               	.LM250:
 2106 0718 C801      		movw r24,r16
 2107 071a 0E94 0000 		call prvIsQueueEmpty
 2108 071e 8823      		tst r24
 2109 0720 01F0      		breq .L162
 2110               	.L169:
1774:../../Source/queue.c **** 			}
 2112               	.LM251:
 2113 0722 80E0      		ldi r24,0
 2114               	.L154:
 2115               	/* epilogue start */
1782:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2117               	.LM252:
 2118 0724 0F90      		pop __tmp_reg__
 2119 0726 0F90      		pop __tmp_reg__
 2120 0728 0F90      		pop __tmp_reg__
 2121 072a 0F90      		pop __tmp_reg__
 2122 072c 0F90      		pop __tmp_reg__
 2123 072e DF91      		pop r29
 2124 0730 CF91      		pop r28
 2125 0732 1F91      		pop r17
 2126 0734 0F91      		pop r16
 2127 0736 FF90      		pop r15
 2128 0738 EF90      		pop r14
 2129 073a DF90      		pop r13
 2130 073c CF90      		pop r12
 2131 073e 0895      		ret
 2141               	.Lscope12:
 2143               		.stabd	78,0,0
 2148               	.global	xQueueReceiveFromISR
 2150               	xQueueReceiveFromISR:
 2151               		.stabd	46,0,0
1786:../../Source/queue.c **** BaseType_t xReturn;
 2153               	.LM253:
 2154               	.LFBB13:
 2155 0740 EF92      		push r14
 2156 0742 FF92      		push r15
 2157 0744 0F93      		push r16
 2158 0746 1F93      		push r17
 2159 0748 CF93      		push r28
 2160 074a DF93      		push r29
 2161               	/* prologue: function */
 2162               	/* frame size = 0 */
 2163               	/* stack size = 6 */
 2164               	.L__stack_usage = 6
 2165               	.LBB18:
1812:../../Source/queue.c **** 
 2167               	.LM254:
 2168 074c FC01      		movw r30,r24
 2169 074e 028D      		ldd r16,Z+26
1815:../../Source/queue.c **** 		{
 2171               	.LM255:
 2172 0750 0023      		tst r16
 2173 0752 01F0      		breq .L176
 2174 0754 7A01      		movw r14,r20
 2175 0756 EC01      		movw r28,r24
 2176               	.LBB19:
1817:../../Source/queue.c **** 
 2178               	.LM256:
 2179 0758 158D      		ldd r17,Z+29
1821:../../Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2181               	.LM257:
 2182 075a 0E94 0000 		call prvCopyDataFromQueue
1822:../../Source/queue.c **** 
 2184               	.LM258:
 2185 075e 0150      		subi r16,lo8(-(-1))
 2186 0760 0A8F      		std Y+26,r16
1828:../../Source/queue.c **** 			{
 2188               	.LM259:
 2189 0762 1F3F      		cpi r17,lo8(-1)
 2190 0764 01F4      		brne .L173
1830:../../Source/queue.c **** 				{
 2192               	.LM260:
 2193 0766 8885      		ldd r24,Y+8
 2194 0768 8823      		tst r24
 2195 076a 01F0      		breq .L183
1832:../../Source/queue.c **** 					{
 2197               	.LM261:
 2198 076c CE01      		movw r24,r28
 2199 076e 0896      		adiw r24,8
 2200 0770 0E94 0000 		call xTaskRemoveFromEventList
 2201 0774 8823      		tst r24
 2202 0776 01F0      		breq .L183
1836:../../Source/queue.c **** 						{
 2204               	.LM262:
 2205 0778 E114      		cp r14,__zero_reg__
 2206 077a F104      		cpc r15,__zero_reg__
 2207 077c 01F0      		breq .L183
1838:../../Source/queue.c **** 						}
 2209               	.LM263:
 2210 077e 81E0      		ldi r24,lo8(1)
 2211 0780 F701      		movw r30,r14
 2212 0782 8083      		st Z,r24
 2213 0784 00C0      		rjmp .L172
 2214               	.L173:
1859:../../Source/queue.c **** 			}
 2216               	.LM264:
 2217 0786 1F5F      		subi r17,lo8(-(1))
 2218 0788 1D8F      		std Y+29,r17
 2219               	.L183:
1862:../../Source/queue.c **** 		}
 2221               	.LM265:
 2222 078a 81E0      		ldi r24,lo8(1)
 2223 078c 00C0      		rjmp .L172
 2224               	.L176:
 2225               	.LBE19:
1866:../../Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 2227               	.LM266:
 2228 078e 80E0      		ldi r24,0
 2229               	.L172:
 2230               	/* epilogue start */
 2231               	.LBE18:
1873:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2233               	.LM267:
 2234 0790 DF91      		pop r29
 2235 0792 CF91      		pop r28
 2236 0794 1F91      		pop r17
 2237 0796 0F91      		pop r16
 2238 0798 FF90      		pop r15
 2239 079a EF90      		pop r14
 2240 079c 0895      		ret
 2251               	.Lscope13:
 2253               		.stabd	78,0,0
 2257               	.global	xQueuePeekFromISR
 2259               	xQueuePeekFromISR:
 2260               		.stabd	46,0,0
1877:../../Source/queue.c **** BaseType_t xReturn;
 2262               	.LM268:
 2263               	.LFBB14:
 2264 079e 0F93      		push r16
 2265 07a0 1F93      		push r17
 2266 07a2 CF93      		push r28
 2267 07a4 DF93      		push r29
 2268               	/* prologue: function */
 2269               	/* frame size = 0 */
 2270               	/* stack size = 4 */
 2271               	.L__stack_usage = 4
1906:../../Source/queue.c **** 		{
 2273               	.LM269:
 2274 07a6 FC01      		movw r30,r24
 2275 07a8 228D      		ldd r18,Z+26
 2276 07aa 2223      		tst r18
 2277 07ac 01F0      		breq .L186
 2278 07ae EC01      		movw r28,r24
1912:../../Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2280               	.LM270:
 2281 07b0 0681      		ldd r16,Z+6
 2282 07b2 1781      		ldd r17,Z+7
1913:../../Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2284               	.LM271:
 2285 07b4 0E94 0000 		call prvCopyDataFromQueue
1914:../../Source/queue.c **** 
 2287               	.LM272:
 2288 07b8 1F83      		std Y+7,r17
 2289 07ba 0E83      		std Y+6,r16
1916:../../Source/queue.c **** 		}
 2291               	.LM273:
 2292 07bc 81E0      		ldi r24,lo8(1)
 2293 07be 00C0      		rjmp .L185
 2294               	.L186:
1920:../../Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 2296               	.LM274:
 2297 07c0 80E0      		ldi r24,0
 2298               	.L185:
 2299               	/* epilogue start */
1927:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2301               	.LM275:
 2302 07c2 DF91      		pop r29
 2303 07c4 CF91      		pop r28
 2304 07c6 1F91      		pop r17
 2305 07c8 0F91      		pop r16
 2306 07ca 0895      		ret
 2312               	.Lscope14:
 2314               		.stabd	78,0,0
 2317               	.global	uxQueueMessagesWaiting
 2319               	uxQueueMessagesWaiting:
 2320               		.stabd	46,0,0
1931:../../Source/queue.c **** UBaseType_t uxReturn;
 2322               	.LM276:
 2323               	.LFBB15:
 2324               	/* prologue: function */
 2325               	/* frame size = 0 */
 2326               	/* stack size = 0 */
 2327               	.L__stack_usage = 0
1936:../../Source/queue.c **** 	{
 2329               	.LM277:
 2330               	/* #APP */
 2331               	 ;  1936 "../../Source/queue.c" 1
 2332 07cc 0FB6      		in		__tmp_reg__, __SREG__
 2333               	 ;  0 "" 2
 2334               	 ;  1936 "../../Source/queue.c" 1
 2335 07ce F894      		cli
 2336               	 ;  0 "" 2
 2337               	 ;  1936 "../../Source/queue.c" 1
 2338 07d0 0F92      		push	__tmp_reg__
 2339               	 ;  0 "" 2
1938:../../Source/queue.c **** 	}
 2341               	.LM278:
 2342               	/* #NOAPP */
 2343 07d2 FC01      		movw r30,r24
 2344 07d4 828D      		ldd r24,Z+26
1940:../../Source/queue.c **** 
 2346               	.LM279:
 2347               	/* #APP */
 2348               	 ;  1940 "../../Source/queue.c" 1
 2349 07d6 0F90      		pop		__tmp_reg__
 2350               	 ;  0 "" 2
 2351               	 ;  1940 "../../Source/queue.c" 1
 2352 07d8 0FBE      		out		__SREG__, __tmp_reg__
 2353               	 ;  0 "" 2
1943:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2355               	.LM280:
 2356               	/* #NOAPP */
 2357 07da 0895      		ret
 2362               	.Lscope15:
 2364               		.stabd	78,0,0
 2367               	.global	uxQueueSpacesAvailable
 2369               	uxQueueSpacesAvailable:
 2370               		.stabd	46,0,0
1947:../../Source/queue.c **** UBaseType_t uxReturn;
 2372               	.LM281:
 2373               	.LFBB16:
 2374               	/* prologue: function */
 2375               	/* frame size = 0 */
 2376               	/* stack size = 0 */
 2377               	.L__stack_usage = 0
1953:../../Source/queue.c **** 	{
 2379               	.LM282:
 2380               	/* #APP */
 2381               	 ;  1953 "../../Source/queue.c" 1
 2382 07dc 0FB6      		in		__tmp_reg__, __SREG__
 2383               	 ;  0 "" 2
 2384               	 ;  1953 "../../Source/queue.c" 1
 2385 07de F894      		cli
 2386               	 ;  0 "" 2
 2387               	 ;  1953 "../../Source/queue.c" 1
 2388 07e0 0F92      		push	__tmp_reg__
 2389               	 ;  0 "" 2
1955:../../Source/queue.c **** 	}
 2391               	.LM283:
 2392               	/* #NOAPP */
 2393 07e2 FC01      		movw r30,r24
 2394 07e4 228D      		ldd r18,Z+26
1957:../../Source/queue.c **** 
 2396               	.LM284:
 2397               	/* #APP */
 2398               	 ;  1957 "../../Source/queue.c" 1
 2399 07e6 0F90      		pop		__tmp_reg__
 2400               	 ;  0 "" 2
 2401               	 ;  1957 "../../Source/queue.c" 1
 2402 07e8 0FBE      		out		__SREG__, __tmp_reg__
 2403               	 ;  0 "" 2
1959:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2405               	.LM285:
 2406               	/* #NOAPP */
 2407 07ea 838D      		ldd r24,Z+27
1960:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2409               	.LM286:
 2410 07ec 821B      		sub r24,r18
 2411 07ee 0895      		ret
 2413               	.Lscope16:
 2415               		.stabd	78,0,0
 2418               	.global	uxQueueMessagesWaitingFromISR
 2420               	uxQueueMessagesWaitingFromISR:
 2421               		.stabd	46,0,0
1964:../../Source/queue.c **** UBaseType_t uxReturn;
 2423               	.LM287:
 2424               	.LFBB17:
 2425               	/* prologue: function */
 2426               	/* frame size = 0 */
 2427               	/* stack size = 0 */
 2428               	.L__stack_usage = 0
1969:../../Source/queue.c **** 
 2430               	.LM288:
 2431 07f0 FC01      		movw r30,r24
 2432 07f2 828D      		ldd r24,Z+26
1972:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2434               	.LM289:
 2435 07f4 0895      		ret
 2440               	.Lscope17:
 2442               		.stabd	78,0,0
 2445               	.global	vQueueDelete
 2447               	vQueueDelete:
 2448               		.stabd	46,0,0
1976:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2450               	.LM290:
 2451               	.LFBB18:
 2452               	/* prologue: function */
 2453               	/* frame size = 0 */
 2454               	/* stack size = 0 */
 2455               	.L__stack_usage = 0
1992:../../Source/queue.c **** 	}
 2457               	.LM291:
 2458 07f6 0C94 0000 		jmp vPortFree
 2460               	.Lscope18:
 2462               		.stabd	78,0,0
 2465               	.global	xQueueIsQueueEmptyFromISR
 2467               	xQueueIsQueueEmptyFromISR:
 2468               		.stabd	46,0,0
2313:../../Source/queue.c **** BaseType_t xReturn;
 2470               	.LM292:
 2471               	.LFBB19:
 2472               	/* prologue: function */
 2473               	/* frame size = 0 */
 2474               	/* stack size = 0 */
 2475               	.L__stack_usage = 0
2318:../../Source/queue.c **** 	{
 2477               	.LM293:
 2478 07fa FC01      		movw r30,r24
 2479 07fc 928D      		ldd r25,Z+26
2327:../../Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2481               	.LM294:
 2482 07fe 81E0      		ldi r24,lo8(1)
 2483 0800 9111      		cpse r25,__zero_reg__
 2484 0802 80E0      		ldi r24,0
 2485               	.L192:
2328:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2487               	.LM295:
 2488 0804 0895      		ret
 2490               	.Lscope19:
 2492               		.stabd	78,0,0
 2495               	.global	xQueueIsQueueFullFromISR
 2497               	xQueueIsQueueFullFromISR:
 2498               		.stabd	46,0,0
2347:../../Source/queue.c **** 
2348:../../Source/queue.c **** 	return xReturn;
2349:../../Source/queue.c **** }
2350:../../Source/queue.c **** /*-----------------------------------------------------------*/
2351:../../Source/queue.c **** 
2352:../../Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2353:../../Source/queue.c **** {
 2500               	.LM296:
 2501               	.LFBB20:
 2502               	/* prologue: function */
 2503               	/* frame size = 0 */
 2504               	/* stack size = 0 */
 2505               	.L__stack_usage = 0
 2506 0806 FC01      		movw r30,r24
2354:../../Source/queue.c **** BaseType_t xReturn;
2355:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
2356:../../Source/queue.c **** 
2357:../../Source/queue.c **** 	configASSERT( pxQueue );
2358:../../Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2508               	.LM297:
 2509 0808 928D      		ldd r25,Z+26
2359:../../Source/queue.c **** 	{
2360:../../Source/queue.c **** 		xReturn = pdTRUE;
2361:../../Source/queue.c **** 	}
2362:../../Source/queue.c **** 	else
2363:../../Source/queue.c **** 	{
2364:../../Source/queue.c **** 		xReturn = pdFALSE;
2365:../../Source/queue.c **** 	}
2366:../../Source/queue.c **** 
2367:../../Source/queue.c **** 	return xReturn;
 2511               	.LM298:
 2512 080a 81E0      		ldi r24,lo8(1)
 2513 080c 238D      		ldd r18,Z+27
 2514 080e 2913      		cpse r18,r25
 2515 0810 80E0      		ldi r24,0
 2516               	.L197:
2368:../../Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2518               	.LM299:
 2519 0812 0895      		ret
 2521               	.Lscope20:
 2523               		.stabd	78,0,0
 2528               	.global	xQueueCRSend
 2530               	xQueueCRSend:
 2531               		.stabd	46,0,0
2369:../../Source/queue.c **** /*-----------------------------------------------------------*/
2370:../../Source/queue.c **** 
2371:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2372:../../Source/queue.c **** 
2373:../../Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2374:../../Source/queue.c **** 	{
 2533               	.LM300:
 2534               	.LFBB21:
 2535 0814 CF93      		push r28
 2536 0816 DF93      		push r29
 2537               	/* prologue: function */
 2538               	/* frame size = 0 */
 2539               	/* stack size = 2 */
 2540               	.L__stack_usage = 2
 2541 0818 EC01      		movw r28,r24
2375:../../Source/queue.c **** 	BaseType_t xReturn;
2376:../../Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2377:../../Source/queue.c **** 
2378:../../Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2379:../../Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2380:../../Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2381:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2543               	.LM301:
 2544               	/* #APP */
 2545               	 ;  2381 "../../Source/queue.c" 1
 2546 081a F894      		cli
 2547               	 ;  0 "" 2
 2548               	/* #NOAPP */
 2549               	.LBB22:
 2550               	.LBB23:
2335:../../Source/queue.c **** 	{
 2552               	.LM302:
 2553               	/* #APP */
 2554               	 ;  2335 "../../Source/queue.c" 1
 2555 081c 0FB6      		in		__tmp_reg__, __SREG__
 2556               	 ;  0 "" 2
 2557               	 ;  2335 "../../Source/queue.c" 1
 2558 081e F894      		cli
 2559               	 ;  0 "" 2
 2560               	 ;  2335 "../../Source/queue.c" 1
 2561 0820 0F92      		push	__tmp_reg__
 2562               	 ;  0 "" 2
2337:../../Source/queue.c **** 		{
 2564               	.LM303:
 2565               	/* #NOAPP */
 2566 0822 8A8D      		ldd r24,Y+26
 2567 0824 9B8D      		ldd r25,Y+27
2346:../../Source/queue.c **** 
 2569               	.LM304:
 2570               	/* #APP */
 2571               	 ;  2346 "../../Source/queue.c" 1
 2572 0826 0F90      		pop		__tmp_reg__
 2573               	 ;  0 "" 2
 2574               	 ;  2346 "../../Source/queue.c" 1
 2575 0828 0FBE      		out		__SREG__, __tmp_reg__
 2576               	 ;  0 "" 2
 2577               	/* #NOAPP */
 2578               	.LBE23:
 2579               	.LBE22:
2382:../../Source/queue.c **** 		{
2383:../../Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 2581               	.LM305:
 2582 082a 8913      		cpse r24,r25
 2583 082c 00C0      		rjmp .L199
2384:../../Source/queue.c **** 			{
2385:../../Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2386:../../Source/queue.c **** 				posting? */
2387:../../Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2585               	.LM306:
 2586 082e 4115      		cp r20,__zero_reg__
 2587 0830 5105      		cpc r21,__zero_reg__
 2588 0832 01F0      		breq .L200
2388:../../Source/queue.c **** 				{
2389:../../Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2390:../../Source/queue.c **** 					return indicating that we need to block. */
2391:../../Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 2590               	.LM307:
 2591 0834 BE01      		movw r22,r28
 2592 0836 685F      		subi r22,-8
 2593 0838 7F4F      		sbci r23,-1
 2594 083a CA01      		movw r24,r20
 2595 083c 0E94 0000 		call vCoRoutineAddToDelayedList
2392:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 2597               	.LM308:
 2598               	/* #APP */
 2599               	 ;  2392 "../../Source/queue.c" 1
 2600 0840 7894      		sei
 2601               	 ;  0 "" 2
2393:../../Source/queue.c **** 					return errQUEUE_BLOCKED;
 2603               	.LM309:
 2604               	/* #NOAPP */
 2605 0842 8CEF      		ldi r24,lo8(-4)
 2606 0844 00C0      		rjmp .L201
 2607               	.L200:
2394:../../Source/queue.c **** 				}
2395:../../Source/queue.c **** 				else
2396:../../Source/queue.c **** 				{
2397:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 2609               	.LM310:
 2610               	/* #APP */
 2611               	 ;  2397 "../../Source/queue.c" 1
 2612 0846 7894      		sei
 2613               	 ;  0 "" 2
2398:../../Source/queue.c **** 					return errQUEUE_FULL;
 2615               	.LM311:
 2616               	/* #NOAPP */
 2617 0848 80E0      		ldi r24,0
 2618 084a 00C0      		rjmp .L201
 2619               	.L199:
2399:../../Source/queue.c **** 				}
2400:../../Source/queue.c **** 			}
2401:../../Source/queue.c **** 		}
2402:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 2621               	.LM312:
 2622               	/* #APP */
 2623               	 ;  2402 "../../Source/queue.c" 1
 2624 084c 7894      		sei
 2625               	 ;  0 "" 2
2403:../../Source/queue.c **** 
2404:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2627               	.LM313:
 2628               	 ;  2404 "../../Source/queue.c" 1
 2629 084e F894      		cli
 2630               	 ;  0 "" 2
2405:../../Source/queue.c **** 		{
2406:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2632               	.LM314:
 2633               	/* #NOAPP */
 2634 0850 8A8D      		ldd r24,Y+26
 2635 0852 8917      		cp r24,r25
 2636 0854 00F4      		brsh .L205
2407:../../Source/queue.c **** 			{
2408:../../Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2409:../../Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2638               	.LM315:
 2639 0856 40E0      		ldi r20,0
 2640 0858 CE01      		movw r24,r28
 2641 085a 0E94 0000 		call prvCopyDataToQueue
2410:../../Source/queue.c **** 				xReturn = pdPASS;
2411:../../Source/queue.c **** 
2412:../../Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2413:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2643               	.LM316:
 2644 085e 8989      		ldd r24,Y+17
 2645 0860 8111      		cpse r24,__zero_reg__
 2646 0862 00C0      		rjmp .L203
 2647               	.L204:
2410:../../Source/queue.c **** 				xReturn = pdPASS;
 2649               	.LM317:
 2650 0864 81E0      		ldi r24,lo8(1)
 2651 0866 00C0      		rjmp .L202
 2652               	.L203:
2414:../../Source/queue.c **** 				{
2415:../../Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2416:../../Source/queue.c **** 					into the ready list as we are within a critical section.
2417:../../Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2418:../../Source/queue.c **** 					the event were caused from within an interrupt. */
2419:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2654               	.LM318:
 2655 0868 CE01      		movw r24,r28
 2656 086a 4196      		adiw r24,17
 2657 086c 0E94 0000 		call xCoRoutineRemoveFromEventList
 2658 0870 8823      		tst r24
 2659 0872 01F0      		breq .L204
2420:../../Source/queue.c **** 					{
2421:../../Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2422:../../Source/queue.c **** 						that a yield might be appropriate. */
2423:../../Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2661               	.LM319:
 2662 0874 8BEF      		ldi r24,lo8(-5)
 2663 0876 00C0      		rjmp .L202
 2664               	.L205:
2424:../../Source/queue.c **** 					}
2425:../../Source/queue.c **** 					else
2426:../../Source/queue.c **** 					{
2427:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2428:../../Source/queue.c **** 					}
2429:../../Source/queue.c **** 				}
2430:../../Source/queue.c **** 				else
2431:../../Source/queue.c **** 				{
2432:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2433:../../Source/queue.c **** 				}
2434:../../Source/queue.c **** 			}
2435:../../Source/queue.c **** 			else
2436:../../Source/queue.c **** 			{
2437:../../Source/queue.c **** 				xReturn = errQUEUE_FULL;
 2666               	.LM320:
 2667 0878 80E0      		ldi r24,0
 2668               	.L202:
2438:../../Source/queue.c **** 			}
2439:../../Source/queue.c **** 		}
2440:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 2670               	.LM321:
 2671               	/* #APP */
 2672               	 ;  2440 "../../Source/queue.c" 1
 2673 087a 7894      		sei
 2674               	 ;  0 "" 2
 2675               	/* #NOAPP */
 2676               	.L201:
 2677               	/* epilogue start */
2441:../../Source/queue.c **** 
2442:../../Source/queue.c **** 		return xReturn;
2443:../../Source/queue.c **** 	}
 2679               	.LM322:
 2680 087c DF91      		pop r29
 2681 087e CF91      		pop r28
 2682 0880 0895      		ret
 2687               	.Lscope21:
 2689               		.stabd	78,0,0
 2694               	.global	xQueueCRReceive
 2696               	xQueueCRReceive:
 2697               		.stabd	46,0,0
2444:../../Source/queue.c **** 
2445:../../Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2446:../../Source/queue.c **** /*-----------------------------------------------------------*/
2447:../../Source/queue.c **** 
2448:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2449:../../Source/queue.c **** 
2450:../../Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2451:../../Source/queue.c **** 	{
 2699               	.LM323:
 2700               	.LFBB22:
 2701 0882 CF93      		push r28
 2702 0884 DF93      		push r29
 2703               	/* prologue: function */
 2704               	/* frame size = 0 */
 2705               	/* stack size = 2 */
 2706               	.L__stack_usage = 2
 2707 0886 EC01      		movw r28,r24
 2708 0888 FB01      		movw r30,r22
2452:../../Source/queue.c **** 	BaseType_t xReturn;
2453:../../Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2454:../../Source/queue.c **** 
2455:../../Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2456:../../Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
2457:../../Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2458:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2710               	.LM324:
 2711               	/* #APP */
 2712               	 ;  2458 "../../Source/queue.c" 1
 2713 088a F894      		cli
 2714               	 ;  0 "" 2
2459:../../Source/queue.c **** 		{
2460:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2716               	.LM325:
 2717               	/* #NOAPP */
 2718 088c 8A8D      		ldd r24,Y+26
 2719 088e 8111      		cpse r24,__zero_reg__
 2720 0890 00C0      		rjmp .L210
2461:../../Source/queue.c **** 			{
2462:../../Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2463:../../Source/queue.c **** 				leave with nothing? */
2464:../../Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2722               	.LM326:
 2723 0892 4115      		cp r20,__zero_reg__
 2724 0894 5105      		cpc r21,__zero_reg__
 2725 0896 01F0      		breq .L211
2465:../../Source/queue.c **** 				{
2466:../../Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2467:../../Source/queue.c **** 					indicating that we need to block. */
2468:../../Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 2727               	.LM327:
 2728 0898 BE01      		movw r22,r28
 2729 089a 6F5E      		subi r22,-17
 2730 089c 7F4F      		sbci r23,-1
 2731 089e CA01      		movw r24,r20
 2732 08a0 0E94 0000 		call vCoRoutineAddToDelayedList
2469:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 2734               	.LM328:
 2735               	/* #APP */
 2736               	 ;  2469 "../../Source/queue.c" 1
 2737 08a4 7894      		sei
 2738               	 ;  0 "" 2
2470:../../Source/queue.c **** 					return errQUEUE_BLOCKED;
 2740               	.LM329:
 2741               	/* #NOAPP */
 2742 08a6 8CEF      		ldi r24,lo8(-4)
 2743 08a8 00C0      		rjmp .L212
 2744               	.L211:
2471:../../Source/queue.c **** 				}
2472:../../Source/queue.c **** 				else
2473:../../Source/queue.c **** 				{
2474:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 2746               	.LM330:
 2747               	/* #APP */
 2748               	 ;  2474 "../../Source/queue.c" 1
 2749 08aa 7894      		sei
 2750               	 ;  0 "" 2
2475:../../Source/queue.c **** 					return errQUEUE_FULL;
 2752               	.LM331:
 2753               	/* #NOAPP */
 2754 08ac 80E0      		ldi r24,0
 2755 08ae 00C0      		rjmp .L212
 2756               	.L210:
2476:../../Source/queue.c **** 				}
2477:../../Source/queue.c **** 			}
2478:../../Source/queue.c **** 			else
2479:../../Source/queue.c **** 			{
2480:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2481:../../Source/queue.c **** 			}
2482:../../Source/queue.c **** 		}
2483:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 2758               	.LM332:
 2759               	/* #APP */
 2760               	 ;  2483 "../../Source/queue.c" 1
 2761 08b0 7894      		sei
 2762               	 ;  0 "" 2
2484:../../Source/queue.c **** 
2485:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2764               	.LM333:
 2765               	 ;  2485 "../../Source/queue.c" 1
 2766 08b2 F894      		cli
 2767               	 ;  0 "" 2
2486:../../Source/queue.c **** 		{
2487:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2769               	.LM334:
 2770               	/* #NOAPP */
 2771 08b4 8A8D      		ldd r24,Y+26
 2772 08b6 8823      		tst r24
 2773 08b8 01F0      		breq .L217
2488:../../Source/queue.c **** 			{
2489:../../Source/queue.c **** 				/* Data is available from the queue. */
2490:../../Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 2775               	.LM335:
 2776 08ba 4C8D      		ldd r20,Y+28
 2777 08bc 50E0      		ldi r21,0
 2778 08be 2E81      		ldd r18,Y+6
 2779 08c0 3F81      		ldd r19,Y+7
 2780 08c2 240F      		add r18,r20
 2781 08c4 351F      		adc r19,r21
 2782 08c6 3F83      		std Y+7,r19
 2783 08c8 2E83      		std Y+6,r18
2491:../../Source/queue.c **** 				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 2785               	.LM336:
 2786 08ca 8C81      		ldd r24,Y+4
 2787 08cc 9D81      		ldd r25,Y+5
 2788 08ce 2817      		cp r18,r24
 2789 08d0 3907      		cpc r19,r25
 2790 08d2 00F0      		brlo .L214
2492:../../Source/queue.c **** 				{
2493:../../Source/queue.c **** 					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 2792               	.LM337:
 2793 08d4 8881      		ld r24,Y
 2794 08d6 9981      		ldd r25,Y+1
 2795 08d8 9F83      		std Y+7,r25
 2796 08da 8E83      		std Y+6,r24
 2797               	.L214:
2494:../../Source/queue.c **** 				}
2495:../../Source/queue.c **** 				else
2496:../../Source/queue.c **** 				{
2497:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2498:../../Source/queue.c **** 				}
2499:../../Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 2799               	.LM338:
 2800 08dc 9A8D      		ldd r25,Y+26
 2801 08de 9150      		subi r25,lo8(-(-1))
 2802 08e0 9A8F      		std Y+26,r25
2500:../../Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQ
 2804               	.LM339:
 2805 08e2 6E81      		ldd r22,Y+6
 2806 08e4 7F81      		ldd r23,Y+7
 2807 08e6 CF01      		movw r24,r30
 2808 08e8 0E94 0000 		call memcpy
2501:../../Source/queue.c **** 
2502:../../Source/queue.c **** 				xReturn = pdPASS;
2503:../../Source/queue.c **** 
2504:../../Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2505:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2810               	.LM340:
 2811 08ec 8885      		ldd r24,Y+8
 2812 08ee 8111      		cpse r24,__zero_reg__
 2813 08f0 00C0      		rjmp .L215
 2814               	.L216:
2502:../../Source/queue.c **** 
 2816               	.LM341:
 2817 08f2 81E0      		ldi r24,lo8(1)
 2818 08f4 00C0      		rjmp .L213
 2819               	.L215:
2506:../../Source/queue.c **** 				{
2507:../../Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2508:../../Source/queue.c **** 					into the ready list as we are within a critical section.
2509:../../Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2510:../../Source/queue.c **** 					the event were caused from within an interrupt. */
2511:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2821               	.LM342:
 2822 08f6 CE01      		movw r24,r28
 2823 08f8 0896      		adiw r24,8
 2824 08fa 0E94 0000 		call xCoRoutineRemoveFromEventList
 2825 08fe 8823      		tst r24
 2826 0900 01F0      		breq .L216
2512:../../Source/queue.c **** 					{
2513:../../Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2828               	.LM343:
 2829 0902 8BEF      		ldi r24,lo8(-5)
 2830 0904 00C0      		rjmp .L213
 2831               	.L217:
2514:../../Source/queue.c **** 					}
2515:../../Source/queue.c **** 					else
2516:../../Source/queue.c **** 					{
2517:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2518:../../Source/queue.c **** 					}
2519:../../Source/queue.c **** 				}
2520:../../Source/queue.c **** 				else
2521:../../Source/queue.c **** 				{
2522:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2523:../../Source/queue.c **** 				}
2524:../../Source/queue.c **** 			}
2525:../../Source/queue.c **** 			else
2526:../../Source/queue.c **** 			{
2527:../../Source/queue.c **** 				xReturn = pdFAIL;
 2833               	.LM344:
 2834 0906 80E0      		ldi r24,0
 2835               	.L213:
2528:../../Source/queue.c **** 			}
2529:../../Source/queue.c **** 		}
2530:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 2837               	.LM345:
 2838               	/* #APP */
 2839               	 ;  2530 "../../Source/queue.c" 1
 2840 0908 7894      		sei
 2841               	 ;  0 "" 2
 2842               	/* #NOAPP */
 2843               	.L212:
 2844               	/* epilogue start */
2531:../../Source/queue.c **** 
2532:../../Source/queue.c **** 		return xReturn;
2533:../../Source/queue.c **** 	}
 2846               	.LM346:
 2847 090a DF91      		pop r29
 2848 090c CF91      		pop r28
 2849 090e 0895      		ret
 2854               	.Lscope22:
 2856               		.stabd	78,0,0
 2861               	.global	xQueueCRSendFromISR
 2863               	xQueueCRSendFromISR:
 2864               		.stabd	46,0,0
2534:../../Source/queue.c **** 
2535:../../Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2536:../../Source/queue.c **** /*-----------------------------------------------------------*/
2537:../../Source/queue.c **** 
2538:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2539:../../Source/queue.c **** 
2540:../../Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2541:../../Source/queue.c **** 	{
 2866               	.LM347:
 2867               	.LFBB23:
 2868 0910 0F93      		push r16
 2869 0912 1F93      		push r17
 2870 0914 CF93      		push r28
 2871               	/* prologue: function */
 2872               	/* frame size = 0 */
 2873               	/* stack size = 3 */
 2874               	.L__stack_usage = 3
 2875 0916 8C01      		movw r16,r24
 2876 0918 C42F      		mov r28,r20
2542:../../Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2543:../../Source/queue.c **** 
2544:../../Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2545:../../Source/queue.c **** 		exit without doing anything. */
2546:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2878               	.LM348:
 2879 091a FC01      		movw r30,r24
 2880 091c 928D      		ldd r25,Z+26
 2881 091e 838D      		ldd r24,Z+27
 2882 0920 9817      		cp r25,r24
 2883 0922 00F0      		brlo .L222
 2884               	.L224:
 2885 0924 4C2F      		mov r20,r28
 2886 0926 00C0      		rjmp .L223
 2887               	.L222:
2547:../../Source/queue.c **** 		{
2548:../../Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2889               	.LM349:
 2890 0928 40E0      		ldi r20,0
 2891 092a C801      		movw r24,r16
 2892 092c 0E94 0000 		call prvCopyDataToQueue
2549:../../Source/queue.c **** 
2550:../../Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2551:../../Source/queue.c **** 			co-routine has not already been woken. */
2552:../../Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
 2894               	.LM350:
 2895 0930 C111      		cpse r28,__zero_reg__
 2896 0932 00C0      		rjmp .L224
2553:../../Source/queue.c **** 			{
2554:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2898               	.LM351:
 2899 0934 F801      		movw r30,r16
 2900 0936 8189      		ldd r24,Z+17
 2901 0938 8823      		tst r24
 2902 093a 01F0      		breq .L226
2555:../../Source/queue.c **** 				{
2556:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2904               	.LM352:
 2905 093c C801      		movw r24,r16
 2906 093e 4196      		adiw r24,17
 2907 0940 0E94 0000 		call xCoRoutineRemoveFromEventList
2557:../../Source/queue.c **** 					{
2558:../../Source/queue.c **** 						return pdTRUE;
 2909               	.LM353:
 2910 0944 41E0      		ldi r20,lo8(1)
 2911 0946 8111      		cpse r24,__zero_reg__
 2912 0948 00C0      		rjmp .L223
 2913               	.L226:
 2914 094a 40E0      		ldi r20,0
 2915               	.L223:
2559:../../Source/queue.c **** 					}
2560:../../Source/queue.c **** 					else
2561:../../Source/queue.c **** 					{
2562:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2563:../../Source/queue.c **** 					}
2564:../../Source/queue.c **** 				}
2565:../../Source/queue.c **** 				else
2566:../../Source/queue.c **** 				{
2567:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2568:../../Source/queue.c **** 				}
2569:../../Source/queue.c **** 			}
2570:../../Source/queue.c **** 			else
2571:../../Source/queue.c **** 			{
2572:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2573:../../Source/queue.c **** 			}
2574:../../Source/queue.c **** 		}
2575:../../Source/queue.c **** 		else
2576:../../Source/queue.c **** 		{
2577:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2578:../../Source/queue.c **** 		}
2579:../../Source/queue.c **** 
2580:../../Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2581:../../Source/queue.c **** 	}
 2917               	.LM354:
 2918 094c 842F      		mov r24,r20
 2919               	/* epilogue start */
 2920 094e CF91      		pop r28
 2921 0950 1F91      		pop r17
 2922 0952 0F91      		pop r16
 2923 0954 0895      		ret
 2925               	.Lscope23:
 2927               		.stabd	78,0,0
 2932               	.global	xQueueCRReceiveFromISR
 2934               	xQueueCRReceiveFromISR:
 2935               		.stabd	46,0,0
2582:../../Source/queue.c **** 
2583:../../Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2584:../../Source/queue.c **** /*-----------------------------------------------------------*/
2585:../../Source/queue.c **** 
2586:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2587:../../Source/queue.c **** 
2588:../../Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2589:../../Source/queue.c **** 	{
 2937               	.LM355:
 2938               	.LFBB24:
 2939 0956 0F93      		push r16
 2940 0958 1F93      		push r17
 2941 095a CF93      		push r28
 2942 095c DF93      		push r29
 2943               	/* prologue: function */
 2944               	/* frame size = 0 */
 2945               	/* stack size = 4 */
 2946               	.L__stack_usage = 4
 2947 095e FC01      		movw r30,r24
2590:../../Source/queue.c **** 	BaseType_t xReturn;
2591:../../Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2592:../../Source/queue.c **** 
2593:../../Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2594:../../Source/queue.c **** 		not then just leave without doing anything. */
2595:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2949               	.LM356:
 2950 0960 828D      		ldd r24,Z+26
 2951 0962 8823      		tst r24
 2952 0964 01F0      		breq .L232
2596:../../Source/queue.c **** 		{
2597:../../Source/queue.c **** 			/* Copy the data from the queue. */
2598:../../Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 2954               	.LM357:
 2955 0966 248D      		ldd r18,Z+28
 2956 0968 30E0      		ldi r19,0
 2957 096a A681      		ldd r26,Z+6
 2958 096c B781      		ldd r27,Z+7
 2959 096e A20F      		add r26,r18
 2960 0970 B31F      		adc r27,r19
 2961 0972 B783      		std Z+7,r27
 2962 0974 A683      		std Z+6,r26
2599:../../Source/queue.c **** 			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 2964               	.LM358:
 2965 0976 8481      		ldd r24,Z+4
 2966 0978 9581      		ldd r25,Z+5
 2967 097a A817      		cp r26,r24
 2968 097c B907      		cpc r27,r25
 2969 097e 00F0      		brlo .L229
2600:../../Source/queue.c **** 			{
2601:../../Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 2971               	.LM359:
 2972 0980 8081      		ld r24,Z
 2973 0982 9181      		ldd r25,Z+1
 2974 0984 9783      		std Z+7,r25
 2975 0986 8683      		std Z+6,r24
 2976               	.L229:
 2977 0988 8A01      		movw r16,r20
 2978 098a CB01      		movw r24,r22
 2979 098c EF01      		movw r28,r30
2602:../../Source/queue.c **** 			}
2603:../../Source/queue.c **** 			else
2604:../../Source/queue.c **** 			{
2605:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2606:../../Source/queue.c **** 			}
2607:../../Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 2981               	.LM360:
 2982 098e 428D      		ldd r20,Z+26
 2983 0990 4150      		subi r20,lo8(-(-1))
 2984 0992 428F      		std Z+26,r20
2608:../../Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQu
 2986               	.LM361:
 2987 0994 6681      		ldd r22,Z+6
 2988 0996 7781      		ldd r23,Z+7
 2989 0998 A901      		movw r20,r18
 2990 099a 0E94 0000 		call memcpy
2609:../../Source/queue.c **** 
2610:../../Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
 2992               	.LM362:
 2993 099e F801      		movw r30,r16
 2994 09a0 8081      		ld r24,Z
 2995 09a2 8823      		tst r24
 2996 09a4 01F0      		breq .L230
 2997               	.L231:
2611:../../Source/queue.c **** 			{
2612:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2613:../../Source/queue.c **** 				{
2614:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2615:../../Source/queue.c **** 					{
2616:../../Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2617:../../Source/queue.c **** 					}
2618:../../Source/queue.c **** 					else
2619:../../Source/queue.c **** 					{
2620:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2621:../../Source/queue.c **** 					}
2622:../../Source/queue.c **** 				}
2623:../../Source/queue.c **** 				else
2624:../../Source/queue.c **** 				{
2625:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2626:../../Source/queue.c **** 				}
2627:../../Source/queue.c **** 			}
2628:../../Source/queue.c **** 			else
2629:../../Source/queue.c **** 			{
2630:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2631:../../Source/queue.c **** 			}
2632:../../Source/queue.c **** 
2633:../../Source/queue.c **** 			xReturn = pdPASS;
 2999               	.LM363:
 3000 09a6 81E0      		ldi r24,lo8(1)
 3001 09a8 00C0      		rjmp .L228
 3002               	.L230:
2612:../../Source/queue.c **** 				{
 3004               	.LM364:
 3005 09aa 8885      		ldd r24,Y+8
 3006 09ac 8823      		tst r24
 3007 09ae 01F0      		breq .L231
2614:../../Source/queue.c **** 					{
 3009               	.LM365:
 3010 09b0 CE01      		movw r24,r28
 3011 09b2 0896      		adiw r24,8
 3012 09b4 0E94 0000 		call xCoRoutineRemoveFromEventList
 3013 09b8 8823      		tst r24
 3014 09ba 01F0      		breq .L231
2616:../../Source/queue.c **** 					}
 3016               	.LM366:
 3017 09bc 81E0      		ldi r24,lo8(1)
 3018 09be F801      		movw r30,r16
 3019 09c0 8083      		st Z,r24
 3020 09c2 00C0      		rjmp .L228
 3021               	.L232:
2634:../../Source/queue.c **** 		}
2635:../../Source/queue.c **** 		else
2636:../../Source/queue.c **** 		{
2637:../../Source/queue.c **** 			xReturn = pdFAIL;
 3023               	.LM367:
 3024 09c4 80E0      		ldi r24,0
 3025               	.L228:
 3026               	/* epilogue start */
2638:../../Source/queue.c **** 		}
2639:../../Source/queue.c **** 
2640:../../Source/queue.c **** 		return xReturn;
2641:../../Source/queue.c **** 	}
 3028               	.LM368:
 3029 09c6 DF91      		pop r29
 3030 09c8 CF91      		pop r28
 3031 09ca 1F91      		pop r17
 3032 09cc 0F91      		pop r16
 3033 09ce 0895      		ret
 3038               	.Lscope24:
 3040               		.stabd	78,0,0
 3042               	.Letext0:
 3043               		.ident	"GCC: (GNU) 5.4.0"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
     /tmp/ccGlptHE.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccGlptHE.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccGlptHE.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccGlptHE.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccGlptHE.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccGlptHE.s:202    .text:0000000000000000 prvIsQueueEmpty
     /tmp/ccGlptHE.s:256    .text:0000000000000016 prvCopyDataToQueue
     /tmp/ccGlptHE.s:382    .text:00000000000000a6 prvCopyDataFromQueue
     /tmp/ccGlptHE.s:435    .text:00000000000000da prvUnlockQueue
     /tmp/ccGlptHE.s:592    .text:0000000000000156 xQueueGenericReset
     /tmp/ccGlptHE.s:717    .text:00000000000001d4 xQueueGenericCreate
     /tmp/ccGlptHE.s:796    .text:000000000000021a xQueueGenericSend
     /tmp/ccGlptHE.s:1105   .text:0000000000000346 xQueueGenericSendFromISR
     /tmp/ccGlptHE.s:1212   .text:00000000000003a6 xQueueGiveFromISR
     /tmp/ccGlptHE.s:1309   .text:00000000000003ec xQueueReceive
     /tmp/ccGlptHE.s:1592   .text:0000000000000510 xQueueSemaphoreTake
     /tmp/ccGlptHE.s:1863   .text:000000000000061c xQueuePeek
     /tmp/ccGlptHE.s:2150   .text:0000000000000740 xQueueReceiveFromISR
     /tmp/ccGlptHE.s:2259   .text:000000000000079e xQueuePeekFromISR
     /tmp/ccGlptHE.s:2319   .text:00000000000007cc uxQueueMessagesWaiting
     /tmp/ccGlptHE.s:2369   .text:00000000000007dc uxQueueSpacesAvailable
     /tmp/ccGlptHE.s:2420   .text:00000000000007f0 uxQueueMessagesWaitingFromISR
     /tmp/ccGlptHE.s:2447   .text:00000000000007f6 vQueueDelete
     /tmp/ccGlptHE.s:2467   .text:00000000000007fa xQueueIsQueueEmptyFromISR
     /tmp/ccGlptHE.s:2497   .text:0000000000000806 xQueueIsQueueFullFromISR
     /tmp/ccGlptHE.s:2530   .text:0000000000000814 xQueueCRSend
     /tmp/ccGlptHE.s:2696   .text:0000000000000882 xQueueCRReceive
     /tmp/ccGlptHE.s:2863   .text:0000000000000910 xQueueCRSendFromISR
     /tmp/ccGlptHE.s:2934   .text:0000000000000956 xQueueCRReceiveFromISR

UNDEFINED SYMBOLS
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
vPortYield
vListInitialise
pvPortMalloc
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortFree
vCoRoutineAddToDelayedList
xCoRoutineRemoveFromEventList
