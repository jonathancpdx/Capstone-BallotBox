   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 191               	prvResetNextTaskUnblockTime:
 192               		.stabd	46,0,0
   1:../../Source/tasks.c **** /*
   2:../../Source/tasks.c ****  * FreeRTOS Kernel V10.3.1
   3:../../Source/tasks.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../../Source/tasks.c ****  *
   5:../../Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../../Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../../Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:../../Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../../Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../../Source/tasks.c ****  * subject to the following conditions:
  11:../../Source/tasks.c ****  *
  12:../../Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../../Source/tasks.c ****  * copies or substantial portions of the Software.
  14:../../Source/tasks.c ****  *
  15:../../Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../../Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../../Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../../Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../../Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../../Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../../Source/tasks.c ****  *
  22:../../Source/tasks.c ****  * http://www.FreeRTOS.org
  23:../../Source/tasks.c ****  * http://aws.amazon.com/freertos
  24:../../Source/tasks.c ****  *
  25:../../Source/tasks.c ****  * 1 tab == 4 spaces!
  26:../../Source/tasks.c ****  */
  27:../../Source/tasks.c **** 
  28:../../Source/tasks.c **** /* Standard includes. */
  29:../../Source/tasks.c **** #include <stdlib.h>
  30:../../Source/tasks.c **** #include <string.h>
  31:../../Source/tasks.c **** 
  32:../../Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:../../Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:../../Source/tasks.c **** task.h is included from an application file. */
  35:../../Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:../../Source/tasks.c **** 
  37:../../Source/tasks.c **** /* FreeRTOS includes. */
  38:../../Source/tasks.c **** #include "FreeRTOS.h"
  39:../../Source/tasks.c **** #include "task.h"
  40:../../Source/tasks.c **** #include "timers.h"
  41:../../Source/tasks.c **** #include "stack_macros.h"
  42:../../Source/tasks.c **** 
  43:../../Source/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:../../Source/tasks.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:../../Source/tasks.c **** for the header files above, but not in this file, in order to generate the
  46:../../Source/tasks.c **** correct privileged Vs unprivileged linkage and placement. */
  47:../../Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:../../Source/tasks.c **** 
  49:../../Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  50:../../Source/tasks.c **** functions but without including stdio.h here. */
  51:../../Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  52:../../Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  53:../../Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  54:../../Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:../../Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  56:../../Source/tasks.c **** 	#include <stdio.h>
  57:../../Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:../../Source/tasks.c **** 
  59:../../Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  60:../../Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  61:../../Source/tasks.c **** 	performed just because a higher priority task has been woken. */
  62:../../Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  63:../../Source/tasks.c **** #else
  64:../../Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  65:../../Source/tasks.c **** #endif
  66:../../Source/tasks.c **** 
  67:../../Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  68:../../Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  69:../../Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  70:../../Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  71:../../Source/tasks.c **** 
  72:../../Source/tasks.c **** /*
  73:../../Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  74:../../Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  75:../../Source/tasks.c ****  */
  76:../../Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  77:../../Source/tasks.c **** 
  78:../../Source/tasks.c **** /* Bits used to recored how a task's stack and TCB were allocated. */
  79:../../Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  80:../../Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  81:../../Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
  82:../../Source/tasks.c **** 
  83:../../Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
  84:../../Source/tasks.c **** value so the high water mark can be determined.  If none of the following are
  85:../../Source/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
  86:../../Source/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
  87:../../Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
  88:../../Source/tasks.c **** #else
  89:../../Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
  90:../../Source/tasks.c **** #endif
  91:../../Source/tasks.c **** 
  92:../../Source/tasks.c **** /*
  93:../../Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
  94:../../Source/tasks.c ****  */
  95:../../Source/tasks.c **** #define tskRUNNING_CHAR		( 'X' )
  96:../../Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
  97:../../Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
  98:../../Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
  99:../../Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 100:../../Source/tasks.c **** 
 101:../../Source/tasks.c **** /*
 102:../../Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 103:../../Source/tasks.c ****  * global, rather than file scope.
 104:../../Source/tasks.c ****  */
 105:../../Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 106:../../Source/tasks.c **** 	#define static
 107:../../Source/tasks.c **** #endif
 108:../../Source/tasks.c **** 
 109:../../Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 110:../../Source/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 111:../../Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 112:../../Source/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 113:../../Source/tasks.c **** #endif
 114:../../Source/tasks.c **** 
 115:../../Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 116:../../Source/tasks.c **** 
 117:../../Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 118:../../Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 119:../../Source/tasks.c **** 	microcontroller architecture. */
 120:../../Source/tasks.c **** 
 121:../../Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 122:../../Source/tasks.c **** 	state task. */
 123:../../Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 124:../../Source/tasks.c **** 	{																									\
 125:../../Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 126:../../Source/tasks.c **** 		{																								\
 127:../../Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 128:../../Source/tasks.c **** 		}																								\
 129:../../Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 130:../../Source/tasks.c **** 
 131:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 132:../../Source/tasks.c **** 
 133:../../Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 134:../../Source/tasks.c **** 	{																									\
 135:../../Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 136:../../Source/tasks.c **** 																										\
 137:../../Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 138:../../Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 139:../../Source/tasks.c **** 		{																								\
 140:../../Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 141:../../Source/tasks.c **** 			--uxTopPriority;																			\
 142:../../Source/tasks.c **** 		}																								\
 143:../../Source/tasks.c **** 																										\
 144:../../Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 145:../../Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 146:../../Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 147:../../Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 148:../../Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 149:../../Source/tasks.c **** 
 150:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 151:../../Source/tasks.c **** 
 152:../../Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 153:../../Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 154:../../Source/tasks.c **** 	being used. */
 155:../../Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 156:../../Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 157:../../Source/tasks.c **** 
 158:../../Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 159:../../Source/tasks.c **** 
 160:../../Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 161:../../Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 162:../../Source/tasks.c **** 	architecture being used. */
 163:../../Source/tasks.c **** 
 164:../../Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 165:../../Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 166:../../Source/tasks.c **** 
 167:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 168:../../Source/tasks.c **** 
 169:../../Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 170:../../Source/tasks.c **** 	{																								\
 171:../../Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 172:../../Source/tasks.c **** 																									\
 173:../../Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 174:../../Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 175:../../Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 176:../../Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 177:../../Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 178:../../Source/tasks.c **** 
 179:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 180:../../Source/tasks.c **** 
 181:../../Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 182:../../Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 183:../../Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 184:../../Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 185:../../Source/tasks.c **** 	{																									\
 186:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 187:../../Source/tasks.c **** 		{																								\
 188:../../Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 189:../../Source/tasks.c **** 		}																								\
 190:../../Source/tasks.c **** 	}
 191:../../Source/tasks.c **** 
 192:../../Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 193:../../Source/tasks.c **** 
 194:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 195:../../Source/tasks.c **** 
 196:../../Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 197:../../Source/tasks.c **** count overflows. */
 198:../../Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 199:../../Source/tasks.c **** {																									\
 200:../../Source/tasks.c **** 	List_t *pxTemp;																					\
 201:../../Source/tasks.c **** 																									\
 202:../../Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 203:../../Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 204:../../Source/tasks.c **** 																									\
 205:../../Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 206:../../Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 207:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 208:../../Source/tasks.c **** 	xNumOfOverflows++;																				\
 209:../../Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 210:../../Source/tasks.c **** }
 211:../../Source/tasks.c **** 
 212:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 213:../../Source/tasks.c **** 
 214:../../Source/tasks.c **** /*
 215:../../Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 216:../../Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 217:../../Source/tasks.c ****  */
 218:../../Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 219:../../Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 220:../../Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 221:../../Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 222:../../Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 223:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 224:../../Source/tasks.c **** 
 225:../../Source/tasks.c **** /*
 226:../../Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 227:../../Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 228:../../Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 229:../../Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 230:../../Source/tasks.c ****  */
 231:../../Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
 232:../../Source/tasks.c **** 
 233:../../Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 234:../../Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 235:../../Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 236:../../Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 237:../../Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 238:../../Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 239:../../Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 240:../../Source/tasks.c **** to its original value when it is released. */
 241:../../Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 242:../../Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 243:../../Source/tasks.c **** #else
 244:../../Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 245:../../Source/tasks.c **** #endif
 246:../../Source/tasks.c **** 
 247:../../Source/tasks.c **** /*
 248:../../Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 249:../../Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 250:../../Source/tasks.c ****  * (the task's run time environment, including register values)
 251:../../Source/tasks.c ****  */
 252:../../Source/tasks.c **** typedef struct tskTaskControlBlock 			/* The old naming convention is used to prevent breaking kern
 253:../../Source/tasks.c **** {
 254:../../Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 255:../../Source/tasks.c **** 
 256:../../Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 257:../../Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 258:../../Source/tasks.c **** 	#endif
 259:../../Source/tasks.c **** 
 260:../../Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 261:../../Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 262:../../Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 263:../../Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 264:../../Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 265:../../Source/tasks.c **** 
 266:../../Source/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 267:../../Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 268:../../Source/tasks.c **** 	#endif
 269:../../Source/tasks.c **** 
 270:../../Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 271:../../Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 272:../../Source/tasks.c **** 	#endif
 273:../../Source/tasks.c **** 
 274:../../Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 275:../../Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 276:../../Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 277:../../Source/tasks.c **** 	#endif
 278:../../Source/tasks.c **** 
 279:../../Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 280:../../Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 281:../../Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 282:../../Source/tasks.c **** 	#endif
 283:../../Source/tasks.c **** 
 284:../../Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 285:../../Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 286:../../Source/tasks.c **** 	#endif
 287:../../Source/tasks.c **** 
 288:../../Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 289:../../Source/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 290:../../Source/tasks.c **** 	#endif
 291:../../Source/tasks.c **** 
 292:../../Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 293:../../Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 294:../../Source/tasks.c **** 	#endif
 295:../../Source/tasks.c **** 
 296:../../Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 297:../../Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 298:../../Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 299:../../Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 300:../../Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 301:../../Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 302:../../Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 303:../../Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks.
 304:../../Source/tasks.c **** 
 305:../../Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
 306:../../Source/tasks.c **** 		for additional information. */
 307:../../Source/tasks.c **** 		struct	_reent xNewLib_reent;
 308:../../Source/tasks.c **** 	#endif
 309:../../Source/tasks.c **** 
 310:../../Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 311:../../Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 312:../../Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 313:../../Source/tasks.c **** 	#endif
 314:../../Source/tasks.c **** 
 315:../../Source/tasks.c **** 	/* See the comments in FreeRTOS.h with the definition of
 316:../../Source/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 317:../../Source/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolida
 318:../../Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 319:../../Source/tasks.c **** 	#endif
 320:../../Source/tasks.c **** 
 321:../../Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 322:../../Source/tasks.c **** 		uint8_t ucDelayAborted;
 323:../../Source/tasks.c **** 	#endif
 324:../../Source/tasks.c **** 
 325:../../Source/tasks.c **** 	#if( configUSE_POSIX_ERRNO == 1 )
 326:../../Source/tasks.c **** 		int iTaskErrno;
 327:../../Source/tasks.c **** 	#endif
 328:../../Source/tasks.c **** 
 329:../../Source/tasks.c **** } tskTCB;
 330:../../Source/tasks.c **** 
 331:../../Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 332:../../Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 333:../../Source/tasks.c **** typedef tskTCB TCB_t;
 334:../../Source/tasks.c **** 
 335:../../Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 336:../../Source/tasks.c **** which static variables must be declared volatile. */
 337:../../Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 338:../../Source/tasks.c **** 
 339:../../Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 340:../../Source/tasks.c **** xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
 341:../../Source/tasks.c **** doing so breaks some kernel aware debuggers and debuggers that rely on removing
 342:../../Source/tasks.c **** the static qualifier. */
 343:../../Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 344:../../Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 345:../../Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 346:../../Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 347:../../Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 348:../../Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 349:../../Source/tasks.c **** 
 350:../../Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 351:../../Source/tasks.c **** 
 352:../../Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 353:../../Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 354:../../Source/tasks.c **** 
 355:../../Source/tasks.c **** #endif
 356:../../Source/tasks.c **** 
 357:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 358:../../Source/tasks.c **** 
 359:../../Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 360:../../Source/tasks.c **** 
 361:../../Source/tasks.c **** #endif
 362:../../Source/tasks.c **** 
 363:../../Source/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 364:../../Source/tasks.c **** the errno of the currently running task. */
 365:../../Source/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 366:../../Source/tasks.c **** 	int FreeRTOS_errno = 0;
 367:../../Source/tasks.c **** #endif
 368:../../Source/tasks.c **** 
 369:../../Source/tasks.c **** /* Other file private variables. --------------------------------*/
 370:../../Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 371:../../Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 372:../../Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 373:../../Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 374:../../Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xPendedTicks 			= ( TickType_t ) 0U;
 375:../../Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 376:../../Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 377:../../Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 378:../../Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 379:../../Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 380:../../Source/tasks.c **** 
 381:../../Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 382:../../Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 383:../../Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 384:../../Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 385:../../Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 386:../../Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 387:../../Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 388:../../Source/tasks.c **** accessed from a critical section. */
 389:../../Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 390:../../Source/tasks.c **** 
 391:../../Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 392:../../Source/tasks.c **** 
 393:../../Source/tasks.c **** 	/* Do not move these variables to function scope as doing so prevents the
 394:../../Source/tasks.c **** 	code working with debuggers that need to remove the static qualifier. */
 395:../../Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 396:../../Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 397:../../Source/tasks.c **** 
 398:../../Source/tasks.c **** #endif
 399:../../Source/tasks.c **** 
 400:../../Source/tasks.c **** /*lint -restore */
 401:../../Source/tasks.c **** 
 402:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 403:../../Source/tasks.c **** 
 404:../../Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 405:../../Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 406:../../Source/tasks.c **** 
 407:../../Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 408:../../Source/tasks.c **** 
 409:../../Source/tasks.c **** #endif
 410:../../Source/tasks.c **** 
 411:../../Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 412:../../Source/tasks.c **** 
 413:../../Source/tasks.c **** 	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application 
 414:../../Source/tasks.c **** 
 415:../../Source/tasks.c **** #endif
 416:../../Source/tasks.c **** 
 417:../../Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 418:../../Source/tasks.c **** 
 419:../../Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 420:../../Source/tasks.c **** 
 421:../../Source/tasks.c **** #endif
 422:../../Source/tasks.c **** 
 423:../../Source/tasks.c **** /* File private functions. --------------------------------*/
 424:../../Source/tasks.c **** 
 425:../../Source/tasks.c **** /**
 426:../../Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 427:../../Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 428:../../Source/tasks.c ****  * is in any other state.
 429:../../Source/tasks.c ****  */
 430:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 431:../../Source/tasks.c **** 
 432:../../Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 433:../../Source/tasks.c **** 
 434:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 435:../../Source/tasks.c **** 
 436:../../Source/tasks.c **** /*
 437:../../Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 438:../../Source/tasks.c ****  * automatically upon the creation of the first task.
 439:../../Source/tasks.c ****  */
 440:../../Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 441:../../Source/tasks.c **** 
 442:../../Source/tasks.c **** /*
 443:../../Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 444:../../Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 445:../../Source/tasks.c ****  * creation of the first user task.
 446:../../Source/tasks.c ****  *
 447:../../Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 448:../../Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 449:../../Source/tasks.c ****  *
 450:../../Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 451:../../Source/tasks.c ****  *
 452:../../Source/tasks.c ****  */
 453:../../Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 454:../../Source/tasks.c **** 
 455:../../Source/tasks.c **** /*
 456:../../Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 457:../../Source/tasks.c ****  * including the stack pointed to by the TCB.
 458:../../Source/tasks.c ****  *
 459:../../Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 460:../../Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 461:../../Source/tasks.c ****  */
 462:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 463:../../Source/tasks.c **** 
 464:../../Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 465:../../Source/tasks.c **** 
 466:../../Source/tasks.c **** #endif
 467:../../Source/tasks.c **** 
 468:../../Source/tasks.c **** /*
 469:../../Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 470:../../Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 471:../../Source/tasks.c ****  * and its TCB deleted.
 472:../../Source/tasks.c ****  */
 473:../../Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 474:../../Source/tasks.c **** 
 475:../../Source/tasks.c **** /*
 476:../../Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 477:../../Source/tasks.c ****  * either the current or the overflow delayed task list.
 478:../../Source/tasks.c ****  */
 479:../../Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 480:../../Source/tasks.c **** 
 481:../../Source/tasks.c **** /*
 482:../../Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 483:../../Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 484:../../Source/tasks.c ****  * a suspended list, etc.).
 485:../../Source/tasks.c ****  *
 486:../../Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 487:../../Source/tasks.c ****  * NORMAL APPLICATION CODE.
 488:../../Source/tasks.c ****  */
 489:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 490:../../Source/tasks.c **** 
 491:../../Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 492:../../Source/tasks.c **** 
 493:../../Source/tasks.c **** #endif
 494:../../Source/tasks.c **** 
 495:../../Source/tasks.c **** /*
 496:../../Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 497:../../Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 498:../../Source/tasks.c ****  */
 499:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 500:../../Source/tasks.c **** 
 501:../../Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 502:../../Source/tasks.c **** 
 503:../../Source/tasks.c **** #endif
 504:../../Source/tasks.c **** 
 505:../../Source/tasks.c **** /*
 506:../../Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 507:../../Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 508:../../Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 509:../../Source/tasks.c ****  */
 510:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
 511:../../Source/tasks.c **** 
 512:../../Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGE
 513:../../Source/tasks.c **** 
 514:../../Source/tasks.c **** #endif
 515:../../Source/tasks.c **** 
 516:../../Source/tasks.c **** /*
 517:../../Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 518:../../Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 519:../../Source/tasks.c ****  *
 520:../../Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 521:../../Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 522:../../Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 523:../../Source/tasks.c ****  * set to a value other than 1.
 524:../../Source/tasks.c ****  */
 525:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 526:../../Source/tasks.c **** 
 527:../../Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 528:../../Source/tasks.c **** 
 529:../../Source/tasks.c **** #endif
 530:../../Source/tasks.c **** 
 531:../../Source/tasks.c **** /*
 532:../../Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 533:../../Source/tasks.c ****  * will exit the Blocked state.
 534:../../Source/tasks.c ****  */
 535:../../Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 536:../../Source/tasks.c **** 
 537:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 538:../../Source/tasks.c **** 
 539:../../Source/tasks.c **** 	/*
 540:../../Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 541:../../Source/tasks.c **** 	 * human readable tables of task information.
 542:../../Source/tasks.c **** 	 */
 543:../../Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 544:../../Source/tasks.c **** 
 545:../../Source/tasks.c **** #endif
 546:../../Source/tasks.c **** 
 547:../../Source/tasks.c **** /*
 548:../../Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 549:../../Source/tasks.c ****  * dynamically to fill in the structure's members.
 550:../../Source/tasks.c ****  */
 551:../../Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 552:../../Source/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 553:../../Source/tasks.c **** 									const uint32_t ulStackDepth,
 554:../../Source/tasks.c **** 									void * const pvParameters,
 555:../../Source/tasks.c **** 									UBaseType_t uxPriority,
 556:../../Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 557:../../Source/tasks.c **** 									TCB_t *pxNewTCB,
 558:../../Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 559:../../Source/tasks.c **** 
 560:../../Source/tasks.c **** /*
 561:../../Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 562:../../Source/tasks.c ****  * under the control of the scheduler.
 563:../../Source/tasks.c ****  */
 564:../../Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 565:../../Source/tasks.c **** 
 566:../../Source/tasks.c **** /*
 567:../../Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 568:../../Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 569:../../Source/tasks.c ****  * called by the function.
 570:../../Source/tasks.c ****  */
 571:../../Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 572:../../Source/tasks.c **** 
 573:../../Source/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 574:../../Source/tasks.c **** 
 575:../../Source/tasks.c **** #endif
 576:../../Source/tasks.c **** 
 577:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 578:../../Source/tasks.c **** 
 579:../../Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 580:../../Source/tasks.c **** 
 581:../../Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 582:../../Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 583:../../Source/tasks.c **** 									const uint32_t ulStackDepth,
 584:../../Source/tasks.c **** 									void * const pvParameters,
 585:../../Source/tasks.c **** 									UBaseType_t uxPriority,
 586:../../Source/tasks.c **** 									StackType_t * const puxStackBuffer,
 587:../../Source/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 588:../../Source/tasks.c **** 	{
 589:../../Source/tasks.c **** 	TCB_t *pxNewTCB;
 590:../../Source/tasks.c **** 	TaskHandle_t xReturn;
 591:../../Source/tasks.c **** 
 592:../../Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 593:../../Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 594:../../Source/tasks.c **** 
 595:../../Source/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 596:../../Source/tasks.c **** 		{
 597:../../Source/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 598:../../Source/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 599:../../Source/tasks.c **** 			structure. */
 600:../../Source/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 601:../../Source/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 602:../../Source/tasks.c **** 			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 603:../../Source/tasks.c **** 		}
 604:../../Source/tasks.c **** 		#endif /* configASSERT_DEFINED */
 605:../../Source/tasks.c **** 
 606:../../Source/tasks.c **** 
 607:../../Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 608:../../Source/tasks.c **** 		{
 609:../../Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 610:../../Source/tasks.c **** 			function - use them. */
 611:../../Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures ar
 612:../../Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 613:../../Source/tasks.c **** 
 614:../../Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consoli
 615:../../Source/tasks.c **** 			{
 616:../../Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 617:../../Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 618:../../Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 619:../../Source/tasks.c **** 			}
 620:../../Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 621:../../Source/tasks.c **** 
 622:../../Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 623:../../Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 624:../../Source/tasks.c **** 		}
 625:../../Source/tasks.c **** 		else
 626:../../Source/tasks.c **** 		{
 627:../../Source/tasks.c **** 			xReturn = NULL;
 628:../../Source/tasks.c **** 		}
 629:../../Source/tasks.c **** 
 630:../../Source/tasks.c **** 		return xReturn;
 631:../../Source/tasks.c **** 	}
 632:../../Source/tasks.c **** 
 633:../../Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 634:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 635:../../Source/tasks.c **** 
 636:../../Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 637:../../Source/tasks.c **** 
 638:../../Source/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 639:../../Source/tasks.c **** 	{
 640:../../Source/tasks.c **** 	TCB_t *pxNewTCB;
 641:../../Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 642:../../Source/tasks.c **** 
 643:../../Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 644:../../Source/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 645:../../Source/tasks.c **** 
 646:../../Source/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 647:../../Source/tasks.c **** 		{
 648:../../Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 649:../../Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 650:../../Source/tasks.c **** 			not static allocation is being used. */
 651:../../Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 652:../../Source/tasks.c **** 
 653:../../Source/tasks.c **** 			/* Store the stack location in the TCB. */
 654:../../Source/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 655:../../Source/tasks.c **** 
 656:../../Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 657:../../Source/tasks.c **** 			{
 658:../../Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 659:../../Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 660:../../Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 661:../../Source/tasks.c **** 			}
 662:../../Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 663:../../Source/tasks.c **** 
 664:../../Source/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 665:../../Source/tasks.c **** 									pxTaskDefinition->pcName,
 666:../../Source/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 667:../../Source/tasks.c **** 									pxTaskDefinition->pvParameters,
 668:../../Source/tasks.c **** 									pxTaskDefinition->uxPriority,
 669:../../Source/tasks.c **** 									pxCreatedTask, pxNewTCB,
 670:../../Source/tasks.c **** 									pxTaskDefinition->xRegions );
 671:../../Source/tasks.c **** 
 672:../../Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 673:../../Source/tasks.c **** 			xReturn = pdPASS;
 674:../../Source/tasks.c **** 		}
 675:../../Source/tasks.c **** 
 676:../../Source/tasks.c **** 		return xReturn;
 677:../../Source/tasks.c **** 	}
 678:../../Source/tasks.c **** 
 679:../../Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 680:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 681:../../Source/tasks.c **** 
 682:../../Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 683:../../Source/tasks.c **** 
 684:../../Source/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 685:../../Source/tasks.c **** 	{
 686:../../Source/tasks.c **** 	TCB_t *pxNewTCB;
 687:../../Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 688:../../Source/tasks.c **** 
 689:../../Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 690:../../Source/tasks.c **** 
 691:../../Source/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 692:../../Source/tasks.c **** 		{
 693:../../Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 694:../../Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 695:../../Source/tasks.c **** 			not static allocation is being used. */
 696:../../Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 697:../../Source/tasks.c **** 
 698:../../Source/tasks.c **** 			if( pxNewTCB != NULL )
 699:../../Source/tasks.c **** 			{
 700:../../Source/tasks.c **** 				/* Store the stack location in the TCB. */
 701:../../Source/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 702:../../Source/tasks.c **** 
 703:../../Source/tasks.c **** 				#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 704:../../Source/tasks.c **** 				{
 705:../../Source/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 706:../../Source/tasks.c **** 					this task had a statically allocated stack in case it is
 707:../../Source/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 708:../../Source/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 709:../../Source/tasks.c **** 				}
 710:../../Source/tasks.c **** 				#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 711:../../Source/tasks.c **** 
 712:../../Source/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 713:../../Source/tasks.c **** 										pxTaskDefinition->pcName,
 714:../../Source/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 715:../../Source/tasks.c **** 										pxTaskDefinition->pvParameters,
 716:../../Source/tasks.c **** 										pxTaskDefinition->uxPriority,
 717:../../Source/tasks.c **** 										pxCreatedTask, pxNewTCB,
 718:../../Source/tasks.c **** 										pxTaskDefinition->xRegions );
 719:../../Source/tasks.c **** 
 720:../../Source/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 721:../../Source/tasks.c **** 				xReturn = pdPASS;
 722:../../Source/tasks.c **** 			}
 723:../../Source/tasks.c **** 		}
 724:../../Source/tasks.c **** 
 725:../../Source/tasks.c **** 		return xReturn;
 726:../../Source/tasks.c **** 	}
 727:../../Source/tasks.c **** 
 728:../../Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 729:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 730:../../Source/tasks.c **** 
 731:../../Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 732:../../Source/tasks.c **** 
 733:../../Source/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 734:../../Source/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 735:../../Source/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
 736:../../Source/tasks.c **** 							void * const pvParameters,
 737:../../Source/tasks.c **** 							UBaseType_t uxPriority,
 738:../../Source/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 739:../../Source/tasks.c **** 	{
 740:../../Source/tasks.c **** 	TCB_t *pxNewTCB;
 741:../../Source/tasks.c **** 	BaseType_t xReturn;
 742:../../Source/tasks.c **** 
 743:../../Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 744:../../Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 745:../../Source/tasks.c **** 		the TCB then the stack. */
 746:../../Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 747:../../Source/tasks.c **** 		{
 748:../../Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 749:../../Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 750:../../Source/tasks.c **** 			allocation is being used. */
 751:../../Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 752:../../Source/tasks.c **** 
 753:../../Source/tasks.c **** 			if( pxNewTCB != NULL )
 754:../../Source/tasks.c **** 			{
 755:../../Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 756:../../Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 757:../../Source/tasks.c **** 				be deleted later if required. */
 758:../../Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 759:../../Source/tasks.c **** 
 760:../../Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 761:../../Source/tasks.c **** 				{
 762:../../Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 763:../../Source/tasks.c **** 					vPortFree( pxNewTCB );
 764:../../Source/tasks.c **** 					pxNewTCB = NULL;
 765:../../Source/tasks.c **** 				}
 766:../../Source/tasks.c **** 			}
 767:../../Source/tasks.c **** 		}
 768:../../Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 769:../../Source/tasks.c **** 		{
 770:../../Source/tasks.c **** 		StackType_t *pxStack;
 771:../../Source/tasks.c **** 
 772:../../Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 773:../../Source/tasks.c **** 			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079
 774:../../Source/tasks.c **** 
 775:../../Source/tasks.c **** 			if( pxStack != NULL )
 776:../../Source/tasks.c **** 			{
 777:../../Source/tasks.c **** 				/* Allocate space for the TCB. */
 778:../../Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returne
 779:../../Source/tasks.c **** 
 780:../../Source/tasks.c **** 				if( pxNewTCB != NULL )
 781:../../Source/tasks.c **** 				{
 782:../../Source/tasks.c **** 					/* Store the stack location in the TCB. */
 783:../../Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 784:../../Source/tasks.c **** 				}
 785:../../Source/tasks.c **** 				else
 786:../../Source/tasks.c **** 				{
 787:../../Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 788:../../Source/tasks.c **** 					it again. */
 789:../../Source/tasks.c **** 					vPortFree( pxStack );
 790:../../Source/tasks.c **** 				}
 791:../../Source/tasks.c **** 			}
 792:../../Source/tasks.c **** 			else
 793:../../Source/tasks.c **** 			{
 794:../../Source/tasks.c **** 				pxNewTCB = NULL;
 795:../../Source/tasks.c **** 			}
 796:../../Source/tasks.c **** 		}
 797:../../Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 798:../../Source/tasks.c **** 
 799:../../Source/tasks.c **** 		if( pxNewTCB != NULL )
 800:../../Source/tasks.c **** 		{
 801:../../Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consoli
 802:../../Source/tasks.c **** 			{
 803:../../Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 804:../../Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 805:../../Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 806:../../Source/tasks.c **** 			}
 807:../../Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 808:../../Source/tasks.c **** 
 809:../../Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 810:../../Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 811:../../Source/tasks.c **** 			xReturn = pdPASS;
 812:../../Source/tasks.c **** 		}
 813:../../Source/tasks.c **** 		else
 814:../../Source/tasks.c **** 		{
 815:../../Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 816:../../Source/tasks.c **** 		}
 817:../../Source/tasks.c **** 
 818:../../Source/tasks.c **** 		return xReturn;
 819:../../Source/tasks.c **** 	}
 820:../../Source/tasks.c **** 
 821:../../Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 822:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 823:../../Source/tasks.c **** 
 824:../../Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 825:../../Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 826:../../Source/tasks.c **** 									const uint32_t ulStackDepth,
 827:../../Source/tasks.c **** 									void * const pvParameters,
 828:../../Source/tasks.c **** 									UBaseType_t uxPriority,
 829:../../Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 830:../../Source/tasks.c **** 									TCB_t *pxNewTCB,
 831:../../Source/tasks.c **** 									const MemoryRegion_t * const xRegions )
 832:../../Source/tasks.c **** {
 833:../../Source/tasks.c **** StackType_t *pxTopOfStack;
 834:../../Source/tasks.c **** UBaseType_t x;
 835:../../Source/tasks.c **** 
 836:../../Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 837:../../Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 838:../../Source/tasks.c **** 		BaseType_t xRunPrivileged;
 839:../../Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 840:../../Source/tasks.c **** 		{
 841:../../Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 842:../../Source/tasks.c **** 		}
 843:../../Source/tasks.c **** 		else
 844:../../Source/tasks.c **** 		{
 845:../../Source/tasks.c **** 			xRunPrivileged = pdFALSE;
 846:../../Source/tasks.c **** 		}
 847:../../Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 848:../../Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 849:../../Source/tasks.c **** 
 850:../../Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 851:../../Source/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 852:../../Source/tasks.c **** 	{
 853:../../Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 854:../../Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 855:../../Source/tasks.c **** 	}
 856:../../Source/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 857:../../Source/tasks.c **** 
 858:../../Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 859:../../Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 860:../../Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 861:../../Source/tasks.c **** 	by the port. */
 862:../../Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 863:../../Source/tasks.c **** 	{
 864:../../Source/tasks.c **** 		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 865:../../Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 866:../../Source/tasks.c **** 
 867:../../Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 868:../../Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 869:../../Source/tasks.c **** 
 870:../../Source/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 871:../../Source/tasks.c **** 		{
 872:../../Source/tasks.c **** 			/* Also record the stack's high address, which may assist
 873:../../Source/tasks.c **** 			debugging. */
 874:../../Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 875:../../Source/tasks.c **** 		}
 876:../../Source/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 877:../../Source/tasks.c **** 	}
 878:../../Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 879:../../Source/tasks.c **** 	{
 880:../../Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 881:../../Source/tasks.c **** 
 882:../../Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 883:../../Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 884:../../Source/tasks.c **** 
 885:../../Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 886:../../Source/tasks.c **** 		performed. */
 887:../../Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 888:../../Source/tasks.c **** 	}
 889:../../Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 890:../../Source/tasks.c **** 
 891:../../Source/tasks.c **** 	/* Store the task name in the TCB. */
 892:../../Source/tasks.c **** 	if( pcName != NULL )
 893:../../Source/tasks.c **** 	{
 894:../../Source/tasks.c **** 		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 895:../../Source/tasks.c **** 		{
 896:../../Source/tasks.c **** 			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 897:../../Source/tasks.c **** 
 898:../../Source/tasks.c **** 			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 899:../../Source/tasks.c **** 			configMAX_TASK_NAME_LEN characters just in case the memory after the
 900:../../Source/tasks.c **** 			string is not accessible (extremely unlikely). */
 901:../../Source/tasks.c **** 			if( pcName[ x ] == ( char ) 0x00 )
 902:../../Source/tasks.c **** 			{
 903:../../Source/tasks.c **** 				break;
 904:../../Source/tasks.c **** 			}
 905:../../Source/tasks.c **** 			else
 906:../../Source/tasks.c **** 			{
 907:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 908:../../Source/tasks.c **** 			}
 909:../../Source/tasks.c **** 		}
 910:../../Source/tasks.c **** 
 911:../../Source/tasks.c **** 		/* Ensure the name string is terminated in the case that the string length
 912:../../Source/tasks.c **** 		was greater or equal to configMAX_TASK_NAME_LEN. */
 913:../../Source/tasks.c **** 		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 914:../../Source/tasks.c **** 	}
 915:../../Source/tasks.c **** 	else
 916:../../Source/tasks.c **** 	{
 917:../../Source/tasks.c **** 		/* The task has not been given a name, so just ensure there is a NULL
 918:../../Source/tasks.c **** 		terminator when it is read out. */
 919:../../Source/tasks.c **** 		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 920:../../Source/tasks.c **** 	}
 921:../../Source/tasks.c **** 
 922:../../Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 923:../../Source/tasks.c **** 	remove the privilege bit if one is present. */
 924:../../Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 925:../../Source/tasks.c **** 	{
 926:../../Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 927:../../Source/tasks.c **** 	}
 928:../../Source/tasks.c **** 	else
 929:../../Source/tasks.c **** 	{
 930:../../Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 931:../../Source/tasks.c **** 	}
 932:../../Source/tasks.c **** 
 933:../../Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 934:../../Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 935:../../Source/tasks.c **** 	{
 936:../../Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 937:../../Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 938:../../Source/tasks.c **** 	}
 939:../../Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 940:../../Source/tasks.c **** 
 941:../../Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 942:../../Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 943:../../Source/tasks.c **** 
 944:../../Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 945:../../Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 946:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 947:../../Source/tasks.c **** 
 948:../../Source/tasks.c **** 	/* Event lists are always in priority order. */
 949:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 950:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 951:../../Source/tasks.c **** 
 952:../../Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 953:../../Source/tasks.c **** 	{
 954:../../Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 955:../../Source/tasks.c **** 	}
 956:../../Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 957:../../Source/tasks.c **** 
 958:../../Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 959:../../Source/tasks.c **** 	{
 960:../../Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 961:../../Source/tasks.c **** 	}
 962:../../Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 963:../../Source/tasks.c **** 
 964:../../Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 965:../../Source/tasks.c **** 	{
 966:../../Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 967:../../Source/tasks.c **** 	}
 968:../../Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 969:../../Source/tasks.c **** 
 970:../../Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 971:../../Source/tasks.c **** 	{
 972:../../Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 973:../../Source/tasks.c **** 	}
 974:../../Source/tasks.c **** 	#else
 975:../../Source/tasks.c **** 	{
 976:../../Source/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 977:../../Source/tasks.c **** 		( void ) xRegions;
 978:../../Source/tasks.c **** 	}
 979:../../Source/tasks.c **** 	#endif
 980:../../Source/tasks.c **** 
 981:../../Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 982:../../Source/tasks.c **** 	{
 983:../../Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 984:../../Source/tasks.c **** 		{
 985:../../Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 986:../../Source/tasks.c **** 		}
 987:../../Source/tasks.c **** 	}
 988:../../Source/tasks.c **** 	#endif
 989:../../Source/tasks.c **** 
 990:../../Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 991:../../Source/tasks.c **** 	{
 992:../../Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
 993:../../Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 994:../../Source/tasks.c **** 	}
 995:../../Source/tasks.c **** 	#endif
 996:../../Source/tasks.c **** 
 997:../../Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 998:../../Source/tasks.c **** 	{
 999:../../Source/tasks.c **** 		/* Initialise this task's Newlib reent structure.
1000:../../Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
1001:../../Source/tasks.c **** 		for additional information. */
1002:../../Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1003:../../Source/tasks.c **** 	}
1004:../../Source/tasks.c **** 	#endif
1005:../../Source/tasks.c **** 
1006:../../Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
1007:../../Source/tasks.c **** 	{
1008:../../Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
1009:../../Source/tasks.c **** 	}
1010:../../Source/tasks.c **** 	#endif
1011:../../Source/tasks.c **** 
1012:../../Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1013:../../Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1014:../../Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1015:../../Source/tasks.c **** 	the top of stack variable is updated. */
1016:../../Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1017:../../Source/tasks.c **** 	{
1018:../../Source/tasks.c **** 		/* If the port has capability to detect stack overflow,
1019:../../Source/tasks.c **** 		pass the stack end address to the stack initialization
1020:../../Source/tasks.c **** 		function as well. */
1021:../../Source/tasks.c **** 		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1022:../../Source/tasks.c **** 		{
1023:../../Source/tasks.c **** 			#if( portSTACK_GROWTH < 0 )
1024:../../Source/tasks.c **** 			{
1025:../../Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pv
1026:../../Source/tasks.c **** 			}
1027:../../Source/tasks.c **** 			#else /* portSTACK_GROWTH */
1028:../../Source/tasks.c **** 			{
1029:../../Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCod
1030:../../Source/tasks.c **** 			}
1031:../../Source/tasks.c **** 			#endif /* portSTACK_GROWTH */
1032:../../Source/tasks.c **** 		}
1033:../../Source/tasks.c **** 		#else /* portHAS_STACK_OVERFLOW_CHECKING */
1034:../../Source/tasks.c **** 		{
1035:../../Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
1036:../../Source/tasks.c **** 		}
1037:../../Source/tasks.c **** 		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
1038:../../Source/tasks.c **** 	}
1039:../../Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1040:../../Source/tasks.c **** 	{
1041:../../Source/tasks.c **** 		/* If the port has capability to detect stack overflow,
1042:../../Source/tasks.c **** 		pass the stack end address to the stack initialization
1043:../../Source/tasks.c **** 		function as well. */
1044:../../Source/tasks.c **** 		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1045:../../Source/tasks.c **** 		{
1046:../../Source/tasks.c **** 			#if( portSTACK_GROWTH < 0 )
1047:../../Source/tasks.c **** 			{
1048:../../Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pv
1049:../../Source/tasks.c **** 			}
1050:../../Source/tasks.c **** 			#else /* portSTACK_GROWTH */
1051:../../Source/tasks.c **** 			{
1052:../../Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCod
1053:../../Source/tasks.c **** 			}
1054:../../Source/tasks.c **** 			#endif /* portSTACK_GROWTH */
1055:../../Source/tasks.c **** 		}
1056:../../Source/tasks.c **** 		#else /* portHAS_STACK_OVERFLOW_CHECKING */
1057:../../Source/tasks.c **** 		{
1058:../../Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
1059:../../Source/tasks.c **** 		}
1060:../../Source/tasks.c **** 		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
1061:../../Source/tasks.c **** 	}
1062:../../Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1063:../../Source/tasks.c **** 
1064:../../Source/tasks.c **** 	if( pxCreatedTask != NULL )
1065:../../Source/tasks.c **** 	{
1066:../../Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1067:../../Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1068:../../Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1069:../../Source/tasks.c **** 	}
1070:../../Source/tasks.c **** 	else
1071:../../Source/tasks.c **** 	{
1072:../../Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1073:../../Source/tasks.c **** 	}
1074:../../Source/tasks.c **** }
1075:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1076:../../Source/tasks.c **** 
1077:../../Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1078:../../Source/tasks.c **** {
1079:../../Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1080:../../Source/tasks.c **** 	updated. */
1081:../../Source/tasks.c **** 	taskENTER_CRITICAL();
1082:../../Source/tasks.c **** 	{
1083:../../Source/tasks.c **** 		uxCurrentNumberOfTasks++;
1084:../../Source/tasks.c **** 		if( pxCurrentTCB == NULL )
1085:../../Source/tasks.c **** 		{
1086:../../Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1087:../../Source/tasks.c **** 			the suspended state - make this the current task. */
1088:../../Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
1089:../../Source/tasks.c **** 
1090:../../Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1091:../../Source/tasks.c **** 			{
1092:../../Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
1093:../../Source/tasks.c **** 				initialisation required.  We will not recover if this call
1094:../../Source/tasks.c **** 				fails, but we will report the failure. */
1095:../../Source/tasks.c **** 				prvInitialiseTaskLists();
1096:../../Source/tasks.c **** 			}
1097:../../Source/tasks.c **** 			else
1098:../../Source/tasks.c **** 			{
1099:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1100:../../Source/tasks.c **** 			}
1101:../../Source/tasks.c **** 		}
1102:../../Source/tasks.c **** 		else
1103:../../Source/tasks.c **** 		{
1104:../../Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
1105:../../Source/tasks.c **** 			current task if it is the highest priority task to be created
1106:../../Source/tasks.c **** 			so far. */
1107:../../Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
1108:../../Source/tasks.c **** 			{
1109:../../Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1110:../../Source/tasks.c **** 				{
1111:../../Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
1112:../../Source/tasks.c **** 				}
1113:../../Source/tasks.c **** 				else
1114:../../Source/tasks.c **** 				{
1115:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1116:../../Source/tasks.c **** 				}
1117:../../Source/tasks.c **** 			}
1118:../../Source/tasks.c **** 			else
1119:../../Source/tasks.c **** 			{
1120:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1121:../../Source/tasks.c **** 			}
1122:../../Source/tasks.c **** 		}
1123:../../Source/tasks.c **** 
1124:../../Source/tasks.c **** 		uxTaskNumber++;
1125:../../Source/tasks.c **** 
1126:../../Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1127:../../Source/tasks.c **** 		{
1128:../../Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1129:../../Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1130:../../Source/tasks.c **** 		}
1131:../../Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1132:../../Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1133:../../Source/tasks.c **** 
1134:../../Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
1135:../../Source/tasks.c **** 
1136:../../Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1137:../../Source/tasks.c **** 	}
1138:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
1139:../../Source/tasks.c **** 
1140:../../Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
1141:../../Source/tasks.c **** 	{
1142:../../Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
1143:../../Source/tasks.c **** 		then it should run now. */
1144:../../Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1145:../../Source/tasks.c **** 		{
1146:../../Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
1147:../../Source/tasks.c **** 		}
1148:../../Source/tasks.c **** 		else
1149:../../Source/tasks.c **** 		{
1150:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1151:../../Source/tasks.c **** 		}
1152:../../Source/tasks.c **** 	}
1153:../../Source/tasks.c **** 	else
1154:../../Source/tasks.c **** 	{
1155:../../Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1156:../../Source/tasks.c **** 	}
1157:../../Source/tasks.c **** }
1158:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1159:../../Source/tasks.c **** 
1160:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1161:../../Source/tasks.c **** 
1162:../../Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1163:../../Source/tasks.c **** 	{
1164:../../Source/tasks.c **** 	TCB_t *pxTCB;
1165:../../Source/tasks.c **** 
1166:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1167:../../Source/tasks.c **** 		{
1168:../../Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1169:../../Source/tasks.c **** 			being deleted. */
1170:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1171:../../Source/tasks.c **** 
1172:../../Source/tasks.c **** 			/* Remove task from the ready/delayed list. */
1173:../../Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1174:../../Source/tasks.c **** 			{
1175:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1176:../../Source/tasks.c **** 			}
1177:../../Source/tasks.c **** 			else
1178:../../Source/tasks.c **** 			{
1179:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1180:../../Source/tasks.c **** 			}
1181:../../Source/tasks.c **** 
1182:../../Source/tasks.c **** 			/* Is the task waiting on an event also? */
1183:../../Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1184:../../Source/tasks.c **** 			{
1185:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1186:../../Source/tasks.c **** 			}
1187:../../Source/tasks.c **** 			else
1188:../../Source/tasks.c **** 			{
1189:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1190:../../Source/tasks.c **** 			}
1191:../../Source/tasks.c **** 
1192:../../Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1193:../../Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1194:../../Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1195:../../Source/tasks.c **** 			not return. */
1196:../../Source/tasks.c **** 			uxTaskNumber++;
1197:../../Source/tasks.c **** 
1198:../../Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1199:../../Source/tasks.c **** 			{
1200:../../Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1201:../../Source/tasks.c **** 				task itself, as a context switch to another task is required.
1202:../../Source/tasks.c **** 				Place the task in the termination list.  The idle task will
1203:../../Source/tasks.c **** 				check the termination list and free up any memory allocated by
1204:../../Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1205:../../Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1206:../../Source/tasks.c **** 
1207:../../Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1208:../../Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
1209:../../Source/tasks.c **** 				check the xTasksWaitingTermination list. */
1210:../../Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
1211:../../Source/tasks.c **** 
1212:../../Source/tasks.c **** 				/* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
1213:../../Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
1214:../../Source/tasks.c **** 				traceTASK_DELETE( pxTCB );
1215:../../Source/tasks.c **** 
1216:../../Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1217:../../Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1218:../../Source/tasks.c **** 				after which it is not possible to yield away from this task -
1219:../../Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1220:../../Source/tasks.c **** 				required. */
1221:../../Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1222:../../Source/tasks.c **** 			}
1223:../../Source/tasks.c **** 			else
1224:../../Source/tasks.c **** 			{
1225:../../Source/tasks.c **** 				--uxCurrentNumberOfTasks;
1226:../../Source/tasks.c **** 				traceTASK_DELETE( pxTCB );
1227:../../Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1228:../../Source/tasks.c **** 
1229:../../Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1230:../../Source/tasks.c **** 				the task that has just been deleted. */
1231:../../Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1232:../../Source/tasks.c **** 			}
1233:../../Source/tasks.c **** 		}
1234:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1235:../../Source/tasks.c **** 
1236:../../Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1237:../../Source/tasks.c **** 		been deleted. */
1238:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1239:../../Source/tasks.c **** 		{
1240:../../Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1241:../../Source/tasks.c **** 			{
1242:../../Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1243:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
1244:../../Source/tasks.c **** 			}
1245:../../Source/tasks.c **** 			else
1246:../../Source/tasks.c **** 			{
1247:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1248:../../Source/tasks.c **** 			}
1249:../../Source/tasks.c **** 		}
1250:../../Source/tasks.c **** 	}
1251:../../Source/tasks.c **** 
1252:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1253:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1254:../../Source/tasks.c **** 
1255:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1256:../../Source/tasks.c **** 
1257:../../Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1258:../../Source/tasks.c **** 	{
1259:../../Source/tasks.c **** 	TickType_t xTimeToWake;
1260:../../Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1261:../../Source/tasks.c **** 
1262:../../Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1263:../../Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1264:../../Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1265:../../Source/tasks.c **** 
1266:../../Source/tasks.c **** 		vTaskSuspendAll();
1267:../../Source/tasks.c **** 		{
1268:../../Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1269:../../Source/tasks.c **** 			block. */
1270:../../Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1271:../../Source/tasks.c **** 
1272:../../Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1273:../../Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1274:../../Source/tasks.c **** 
1275:../../Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
1276:../../Source/tasks.c **** 			{
1277:../../Source/tasks.c **** 				/* The tick count has overflowed since this function was
1278:../../Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1279:../../Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1280:../../Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1281:../../Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1282:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1283:../../Source/tasks.c **** 				{
1284:../../Source/tasks.c **** 					xShouldDelay = pdTRUE;
1285:../../Source/tasks.c **** 				}
1286:../../Source/tasks.c **** 				else
1287:../../Source/tasks.c **** 				{
1288:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1289:../../Source/tasks.c **** 				}
1290:../../Source/tasks.c **** 			}
1291:../../Source/tasks.c **** 			else
1292:../../Source/tasks.c **** 			{
1293:../../Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1294:../../Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1295:../../Source/tasks.c **** 				tick time is less than the wake time. */
1296:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1297:../../Source/tasks.c **** 				{
1298:../../Source/tasks.c **** 					xShouldDelay = pdTRUE;
1299:../../Source/tasks.c **** 				}
1300:../../Source/tasks.c **** 				else
1301:../../Source/tasks.c **** 				{
1302:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1303:../../Source/tasks.c **** 				}
1304:../../Source/tasks.c **** 			}
1305:../../Source/tasks.c **** 
1306:../../Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1307:../../Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
1308:../../Source/tasks.c **** 
1309:../../Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
1310:../../Source/tasks.c **** 			{
1311:../../Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1312:../../Source/tasks.c **** 
1313:../../Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1314:../../Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1315:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1316:../../Source/tasks.c **** 			}
1317:../../Source/tasks.c **** 			else
1318:../../Source/tasks.c **** 			{
1319:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1320:../../Source/tasks.c **** 			}
1321:../../Source/tasks.c **** 		}
1322:../../Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
1323:../../Source/tasks.c **** 
1324:../../Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1325:../../Source/tasks.c **** 		have put ourselves to sleep. */
1326:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1327:../../Source/tasks.c **** 		{
1328:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
1329:../../Source/tasks.c **** 		}
1330:../../Source/tasks.c **** 		else
1331:../../Source/tasks.c **** 		{
1332:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1333:../../Source/tasks.c **** 		}
1334:../../Source/tasks.c **** 	}
1335:../../Source/tasks.c **** 
1336:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1337:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1338:../../Source/tasks.c **** 
1339:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1340:../../Source/tasks.c **** 
1341:../../Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1342:../../Source/tasks.c **** 	{
1343:../../Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
1344:../../Source/tasks.c **** 
1345:../../Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1346:../../Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
1347:../../Source/tasks.c **** 		{
1348:../../Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1349:../../Source/tasks.c **** 			vTaskSuspendAll();
1350:../../Source/tasks.c **** 			{
1351:../../Source/tasks.c **** 				traceTASK_DELAY();
1352:../../Source/tasks.c **** 
1353:../../Source/tasks.c **** 				/* A task that is removed from the event list while the
1354:../../Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1355:../../Source/tasks.c **** 				list or removed from the blocked list until the scheduler
1356:../../Source/tasks.c **** 				is resumed.
1357:../../Source/tasks.c **** 
1358:../../Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1359:../../Source/tasks.c **** 				executing task. */
1360:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1361:../../Source/tasks.c **** 			}
1362:../../Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
1363:../../Source/tasks.c **** 		}
1364:../../Source/tasks.c **** 		else
1365:../../Source/tasks.c **** 		{
1366:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1367:../../Source/tasks.c **** 		}
1368:../../Source/tasks.c **** 
1369:../../Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1370:../../Source/tasks.c **** 		have put ourselves to sleep. */
1371:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1372:../../Source/tasks.c **** 		{
1373:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
1374:../../Source/tasks.c **** 		}
1375:../../Source/tasks.c **** 		else
1376:../../Source/tasks.c **** 		{
1377:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1378:../../Source/tasks.c **** 		}
1379:../../Source/tasks.c **** 	}
1380:../../Source/tasks.c **** 
1381:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1382:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1383:../../Source/tasks.c **** 
1384:../../Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDel
1385:../../Source/tasks.c **** 
1386:../../Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1387:../../Source/tasks.c **** 	{
1388:../../Source/tasks.c **** 	eTaskState eReturn;
1389:../../Source/tasks.c **** 	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
1390:../../Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1391:../../Source/tasks.c **** 
1392:../../Source/tasks.c **** 		configASSERT( pxTCB );
1393:../../Source/tasks.c **** 
1394:../../Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1395:../../Source/tasks.c **** 		{
1396:../../Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1397:../../Source/tasks.c **** 			eReturn = eRunning;
1398:../../Source/tasks.c **** 		}
1399:../../Source/tasks.c **** 		else
1400:../../Source/tasks.c **** 		{
1401:../../Source/tasks.c **** 			taskENTER_CRITICAL();
1402:../../Source/tasks.c **** 			{
1403:../../Source/tasks.c **** 				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1404:../../Source/tasks.c **** 				pxDelayedList = pxDelayedTaskList;
1405:../../Source/tasks.c **** 				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1406:../../Source/tasks.c **** 			}
1407:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
1408:../../Source/tasks.c **** 
1409:../../Source/tasks.c **** 			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1410:../../Source/tasks.c **** 			{
1411:../../Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1412:../../Source/tasks.c **** 				lists. */
1413:../../Source/tasks.c **** 				eReturn = eBlocked;
1414:../../Source/tasks.c **** 			}
1415:../../Source/tasks.c **** 
1416:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1417:../../Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1418:../../Source/tasks.c **** 				{
1419:../../Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1420:../../Source/tasks.c **** 					list.  Is it genuinely suspended or is it blocked
1421:../../Source/tasks.c **** 					indefinitely? */
1422:../../Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1423:../../Source/tasks.c **** 					{
1424:../../Source/tasks.c **** 						#if( configUSE_TASK_NOTIFICATIONS == 1 )
1425:../../Source/tasks.c **** 						{
1426:../../Source/tasks.c **** 							/* The task does not appear on the event list item of
1427:../../Source/tasks.c **** 							and of the RTOS objects, but could still be in the
1428:../../Source/tasks.c **** 							blocked state if it is waiting on its notification
1429:../../Source/tasks.c **** 							rather than waiting on an object. */
1430:../../Source/tasks.c **** 							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1431:../../Source/tasks.c **** 							{
1432:../../Source/tasks.c **** 								eReturn = eBlocked;
1433:../../Source/tasks.c **** 							}
1434:../../Source/tasks.c **** 							else
1435:../../Source/tasks.c **** 							{
1436:../../Source/tasks.c **** 								eReturn = eSuspended;
1437:../../Source/tasks.c **** 							}
1438:../../Source/tasks.c **** 						}
1439:../../Source/tasks.c **** 						#else
1440:../../Source/tasks.c **** 						{
1441:../../Source/tasks.c **** 							eReturn = eSuspended;
1442:../../Source/tasks.c **** 						}
1443:../../Source/tasks.c **** 						#endif
1444:../../Source/tasks.c **** 					}
1445:../../Source/tasks.c **** 					else
1446:../../Source/tasks.c **** 					{
1447:../../Source/tasks.c **** 						eReturn = eBlocked;
1448:../../Source/tasks.c **** 					}
1449:../../Source/tasks.c **** 				}
1450:../../Source/tasks.c **** 			#endif
1451:../../Source/tasks.c **** 
1452:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1453:../../Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1454:../../Source/tasks.c **** 				{
1455:../../Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1456:../../Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1457:../../Source/tasks.c **** 					all. */
1458:../../Source/tasks.c **** 					eReturn = eDeleted;
1459:../../Source/tasks.c **** 				}
1460:../../Source/tasks.c **** 			#endif
1461:../../Source/tasks.c **** 
1462:../../Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1463:../../Source/tasks.c **** 			{
1464:../../Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1465:../../Source/tasks.c **** 				Ready (including pending ready) state. */
1466:../../Source/tasks.c **** 				eReturn = eReady;
1467:../../Source/tasks.c **** 			}
1468:../../Source/tasks.c **** 		}
1469:../../Source/tasks.c **** 
1470:../../Source/tasks.c **** 		return eReturn;
1471:../../Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1472:../../Source/tasks.c **** 
1473:../../Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1474:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1475:../../Source/tasks.c **** 
1476:../../Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1477:../../Source/tasks.c **** 
1478:../../Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1479:../../Source/tasks.c **** 	{
1480:../../Source/tasks.c **** 	TCB_t const *pxTCB;
1481:../../Source/tasks.c **** 	UBaseType_t uxReturn;
1482:../../Source/tasks.c **** 
1483:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1484:../../Source/tasks.c **** 		{
1485:../../Source/tasks.c **** 			/* If null is passed in here then it is the priority of the task
1486:../../Source/tasks.c **** 			that called uxTaskPriorityGet() that is being queried. */
1487:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1488:../../Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1489:../../Source/tasks.c **** 		}
1490:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1491:../../Source/tasks.c **** 
1492:../../Source/tasks.c **** 		return uxReturn;
1493:../../Source/tasks.c **** 	}
1494:../../Source/tasks.c **** 
1495:../../Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1496:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1497:../../Source/tasks.c **** 
1498:../../Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1499:../../Source/tasks.c **** 
1500:../../Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1501:../../Source/tasks.c **** 	{
1502:../../Source/tasks.c **** 	TCB_t const *pxTCB;
1503:../../Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1504:../../Source/tasks.c **** 
1505:../../Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1506:../../Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1507:../../Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1508:../../Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1509:../../Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1510:../../Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1511:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1512:../../Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1513:../../Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1514:../../Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1515:../../Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1516:../../Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1517:../../Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1518:../../Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1519:../../Source/tasks.c **** 		provided on the following link:
1520:../../Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1521:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1522:../../Source/tasks.c **** 
1523:../../Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1524:../../Source/tasks.c **** 		{
1525:../../Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1526:../../Source/tasks.c **** 			task that is being queried. */
1527:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1528:../../Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1529:../../Source/tasks.c **** 		}
1530:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1531:../../Source/tasks.c **** 
1532:../../Source/tasks.c **** 		return uxReturn;
1533:../../Source/tasks.c **** 	}
1534:../../Source/tasks.c **** 
1535:../../Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1536:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1537:../../Source/tasks.c **** 
1538:../../Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1539:../../Source/tasks.c **** 
1540:../../Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1541:../../Source/tasks.c **** 	{
1542:../../Source/tasks.c **** 	TCB_t *pxTCB;
1543:../../Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1544:../../Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1545:../../Source/tasks.c **** 
1546:../../Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1547:../../Source/tasks.c **** 
1548:../../Source/tasks.c **** 		/* Ensure the new priority is valid. */
1549:../../Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1550:../../Source/tasks.c **** 		{
1551:../../Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1552:../../Source/tasks.c **** 		}
1553:../../Source/tasks.c **** 		else
1554:../../Source/tasks.c **** 		{
1555:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1556:../../Source/tasks.c **** 		}
1557:../../Source/tasks.c **** 
1558:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1559:../../Source/tasks.c **** 		{
1560:../../Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1561:../../Source/tasks.c **** 			task that is being changed. */
1562:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1563:../../Source/tasks.c **** 
1564:../../Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1565:../../Source/tasks.c **** 
1566:../../Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1567:../../Source/tasks.c **** 			{
1568:../../Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1569:../../Source/tasks.c **** 			}
1570:../../Source/tasks.c **** 			#else
1571:../../Source/tasks.c **** 			{
1572:../../Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1573:../../Source/tasks.c **** 			}
1574:../../Source/tasks.c **** 			#endif
1575:../../Source/tasks.c **** 
1576:../../Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1577:../../Source/tasks.c **** 			{
1578:../../Source/tasks.c **** 				/* The priority change may have readied a task of higher
1579:../../Source/tasks.c **** 				priority than the calling task. */
1580:../../Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1581:../../Source/tasks.c **** 				{
1582:../../Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1583:../../Source/tasks.c **** 					{
1584:../../Source/tasks.c **** 						/* The priority of a task other than the currently
1585:../../Source/tasks.c **** 						running task is being raised.  Is the priority being
1586:../../Source/tasks.c **** 						raised above that of the running task? */
1587:../../Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1588:../../Source/tasks.c **** 						{
1589:../../Source/tasks.c **** 							xYieldRequired = pdTRUE;
1590:../../Source/tasks.c **** 						}
1591:../../Source/tasks.c **** 						else
1592:../../Source/tasks.c **** 						{
1593:../../Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1594:../../Source/tasks.c **** 						}
1595:../../Source/tasks.c **** 					}
1596:../../Source/tasks.c **** 					else
1597:../../Source/tasks.c **** 					{
1598:../../Source/tasks.c **** 						/* The priority of the running task is being raised,
1599:../../Source/tasks.c **** 						but the running task must already be the highest
1600:../../Source/tasks.c **** 						priority task able to run so no yield is required. */
1601:../../Source/tasks.c **** 					}
1602:../../Source/tasks.c **** 				}
1603:../../Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1604:../../Source/tasks.c **** 				{
1605:../../Source/tasks.c **** 					/* Setting the priority of the running task down means
1606:../../Source/tasks.c **** 					there may now be another task of higher priority that
1607:../../Source/tasks.c **** 					is ready to execute. */
1608:../../Source/tasks.c **** 					xYieldRequired = pdTRUE;
1609:../../Source/tasks.c **** 				}
1610:../../Source/tasks.c **** 				else
1611:../../Source/tasks.c **** 				{
1612:../../Source/tasks.c **** 					/* Setting the priority of any other task down does not
1613:../../Source/tasks.c **** 					require a yield as the running task must be above the
1614:../../Source/tasks.c **** 					new priority of the task being modified. */
1615:../../Source/tasks.c **** 				}
1616:../../Source/tasks.c **** 
1617:../../Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1618:../../Source/tasks.c **** 				before its uxPriority member is changed so the
1619:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1620:../../Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1621:../../Source/tasks.c **** 
1622:../../Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1623:../../Source/tasks.c **** 				{
1624:../../Source/tasks.c **** 					/* Only change the priority being used if the task is not
1625:../../Source/tasks.c **** 					currently using an inherited priority. */
1626:../../Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1627:../../Source/tasks.c **** 					{
1628:../../Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1629:../../Source/tasks.c **** 					}
1630:../../Source/tasks.c **** 					else
1631:../../Source/tasks.c **** 					{
1632:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1633:../../Source/tasks.c **** 					}
1634:../../Source/tasks.c **** 
1635:../../Source/tasks.c **** 					/* The base priority gets set whatever. */
1636:../../Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1637:../../Source/tasks.c **** 				}
1638:../../Source/tasks.c **** 				#else
1639:../../Source/tasks.c **** 				{
1640:../../Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1641:../../Source/tasks.c **** 				}
1642:../../Source/tasks.c **** 				#endif
1643:../../Source/tasks.c **** 
1644:../../Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1645:../../Source/tasks.c **** 				being used for anything else. */
1646:../../Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1647:../../Source/tasks.c **** 				{
1648:../../Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1649:../../Source/tasks.c **** 				}
1650:../../Source/tasks.c **** 				else
1651:../../Source/tasks.c **** 				{
1652:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1653:../../Source/tasks.c **** 				}
1654:../../Source/tasks.c **** 
1655:../../Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1656:../../Source/tasks.c **** 				nothing more than change its priority variable. However, if
1657:../../Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1658:../../Source/tasks.c **** 				in the list appropriate to its new priority. */
1659:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
1660:../../Source/tasks.c **** 				{
1661:../../Source/tasks.c **** 					/* The task is currently in its ready list - remove before
1662:../../Source/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1663:../../Source/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1664:../../Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1665:../../Source/tasks.c **** 					{
1666:../../Source/tasks.c **** 						/* It is known that the task is in its ready list so
1667:../../Source/tasks.c **** 						there is no need to check again and the port level
1668:../../Source/tasks.c **** 						reset macro can be called directly. */
1669:../../Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1670:../../Source/tasks.c **** 					}
1671:../../Source/tasks.c **** 					else
1672:../../Source/tasks.c **** 					{
1673:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1674:../../Source/tasks.c **** 					}
1675:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1676:../../Source/tasks.c **** 				}
1677:../../Source/tasks.c **** 				else
1678:../../Source/tasks.c **** 				{
1679:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1680:../../Source/tasks.c **** 				}
1681:../../Source/tasks.c **** 
1682:../../Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
1683:../../Source/tasks.c **** 				{
1684:../../Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1685:../../Source/tasks.c **** 				}
1686:../../Source/tasks.c **** 				else
1687:../../Source/tasks.c **** 				{
1688:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1689:../../Source/tasks.c **** 				}
1690:../../Source/tasks.c **** 
1691:../../Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1692:../../Source/tasks.c **** 				optimised task selection is not being used. */
1693:../../Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1694:../../Source/tasks.c **** 			}
1695:../../Source/tasks.c **** 		}
1696:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1697:../../Source/tasks.c **** 	}
1698:../../Source/tasks.c **** 
1699:../../Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1700:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1701:../../Source/tasks.c **** 
1702:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1703:../../Source/tasks.c **** 
1704:../../Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1705:../../Source/tasks.c **** 	{
1706:../../Source/tasks.c **** 	TCB_t *pxTCB;
1707:../../Source/tasks.c **** 
1708:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1709:../../Source/tasks.c **** 		{
1710:../../Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1711:../../Source/tasks.c **** 			being suspended. */
1712:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1713:../../Source/tasks.c **** 
1714:../../Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1715:../../Source/tasks.c **** 
1716:../../Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1717:../../Source/tasks.c **** 			suspended list. */
1718:../../Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1719:../../Source/tasks.c **** 			{
1720:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1721:../../Source/tasks.c **** 			}
1722:../../Source/tasks.c **** 			else
1723:../../Source/tasks.c **** 			{
1724:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1725:../../Source/tasks.c **** 			}
1726:../../Source/tasks.c **** 
1727:../../Source/tasks.c **** 			/* Is the task waiting on an event also? */
1728:../../Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1729:../../Source/tasks.c **** 			{
1730:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1731:../../Source/tasks.c **** 			}
1732:../../Source/tasks.c **** 			else
1733:../../Source/tasks.c **** 			{
1734:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1735:../../Source/tasks.c **** 			}
1736:../../Source/tasks.c **** 
1737:../../Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1738:../../Source/tasks.c **** 
1739:../../Source/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1740:../../Source/tasks.c **** 			{
1741:../../Source/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1742:../../Source/tasks.c **** 				{
1743:../../Source/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1744:../../Source/tasks.c **** 					now suspended, so no notification was received. */
1745:../../Source/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1746:../../Source/tasks.c **** 				}
1747:../../Source/tasks.c **** 			}
1748:../../Source/tasks.c **** 			#endif
1749:../../Source/tasks.c **** 		}
1750:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1751:../../Source/tasks.c **** 
1752:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1753:../../Source/tasks.c **** 		{
1754:../../Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1755:../../Source/tasks.c **** 			task that is now in the Suspended state. */
1756:../../Source/tasks.c **** 			taskENTER_CRITICAL();
1757:../../Source/tasks.c **** 			{
1758:../../Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1759:../../Source/tasks.c **** 			}
1760:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
1761:../../Source/tasks.c **** 		}
1762:../../Source/tasks.c **** 		else
1763:../../Source/tasks.c **** 		{
1764:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1765:../../Source/tasks.c **** 		}
1766:../../Source/tasks.c **** 
1767:../../Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1768:../../Source/tasks.c **** 		{
1769:../../Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1770:../../Source/tasks.c **** 			{
1771:../../Source/tasks.c **** 				/* The current task has just been suspended. */
1772:../../Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1773:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
1774:../../Source/tasks.c **** 			}
1775:../../Source/tasks.c **** 			else
1776:../../Source/tasks.c **** 			{
1777:../../Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1778:../../Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1779:../../Source/tasks.c **** 				must be adjusted to point to a different task. */
1780:../../Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Rig
1781:../../Source/tasks.c **** 				{
1782:../../Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1783:../../Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1784:../../Source/tasks.c **** 					be set to point to it no matter what its relative priority
1785:../../Source/tasks.c **** 					is. */
1786:../../Source/tasks.c **** 					pxCurrentTCB = NULL;
1787:../../Source/tasks.c **** 				}
1788:../../Source/tasks.c **** 				else
1789:../../Source/tasks.c **** 				{
1790:../../Source/tasks.c **** 					vTaskSwitchContext();
1791:../../Source/tasks.c **** 				}
1792:../../Source/tasks.c **** 			}
1793:../../Source/tasks.c **** 		}
1794:../../Source/tasks.c **** 		else
1795:../../Source/tasks.c **** 		{
1796:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1797:../../Source/tasks.c **** 		}
1798:../../Source/tasks.c **** 	}
1799:../../Source/tasks.c **** 
1800:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1801:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1802:../../Source/tasks.c **** 
1803:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1804:../../Source/tasks.c **** 
1805:../../Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1806:../../Source/tasks.c **** 	{
1807:../../Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1808:../../Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1809:../../Source/tasks.c **** 
1810:../../Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1811:../../Source/tasks.c **** 		section. */
1812:../../Source/tasks.c **** 
1813:../../Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1814:../../Source/tasks.c **** 		configASSERT( xTask );
1815:../../Source/tasks.c **** 
1816:../../Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1817:../../Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1818:../../Source/tasks.c **** 		{
1819:../../Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1820:../../Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1821:../../Source/tasks.c **** 			{
1822:../../Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1823:../../Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1824:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
1825:../../Source/tasks.c **** 				{
1826:../../Source/tasks.c **** 					xReturn = pdTRUE;
1827:../../Source/tasks.c **** 				}
1828:../../Source/tasks.c **** 				else
1829:../../Source/tasks.c **** 				{
1830:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1831:../../Source/tasks.c **** 				}
1832:../../Source/tasks.c **** 			}
1833:../../Source/tasks.c **** 			else
1834:../../Source/tasks.c **** 			{
1835:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1836:../../Source/tasks.c **** 			}
1837:../../Source/tasks.c **** 		}
1838:../../Source/tasks.c **** 		else
1839:../../Source/tasks.c **** 		{
1840:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1841:../../Source/tasks.c **** 		}
1842:../../Source/tasks.c **** 
1843:../../Source/tasks.c **** 		return xReturn;
1844:../../Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1845:../../Source/tasks.c **** 
1846:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1847:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1848:../../Source/tasks.c **** 
1849:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1850:../../Source/tasks.c **** 
1851:../../Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1852:../../Source/tasks.c **** 	{
1853:../../Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1854:../../Source/tasks.c **** 
1855:../../Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1856:../../Source/tasks.c **** 		configASSERT( xTaskToResume );
1857:../../Source/tasks.c **** 
1858:../../Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1859:../../Source/tasks.c **** 		currently executing task. */
1860:../../Source/tasks.c **** 		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
1861:../../Source/tasks.c **** 		{
1862:../../Source/tasks.c **** 			taskENTER_CRITICAL();
1863:../../Source/tasks.c **** 			{
1864:../../Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1865:../../Source/tasks.c **** 				{
1866:../../Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1867:../../Source/tasks.c **** 
1868:../../Source/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1869:../../Source/tasks.c **** 					suspended because this is inside a critical section. */
1870:../../Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1871:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1872:../../Source/tasks.c **** 
1873:../../Source/tasks.c **** 					/* A higher priority task may have just been resumed. */
1874:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1875:../../Source/tasks.c **** 					{
1876:../../Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1877:../../Source/tasks.c **** 						but will leave the lists in the correct state for the
1878:../../Source/tasks.c **** 						next yield. */
1879:../../Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1880:../../Source/tasks.c **** 					}
1881:../../Source/tasks.c **** 					else
1882:../../Source/tasks.c **** 					{
1883:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1884:../../Source/tasks.c **** 					}
1885:../../Source/tasks.c **** 				}
1886:../../Source/tasks.c **** 				else
1887:../../Source/tasks.c **** 				{
1888:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1889:../../Source/tasks.c **** 				}
1890:../../Source/tasks.c **** 			}
1891:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
1892:../../Source/tasks.c **** 		}
1893:../../Source/tasks.c **** 		else
1894:../../Source/tasks.c **** 		{
1895:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1896:../../Source/tasks.c **** 		}
1897:../../Source/tasks.c **** 	}
1898:../../Source/tasks.c **** 
1899:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1900:../../Source/tasks.c **** 
1901:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1902:../../Source/tasks.c **** 
1903:../../Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1904:../../Source/tasks.c **** 
1905:../../Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1906:../../Source/tasks.c **** 	{
1907:../../Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1908:../../Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1909:../../Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1910:../../Source/tasks.c **** 
1911:../../Source/tasks.c **** 		configASSERT( xTaskToResume );
1912:../../Source/tasks.c **** 
1913:../../Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1914:../../Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1915:../../Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1916:../../Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1917:../../Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1918:../../Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1919:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1920:../../Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1921:../../Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1922:../../Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1923:../../Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1924:../../Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1925:../../Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1926:../../Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1927:../../Source/tasks.c **** 		provided on the following link:
1928:../../Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1929:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1930:../../Source/tasks.c **** 
1931:../../Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1932:../../Source/tasks.c **** 		{
1933:../../Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1934:../../Source/tasks.c **** 			{
1935:../../Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1936:../../Source/tasks.c **** 
1937:../../Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1938:../../Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1939:../../Source/tasks.c **** 				{
1940:../../Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1941:../../Source/tasks.c **** 					suspended list to the ready list directly. */
1942:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1943:../../Source/tasks.c **** 					{
1944:../../Source/tasks.c **** 						xYieldRequired = pdTRUE;
1945:../../Source/tasks.c **** 					}
1946:../../Source/tasks.c **** 					else
1947:../../Source/tasks.c **** 					{
1948:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1949:../../Source/tasks.c **** 					}
1950:../../Source/tasks.c **** 
1951:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1952:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1953:../../Source/tasks.c **** 				}
1954:../../Source/tasks.c **** 				else
1955:../../Source/tasks.c **** 				{
1956:../../Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1957:../../Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1958:../../Source/tasks.c **** 					unsuspended. */
1959:../../Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1960:../../Source/tasks.c **** 				}
1961:../../Source/tasks.c **** 			}
1962:../../Source/tasks.c **** 			else
1963:../../Source/tasks.c **** 			{
1964:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1965:../../Source/tasks.c **** 			}
1966:../../Source/tasks.c **** 		}
1967:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1968:../../Source/tasks.c **** 
1969:../../Source/tasks.c **** 		return xYieldRequired;
1970:../../Source/tasks.c **** 	}
1971:../../Source/tasks.c **** 
1972:../../Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1973:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1974:../../Source/tasks.c **** 
1975:../../Source/tasks.c **** void vTaskStartScheduler( void )
1976:../../Source/tasks.c **** {
1977:../../Source/tasks.c **** BaseType_t xReturn;
1978:../../Source/tasks.c **** 
1979:../../Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1980:../../Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1981:../../Source/tasks.c **** 	{
1982:../../Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1983:../../Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1984:../../Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1985:../../Source/tasks.c **** 
1986:../../Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1987:../../Source/tasks.c **** 		address of the RAM then create the idle task. */
1988:../../Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1989:../../Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1990:../../Source/tasks.c **** 												configIDLE_TASK_NAME,
1991:../../Source/tasks.c **** 												ulIdleTaskStackSize,
1992:../../Source/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1993:../../Source/tasks.c **** 												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_P
1994:../../Source/tasks.c **** 												pxIdleTaskStackBuffer,
1995:../../Source/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1996:../../Source/tasks.c **** 
1997:../../Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1998:../../Source/tasks.c **** 		{
1999:../../Source/tasks.c **** 			xReturn = pdPASS;
2000:../../Source/tasks.c **** 		}
2001:../../Source/tasks.c **** 		else
2002:../../Source/tasks.c **** 		{
2003:../../Source/tasks.c **** 			xReturn = pdFAIL;
2004:../../Source/tasks.c **** 		}
2005:../../Source/tasks.c **** 	}
2006:../../Source/tasks.c **** 	#else
2007:../../Source/tasks.c **** 	{
2008:../../Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
2009:../../Source/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
2010:../../Source/tasks.c **** 								configIDLE_TASK_NAME,
2011:../../Source/tasks.c **** 								configMINIMAL_STACK_SIZE,
2012:../../Source/tasks.c **** 								( void * ) NULL,
2013:../../Source/tasks.c **** 								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIOR
2014:../../Source/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
2015:../../Source/tasks.c **** 	}
2016:../../Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
2017:../../Source/tasks.c **** 
2018:../../Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
2019:../../Source/tasks.c **** 	{
2020:../../Source/tasks.c **** 		if( xReturn == pdPASS )
2021:../../Source/tasks.c **** 		{
2022:../../Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
2023:../../Source/tasks.c **** 		}
2024:../../Source/tasks.c **** 		else
2025:../../Source/tasks.c **** 		{
2026:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2027:../../Source/tasks.c **** 		}
2028:../../Source/tasks.c **** 	}
2029:../../Source/tasks.c **** 	#endif /* configUSE_TIMERS */
2030:../../Source/tasks.c **** 
2031:../../Source/tasks.c **** 	if( xReturn == pdPASS )
2032:../../Source/tasks.c **** 	{
2033:../../Source/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
2034:../../Source/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
2035:../../Source/tasks.c **** 		the only macro called by the function. */
2036:../../Source/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2037:../../Source/tasks.c **** 		{
2038:../../Source/tasks.c **** 			freertos_tasks_c_additions_init();
2039:../../Source/tasks.c **** 		}
2040:../../Source/tasks.c **** 		#endif
2041:../../Source/tasks.c **** 
2042:../../Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
2043:../../Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
2044:../../Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
2045:../../Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
2046:../../Source/tasks.c **** 		starts to run. */
2047:../../Source/tasks.c **** 		portDISABLE_INTERRUPTS();
2048:../../Source/tasks.c **** 
2049:../../Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2050:../../Source/tasks.c **** 		{
2051:../../Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2052:../../Source/tasks.c **** 			structure specific to the task that will run first.
2053:../../Source/tasks.c **** 			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
2054:../../Source/tasks.c **** 			for additional information. */
2055:../../Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2056:../../Source/tasks.c **** 		}
2057:../../Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2058:../../Source/tasks.c **** 
2059:../../Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
2060:../../Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
2061:../../Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
2062:../../Source/tasks.c **** 
2063:../../Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
2064:../../Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
2065:../../Source/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2066:../../Source/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
2067:../../Source/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2068:../../Source/tasks.c **** 		FreeRTOSConfig.h file. */
2069:../../Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2070:../../Source/tasks.c **** 
2071:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2072:../../Source/tasks.c **** 
2073:../../Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
2074:../../Source/tasks.c **** 		portable interface. */
2075:../../Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
2076:../../Source/tasks.c **** 		{
2077:../../Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2078:../../Source/tasks.c **** 			function will not return. */
2079:../../Source/tasks.c **** 		}
2080:../../Source/tasks.c **** 		else
2081:../../Source/tasks.c **** 		{
2082:../../Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2083:../../Source/tasks.c **** 		}
2084:../../Source/tasks.c **** 	}
2085:../../Source/tasks.c **** 	else
2086:../../Source/tasks.c **** 	{
2087:../../Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2088:../../Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2089:../../Source/tasks.c **** 		or the timer task. */
2090:../../Source/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2091:../../Source/tasks.c **** 	}
2092:../../Source/tasks.c **** 
2093:../../Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2094:../../Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2095:../../Source/tasks.c **** 	( void ) xIdleTaskHandle;
2096:../../Source/tasks.c **** }
2097:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2098:../../Source/tasks.c **** 
2099:../../Source/tasks.c **** void vTaskEndScheduler( void )
2100:../../Source/tasks.c **** {
2101:../../Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2102:../../Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2103:../../Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2104:../../Source/tasks.c **** 	portDISABLE_INTERRUPTS();
2105:../../Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
2106:../../Source/tasks.c **** 	vPortEndScheduler();
2107:../../Source/tasks.c **** }
2108:../../Source/tasks.c **** /*----------------------------------------------------------*/
2109:../../Source/tasks.c **** 
2110:../../Source/tasks.c **** void vTaskSuspendAll( void )
2111:../../Source/tasks.c **** {
2112:../../Source/tasks.c **** 	/* A critical section is not required as the variable is of type
2113:../../Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2114:../../Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2115:../../Source/tasks.c **** 	http://goo.gl/wu4acr */
2116:../../Source/tasks.c **** 
2117:../../Source/tasks.c **** 	/* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that
2118:../../Source/tasks.c **** 	do not otherwise exhibit real time behaviour. */
2119:../../Source/tasks.c **** 	portSOFTWARE_BARRIER();
2120:../../Source/tasks.c **** 
2121:../../Source/tasks.c **** 	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
2122:../../Source/tasks.c **** 	is used to allow calls to vTaskSuspendAll() to nest. */
2123:../../Source/tasks.c **** 	++uxSchedulerSuspended;
2124:../../Source/tasks.c **** 
2125:../../Source/tasks.c **** 	/* Enforces ordering for ports and optimised compilers that may otherwise place
2126:../../Source/tasks.c **** 	the above increment elsewhere. */
2127:../../Source/tasks.c **** 	portMEMORY_BARRIER();
2128:../../Source/tasks.c **** }
2129:../../Source/tasks.c **** /*----------------------------------------------------------*/
2130:../../Source/tasks.c **** 
2131:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2132:../../Source/tasks.c **** 
2133:../../Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2134:../../Source/tasks.c **** 	{
2135:../../Source/tasks.c **** 	TickType_t xReturn;
2136:../../Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2137:../../Source/tasks.c **** 
2138:../../Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2139:../../Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2140:../../Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
2141:../../Source/tasks.c **** 		running. */
2142:../../Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2143:../../Source/tasks.c **** 		{
2144:../../Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2145:../../Source/tasks.c **** 			{
2146:../../Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2147:../../Source/tasks.c **** 			}
2148:../../Source/tasks.c **** 		}
2149:../../Source/tasks.c **** 		#else
2150:../../Source/tasks.c **** 		{
2151:../../Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2152:../../Source/tasks.c **** 
2153:../../Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2154:../../Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
2155:../../Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
2156:../../Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2157:../../Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2158:../../Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2159:../../Source/tasks.c **** 			{
2160:../../Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2161:../../Source/tasks.c **** 			}
2162:../../Source/tasks.c **** 		}
2163:../../Source/tasks.c **** 		#endif
2164:../../Source/tasks.c **** 
2165:../../Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2166:../../Source/tasks.c **** 		{
2167:../../Source/tasks.c **** 			xReturn = 0;
2168:../../Source/tasks.c **** 		}
2169:../../Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2170:../../Source/tasks.c **** 		{
2171:../../Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2172:../../Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2173:../../Source/tasks.c **** 			processed. */
2174:../../Source/tasks.c **** 			xReturn = 0;
2175:../../Source/tasks.c **** 		}
2176:../../Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2177:../../Source/tasks.c **** 		{
2178:../../Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2179:../../Source/tasks.c **** 			idle priority.  This path can only be reached if
2180:../../Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
2181:../../Source/tasks.c **** 			xReturn = 0;
2182:../../Source/tasks.c **** 		}
2183:../../Source/tasks.c **** 		else
2184:../../Source/tasks.c **** 		{
2185:../../Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2186:../../Source/tasks.c **** 		}
2187:../../Source/tasks.c **** 
2188:../../Source/tasks.c **** 		return xReturn;
2189:../../Source/tasks.c **** 	}
2190:../../Source/tasks.c **** 
2191:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2192:../../Source/tasks.c **** /*----------------------------------------------------------*/
2193:../../Source/tasks.c **** 
2194:../../Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2195:../../Source/tasks.c **** {
2196:../../Source/tasks.c **** TCB_t *pxTCB = NULL;
2197:../../Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
2198:../../Source/tasks.c **** 
2199:../../Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2200:../../Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
2201:../../Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2202:../../Source/tasks.c **** 
2203:../../Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2204:../../Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2205:../../Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2206:../../Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2207:../../Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
2208:../../Source/tasks.c **** 	taskENTER_CRITICAL();
2209:../../Source/tasks.c **** 	{
2210:../../Source/tasks.c **** 		--uxSchedulerSuspended;
2211:../../Source/tasks.c **** 
2212:../../Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2213:../../Source/tasks.c **** 		{
2214:../../Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2215:../../Source/tasks.c **** 			{
2216:../../Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
2217:../../Source/tasks.c **** 				appropriate ready list. */
2218:../../Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2219:../../Source/tasks.c **** 				{
2220:../../Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as
2221:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2222:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2223:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2224:../../Source/tasks.c **** 
2225:../../Source/tasks.c **** 					/* If the moved task has a priority higher than the current
2226:../../Source/tasks.c **** 					task then a yield must be performed. */
2227:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2228:../../Source/tasks.c **** 					{
2229:../../Source/tasks.c **** 						xYieldPending = pdTRUE;
2230:../../Source/tasks.c **** 					}
2231:../../Source/tasks.c **** 					else
2232:../../Source/tasks.c **** 					{
2233:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2234:../../Source/tasks.c **** 					}
2235:../../Source/tasks.c **** 				}
2236:../../Source/tasks.c **** 
2237:../../Source/tasks.c **** 				if( pxTCB != NULL )
2238:../../Source/tasks.c **** 				{
2239:../../Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2240:../../Source/tasks.c **** 					which may have prevented the next unblock time from being
2241:../../Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2242:../../Source/tasks.c **** 					important for low power tickless implementations, where
2243:../../Source/tasks.c **** 					this can prevent an unnecessary exit from low power
2244:../../Source/tasks.c **** 					state. */
2245:../../Source/tasks.c **** 					prvResetNextTaskUnblockTime();
2246:../../Source/tasks.c **** 				}
2247:../../Source/tasks.c **** 
2248:../../Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2249:../../Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
2250:../../Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2251:../../Source/tasks.c **** 				time. */
2252:../../Source/tasks.c **** 				{
2253:../../Source/tasks.c **** 					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
2254:../../Source/tasks.c **** 
2255:../../Source/tasks.c **** 					if( xPendedCounts > ( TickType_t ) 0U )
2256:../../Source/tasks.c **** 					{
2257:../../Source/tasks.c **** 						do
2258:../../Source/tasks.c **** 						{
2259:../../Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
2260:../../Source/tasks.c **** 							{
2261:../../Source/tasks.c **** 								xYieldPending = pdTRUE;
2262:../../Source/tasks.c **** 							}
2263:../../Source/tasks.c **** 							else
2264:../../Source/tasks.c **** 							{
2265:../../Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2266:../../Source/tasks.c **** 							}
2267:../../Source/tasks.c **** 							--xPendedCounts;
2268:../../Source/tasks.c **** 						} while( xPendedCounts > ( TickType_t ) 0U );
2269:../../Source/tasks.c **** 
2270:../../Source/tasks.c **** 						xPendedTicks = 0;
2271:../../Source/tasks.c **** 					}
2272:../../Source/tasks.c **** 					else
2273:../../Source/tasks.c **** 					{
2274:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2275:../../Source/tasks.c **** 					}
2276:../../Source/tasks.c **** 				}
2277:../../Source/tasks.c **** 
2278:../../Source/tasks.c **** 				if( xYieldPending != pdFALSE )
2279:../../Source/tasks.c **** 				{
2280:../../Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2281:../../Source/tasks.c **** 					{
2282:../../Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
2283:../../Source/tasks.c **** 					}
2284:../../Source/tasks.c **** 					#endif
2285:../../Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
2286:../../Source/tasks.c **** 				}
2287:../../Source/tasks.c **** 				else
2288:../../Source/tasks.c **** 				{
2289:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2290:../../Source/tasks.c **** 				}
2291:../../Source/tasks.c **** 			}
2292:../../Source/tasks.c **** 		}
2293:../../Source/tasks.c **** 		else
2294:../../Source/tasks.c **** 		{
2295:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2296:../../Source/tasks.c **** 		}
2297:../../Source/tasks.c **** 	}
2298:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
2299:../../Source/tasks.c **** 
2300:../../Source/tasks.c **** 	return xAlreadyYielded;
2301:../../Source/tasks.c **** }
2302:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2303:../../Source/tasks.c **** 
2304:../../Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2305:../../Source/tasks.c **** {
2306:../../Source/tasks.c **** TickType_t xTicks;
2307:../../Source/tasks.c **** 
2308:../../Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2309:../../Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2310:../../Source/tasks.c **** 	{
2311:../../Source/tasks.c **** 		xTicks = xTickCount;
2312:../../Source/tasks.c **** 	}
2313:../../Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2314:../../Source/tasks.c **** 
2315:../../Source/tasks.c **** 	return xTicks;
2316:../../Source/tasks.c **** }
2317:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2318:../../Source/tasks.c **** 
2319:../../Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2320:../../Source/tasks.c **** {
2321:../../Source/tasks.c **** TickType_t xReturn;
2322:../../Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2323:../../Source/tasks.c **** 
2324:../../Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2325:../../Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2326:../../Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2327:../../Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2328:../../Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2329:../../Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2330:../../Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2331:../../Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2332:../../Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2333:../../Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2334:../../Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2335:../../Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2336:../../Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2337:../../Source/tasks.c **** 	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
2338:../../Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2339:../../Source/tasks.c **** 
2340:../../Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2341:../../Source/tasks.c **** 	{
2342:../../Source/tasks.c **** 		xReturn = xTickCount;
2343:../../Source/tasks.c **** 	}
2344:../../Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2345:../../Source/tasks.c **** 
2346:../../Source/tasks.c **** 	return xReturn;
2347:../../Source/tasks.c **** }
2348:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2349:../../Source/tasks.c **** 
2350:../../Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2351:../../Source/tasks.c **** {
2352:../../Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2353:../../Source/tasks.c **** 	BaseType_t. */
2354:../../Source/tasks.c **** 	return uxCurrentNumberOfTasks;
2355:../../Source/tasks.c **** }
2356:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2357:../../Source/tasks.c **** 
2358:../../Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2359:../../Source/tasks.c **** {
2360:../../Source/tasks.c **** TCB_t *pxTCB;
2361:../../Source/tasks.c **** 
2362:../../Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2363:../../Source/tasks.c **** 	queried. */
2364:../../Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2365:../../Source/tasks.c **** 	configASSERT( pxTCB );
2366:../../Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
2367:../../Source/tasks.c **** }
2368:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2369:../../Source/tasks.c **** 
2370:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2371:../../Source/tasks.c **** 
2372:../../Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2373:../../Source/tasks.c **** 	{
2374:../../Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2375:../../Source/tasks.c **** 	UBaseType_t x;
2376:../../Source/tasks.c **** 	char cNextChar;
2377:../../Source/tasks.c **** 	BaseType_t xBreakLoop;
2378:../../Source/tasks.c **** 
2379:../../Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2380:../../Source/tasks.c **** 
2381:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2382:../../Source/tasks.c **** 		{
2383:../../Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro i
2384:../../Source/tasks.c **** 
2385:../../Source/tasks.c **** 			do
2386:../../Source/tasks.c **** 			{
2387:../../Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
2388:../../Source/tasks.c **** 
2389:../../Source/tasks.c **** 				/* Check each character in the name looking for a match or
2390:../../Source/tasks.c **** 				mismatch. */
2391:../../Source/tasks.c **** 				xBreakLoop = pdFALSE;
2392:../../Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2393:../../Source/tasks.c **** 				{
2394:../../Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2395:../../Source/tasks.c **** 
2396:../../Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2397:../../Source/tasks.c **** 					{
2398:../../Source/tasks.c **** 						/* Characters didn't match. */
2399:../../Source/tasks.c **** 						xBreakLoop = pdTRUE;
2400:../../Source/tasks.c **** 					}
2401:../../Source/tasks.c **** 					else if( cNextChar == ( char ) 0x00 )
2402:../../Source/tasks.c **** 					{
2403:../../Source/tasks.c **** 						/* Both strings terminated, a match must have been
2404:../../Source/tasks.c **** 						found. */
2405:../../Source/tasks.c **** 						pxReturn = pxNextTCB;
2406:../../Source/tasks.c **** 						xBreakLoop = pdTRUE;
2407:../../Source/tasks.c **** 					}
2408:../../Source/tasks.c **** 					else
2409:../../Source/tasks.c **** 					{
2410:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2411:../../Source/tasks.c **** 					}
2412:../../Source/tasks.c **** 
2413:../../Source/tasks.c **** 					if( xBreakLoop != pdFALSE )
2414:../../Source/tasks.c **** 					{
2415:../../Source/tasks.c **** 						break;
2416:../../Source/tasks.c **** 					}
2417:../../Source/tasks.c **** 				}
2418:../../Source/tasks.c **** 
2419:../../Source/tasks.c **** 				if( pxReturn != NULL )
2420:../../Source/tasks.c **** 				{
2421:../../Source/tasks.c **** 					/* The handle has been found. */
2422:../../Source/tasks.c **** 					break;
2423:../../Source/tasks.c **** 				}
2424:../../Source/tasks.c **** 
2425:../../Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2426:../../Source/tasks.c **** 		}
2427:../../Source/tasks.c **** 		else
2428:../../Source/tasks.c **** 		{
2429:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2430:../../Source/tasks.c **** 		}
2431:../../Source/tasks.c **** 
2432:../../Source/tasks.c **** 		return pxReturn;
2433:../../Source/tasks.c **** 	}
2434:../../Source/tasks.c **** 
2435:../../Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2436:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2437:../../Source/tasks.c **** 
2438:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2439:../../Source/tasks.c **** 
2440:../../Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2441:../../Source/tasks.c **** 	{
2442:../../Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2443:../../Source/tasks.c **** 	TCB_t* pxTCB;
2444:../../Source/tasks.c **** 
2445:../../Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2446:../../Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2447:../../Source/tasks.c **** 
2448:../../Source/tasks.c **** 		vTaskSuspendAll();
2449:../../Source/tasks.c **** 		{
2450:../../Source/tasks.c **** 			/* Search the ready lists. */
2451:../../Source/tasks.c **** 			do
2452:../../Source/tasks.c **** 			{
2453:../../Source/tasks.c **** 				uxQueue--;
2454:../../Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2455:../../Source/tasks.c **** 
2456:../../Source/tasks.c **** 				if( pxTCB != NULL )
2457:../../Source/tasks.c **** 				{
2458:../../Source/tasks.c **** 					/* Found the handle. */
2459:../../Source/tasks.c **** 					break;
2460:../../Source/tasks.c **** 				}
2461:../../Source/tasks.c **** 
2462:../../Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2463:../../Source/tasks.c **** 
2464:../../Source/tasks.c **** 			/* Search the delayed lists. */
2465:../../Source/tasks.c **** 			if( pxTCB == NULL )
2466:../../Source/tasks.c **** 			{
2467:../../Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2468:../../Source/tasks.c **** 			}
2469:../../Source/tasks.c **** 
2470:../../Source/tasks.c **** 			if( pxTCB == NULL )
2471:../../Source/tasks.c **** 			{
2472:../../Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2473:../../Source/tasks.c **** 			}
2474:../../Source/tasks.c **** 
2475:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2476:../../Source/tasks.c **** 			{
2477:../../Source/tasks.c **** 				if( pxTCB == NULL )
2478:../../Source/tasks.c **** 				{
2479:../../Source/tasks.c **** 					/* Search the suspended list. */
2480:../../Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2481:../../Source/tasks.c **** 				}
2482:../../Source/tasks.c **** 			}
2483:../../Source/tasks.c **** 			#endif
2484:../../Source/tasks.c **** 
2485:../../Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2486:../../Source/tasks.c **** 			{
2487:../../Source/tasks.c **** 				if( pxTCB == NULL )
2488:../../Source/tasks.c **** 				{
2489:../../Source/tasks.c **** 					/* Search the deleted list. */
2490:../../Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2491:../../Source/tasks.c **** 				}
2492:../../Source/tasks.c **** 			}
2493:../../Source/tasks.c **** 			#endif
2494:../../Source/tasks.c **** 		}
2495:../../Source/tasks.c **** 		( void ) xTaskResumeAll();
2496:../../Source/tasks.c **** 
2497:../../Source/tasks.c **** 		return pxTCB;
2498:../../Source/tasks.c **** 	}
2499:../../Source/tasks.c **** 
2500:../../Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2501:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2502:../../Source/tasks.c **** 
2503:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2504:../../Source/tasks.c **** 
2505:../../Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2506:../../Source/tasks.c **** 	{
2507:../../Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2508:../../Source/tasks.c **** 
2509:../../Source/tasks.c **** 		vTaskSuspendAll();
2510:../../Source/tasks.c **** 		{
2511:../../Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2512:../../Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2513:../../Source/tasks.c **** 			{
2514:../../Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2515:../../Source/tasks.c **** 				task in the Ready state. */
2516:../../Source/tasks.c **** 				do
2517:../../Source/tasks.c **** 				{
2518:../../Source/tasks.c **** 					uxQueue--;
2519:../../Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2520:../../Source/tasks.c **** 
2521:../../Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2522:../../Source/tasks.c **** 
2523:../../Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2524:../../Source/tasks.c **** 				task in the Blocked state. */
2525:../../Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2526:../../Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2527:../../Source/tasks.c **** 
2528:../../Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2529:../../Source/tasks.c **** 				{
2530:../../Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2531:../../Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2532:../../Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2533:../../Source/tasks.c **** 				}
2534:../../Source/tasks.c **** 				#endif
2535:../../Source/tasks.c **** 
2536:../../Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2537:../../Source/tasks.c **** 				{
2538:../../Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2539:../../Source/tasks.c **** 					each task in the Suspended state. */
2540:../../Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2541:../../Source/tasks.c **** 				}
2542:../../Source/tasks.c **** 				#endif
2543:../../Source/tasks.c **** 
2544:../../Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2545:../../Source/tasks.c **** 				{
2546:../../Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2547:../../Source/tasks.c **** 					{
2548:../../Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2549:../../Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2550:../../Source/tasks.c **** 						#else
2551:../../Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2552:../../Source/tasks.c **** 						#endif
2553:../../Source/tasks.c **** 					}
2554:../../Source/tasks.c **** 				}
2555:../../Source/tasks.c **** 				#else
2556:../../Source/tasks.c **** 				{
2557:../../Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2558:../../Source/tasks.c **** 					{
2559:../../Source/tasks.c **** 						*pulTotalRunTime = 0;
2560:../../Source/tasks.c **** 					}
2561:../../Source/tasks.c **** 				}
2562:../../Source/tasks.c **** 				#endif
2563:../../Source/tasks.c **** 			}
2564:../../Source/tasks.c **** 			else
2565:../../Source/tasks.c **** 			{
2566:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2567:../../Source/tasks.c **** 			}
2568:../../Source/tasks.c **** 		}
2569:../../Source/tasks.c **** 		( void ) xTaskResumeAll();
2570:../../Source/tasks.c **** 
2571:../../Source/tasks.c **** 		return uxTask;
2572:../../Source/tasks.c **** 	}
2573:../../Source/tasks.c **** 
2574:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2575:../../Source/tasks.c **** /*----------------------------------------------------------*/
2576:../../Source/tasks.c **** 
2577:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2578:../../Source/tasks.c **** 
2579:../../Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2580:../../Source/tasks.c **** 	{
2581:../../Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2582:../../Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2583:../../Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2584:../../Source/tasks.c **** 		return xIdleTaskHandle;
2585:../../Source/tasks.c **** 	}
2586:../../Source/tasks.c **** 
2587:../../Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2588:../../Source/tasks.c **** /*----------------------------------------------------------*/
2589:../../Source/tasks.c **** 
2590:../../Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2591:../../Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2592:../../Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2593:../../Source/tasks.c **** 1. */
2594:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2595:../../Source/tasks.c **** 
2596:../../Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2597:../../Source/tasks.c **** 	{
2598:../../Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2599:../../Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2600:../../Source/tasks.c **** 		each stepped tick. */
2601:../../Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2602:../../Source/tasks.c **** 		xTickCount += xTicksToJump;
2603:../../Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2604:../../Source/tasks.c **** 	}
2605:../../Source/tasks.c **** 
2606:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2607:../../Source/tasks.c **** /*----------------------------------------------------------*/
2608:../../Source/tasks.c **** 
2609:../../Source/tasks.c **** BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
2610:../../Source/tasks.c **** {
2611:../../Source/tasks.c **** BaseType_t xYieldRequired = pdFALSE;
2612:../../Source/tasks.c **** 
2613:../../Source/tasks.c **** 	/* Must not be called with the scheduler suspended as the implementation
2614:../../Source/tasks.c **** 	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
2615:../../Source/tasks.c **** 	configASSERT( uxSchedulerSuspended == 0 );
2616:../../Source/tasks.c **** 
2617:../../Source/tasks.c **** 	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
2618:../../Source/tasks.c **** 	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
2619:../../Source/tasks.c **** 	vTaskSuspendAll();
2620:../../Source/tasks.c **** 	xPendedTicks += xTicksToCatchUp;
2621:../../Source/tasks.c **** 	xYieldRequired = xTaskResumeAll();
2622:../../Source/tasks.c **** 
2623:../../Source/tasks.c **** 	return xYieldRequired;
2624:../../Source/tasks.c **** }
2625:../../Source/tasks.c **** /*----------------------------------------------------------*/
2626:../../Source/tasks.c **** 
2627:../../Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2628:../../Source/tasks.c **** 
2629:../../Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2630:../../Source/tasks.c **** 	{
2631:../../Source/tasks.c **** 	TCB_t *pxTCB = xTask;
2632:../../Source/tasks.c **** 	BaseType_t xReturn;
2633:../../Source/tasks.c **** 
2634:../../Source/tasks.c **** 		configASSERT( pxTCB );
2635:../../Source/tasks.c **** 
2636:../../Source/tasks.c **** 		vTaskSuspendAll();
2637:../../Source/tasks.c **** 		{
2638:../../Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2639:../../Source/tasks.c **** 			it is actually in the Blocked state. */
2640:../../Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2641:../../Source/tasks.c **** 			{
2642:../../Source/tasks.c **** 				xReturn = pdPASS;
2643:../../Source/tasks.c **** 
2644:../../Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2645:../../Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2646:../../Source/tasks.c **** 				scheduler is suspended. */
2647:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2648:../../Source/tasks.c **** 
2649:../../Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2650:../../Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2651:../../Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2652:../../Source/tasks.c **** 				is used. */
2653:../../Source/tasks.c **** 				taskENTER_CRITICAL();
2654:../../Source/tasks.c **** 				{
2655:../../Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2656:../../Source/tasks.c **** 					{
2657:../../Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2658:../../Source/tasks.c **** 
2659:../../Source/tasks.c **** 						/* This lets the task know it was forcibly removed from the
2660:../../Source/tasks.c **** 						blocked state so it should not re-evaluate its block time and
2661:../../Source/tasks.c **** 						then block again. */
2662:../../Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2663:../../Source/tasks.c **** 					}
2664:../../Source/tasks.c **** 					else
2665:../../Source/tasks.c **** 					{
2666:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2667:../../Source/tasks.c **** 					}
2668:../../Source/tasks.c **** 				}
2669:../../Source/tasks.c **** 				taskEXIT_CRITICAL();
2670:../../Source/tasks.c **** 
2671:../../Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2672:../../Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2673:../../Source/tasks.c **** 
2674:../../Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2675:../../Source/tasks.c **** 				switch if preemption is turned off. */
2676:../../Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2677:../../Source/tasks.c **** 				{
2678:../../Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
2679:../../Source/tasks.c **** 					performed if the unblocked task has a priority that is
2680:../../Source/tasks.c **** 					equal to or higher than the currently executing task. */
2681:../../Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2682:../../Source/tasks.c **** 					{
2683:../../Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2684:../../Source/tasks.c **** 						is unsuspended. */
2685:../../Source/tasks.c **** 						xYieldPending = pdTRUE;
2686:../../Source/tasks.c **** 					}
2687:../../Source/tasks.c **** 					else
2688:../../Source/tasks.c **** 					{
2689:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2690:../../Source/tasks.c **** 					}
2691:../../Source/tasks.c **** 				}
2692:../../Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2693:../../Source/tasks.c **** 			}
2694:../../Source/tasks.c **** 			else
2695:../../Source/tasks.c **** 			{
2696:../../Source/tasks.c **** 				xReturn = pdFAIL;
2697:../../Source/tasks.c **** 			}
2698:../../Source/tasks.c **** 		}
2699:../../Source/tasks.c **** 		( void ) xTaskResumeAll();
2700:../../Source/tasks.c **** 
2701:../../Source/tasks.c **** 		return xReturn;
2702:../../Source/tasks.c **** 	}
2703:../../Source/tasks.c **** 
2704:../../Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2705:../../Source/tasks.c **** /*----------------------------------------------------------*/
2706:../../Source/tasks.c **** 
2707:../../Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2708:../../Source/tasks.c **** {
2709:../../Source/tasks.c **** TCB_t * pxTCB;
2710:../../Source/tasks.c **** TickType_t xItemValue;
2711:../../Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
2712:../../Source/tasks.c **** 
2713:../../Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2714:../../Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2715:../../Source/tasks.c **** 	tasks to be unblocked. */
2716:../../Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2717:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2718:../../Source/tasks.c **** 	{
2719:../../Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2720:../../Source/tasks.c **** 		block. */
2721:../../Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2722:../../Source/tasks.c **** 
2723:../../Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2724:../../Source/tasks.c **** 		delayed lists if it wraps to 0. */
2725:../../Source/tasks.c **** 		xTickCount = xConstTickCount;
2726:../../Source/tasks.c **** 
2727:../../Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
2728:../../Source/tasks.c **** 		{
2729:../../Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
2730:../../Source/tasks.c **** 		}
2731:../../Source/tasks.c **** 		else
2732:../../Source/tasks.c **** 		{
2733:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2734:../../Source/tasks.c **** 		}
2735:../../Source/tasks.c **** 
2736:../../Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2737:../../Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2738:../../Source/tasks.c **** 		has been found whose block time has not expired there is no need to
2739:../../Source/tasks.c **** 		look any further down the list. */
2740:../../Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
2741:../../Source/tasks.c **** 		{
2742:../../Source/tasks.c **** 			for( ;; )
2743:../../Source/tasks.c **** 			{
2744:../../Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2745:../../Source/tasks.c **** 				{
2746:../../Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2747:../../Source/tasks.c **** 					to the maximum possible value so it is extremely
2748:../../Source/tasks.c **** 					unlikely that the
2749:../../Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2750:../../Source/tasks.c **** 					next time through. */
2751:../../Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
2752:../../Source/tasks.c **** 					break;
2753:../../Source/tasks.c **** 				}
2754:../../Source/tasks.c **** 				else
2755:../../Source/tasks.c **** 				{
2756:../../Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2757:../../Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2758:../../Source/tasks.c **** 					at which the task at the head of the delayed list must
2759:../../Source/tasks.c **** 					be removed from the Blocked state. */
2760:../../Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this
2761:../../Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2762:../../Source/tasks.c **** 
2763:../../Source/tasks.c **** 					if( xConstTickCount < xItemValue )
2764:../../Source/tasks.c **** 					{
2765:../../Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2766:../../Source/tasks.c **** 						item value is the time at which the task at the head
2767:../../Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2768:../../Source/tasks.c **** 						state -	so record the item value in
2769:../../Source/tasks.c **** 						xNextTaskUnblockTime. */
2770:../../Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
2771:../../Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
2772:../../Source/tasks.c **** 					}
2773:../../Source/tasks.c **** 					else
2774:../../Source/tasks.c **** 					{
2775:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2776:../../Source/tasks.c **** 					}
2777:../../Source/tasks.c **** 
2778:../../Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2779:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2780:../../Source/tasks.c **** 
2781:../../Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2782:../../Source/tasks.c **** 					it from the event list. */
2783:../../Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2784:../../Source/tasks.c **** 					{
2785:../../Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2786:../../Source/tasks.c **** 					}
2787:../../Source/tasks.c **** 					else
2788:../../Source/tasks.c **** 					{
2789:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2790:../../Source/tasks.c **** 					}
2791:../../Source/tasks.c **** 
2792:../../Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2793:../../Source/tasks.c **** 					list. */
2794:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2795:../../Source/tasks.c **** 
2796:../../Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2797:../../Source/tasks.c **** 					context switch if preemption is turned off. */
2798:../../Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2799:../../Source/tasks.c **** 					{
2800:../../Source/tasks.c **** 						/* Preemption is on, but a context switch should
2801:../../Source/tasks.c **** 						only be performed if the unblocked task has a
2802:../../Source/tasks.c **** 						priority that is equal to or higher than the
2803:../../Source/tasks.c **** 						currently executing task. */
2804:../../Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2805:../../Source/tasks.c **** 						{
2806:../../Source/tasks.c **** 							xSwitchRequired = pdTRUE;
2807:../../Source/tasks.c **** 						}
2808:../../Source/tasks.c **** 						else
2809:../../Source/tasks.c **** 						{
2810:../../Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2811:../../Source/tasks.c **** 						}
2812:../../Source/tasks.c **** 					}
2813:../../Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2814:../../Source/tasks.c **** 				}
2815:../../Source/tasks.c **** 			}
2816:../../Source/tasks.c **** 		}
2817:../../Source/tasks.c **** 
2818:../../Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2819:../../Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2820:../../Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2821:../../Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2822:../../Source/tasks.c **** 		{
2823:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2824:../../Source/tasks.c **** 			{
2825:../../Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2826:../../Source/tasks.c **** 			}
2827:../../Source/tasks.c **** 			else
2828:../../Source/tasks.c **** 			{
2829:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2830:../../Source/tasks.c **** 			}
2831:../../Source/tasks.c **** 		}
2832:../../Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2833:../../Source/tasks.c **** 
2834:../../Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2835:../../Source/tasks.c **** 		{
2836:../../Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2837:../../Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2838:../../Source/tasks.c **** 			if( xPendedTicks == ( TickType_t ) 0 )
2839:../../Source/tasks.c **** 			{
2840:../../Source/tasks.c **** 				vApplicationTickHook();
2841:../../Source/tasks.c **** 			}
2842:../../Source/tasks.c **** 			else
2843:../../Source/tasks.c **** 			{
2844:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2845:../../Source/tasks.c **** 			}
2846:../../Source/tasks.c **** 		}
2847:../../Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2848:../../Source/tasks.c **** 
2849:../../Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 1 )
2850:../../Source/tasks.c **** 		{
2851:../../Source/tasks.c **** 			if( xYieldPending != pdFALSE )
2852:../../Source/tasks.c **** 			{
2853:../../Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2854:../../Source/tasks.c **** 			}
2855:../../Source/tasks.c **** 			else
2856:../../Source/tasks.c **** 			{
2857:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2858:../../Source/tasks.c **** 			}
2859:../../Source/tasks.c **** 		}
2860:../../Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2861:../../Source/tasks.c **** 	}
2862:../../Source/tasks.c **** 	else
2863:../../Source/tasks.c **** 	{
2864:../../Source/tasks.c **** 		++xPendedTicks;
2865:../../Source/tasks.c **** 
2866:../../Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2867:../../Source/tasks.c **** 		scheduler is locked. */
2868:../../Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2869:../../Source/tasks.c **** 		{
2870:../../Source/tasks.c **** 			vApplicationTickHook();
2871:../../Source/tasks.c **** 		}
2872:../../Source/tasks.c **** 		#endif
2873:../../Source/tasks.c **** 	}
2874:../../Source/tasks.c **** 
2875:../../Source/tasks.c **** 	return xSwitchRequired;
2876:../../Source/tasks.c **** }
2877:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2878:../../Source/tasks.c **** 
2879:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2880:../../Source/tasks.c **** 
2881:../../Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2882:../../Source/tasks.c **** 	{
2883:../../Source/tasks.c **** 	TCB_t *xTCB;
2884:../../Source/tasks.c **** 
2885:../../Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2886:../../Source/tasks.c **** 		getting set. */
2887:../../Source/tasks.c **** 		if( xTask == NULL )
2888:../../Source/tasks.c **** 		{
2889:../../Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2890:../../Source/tasks.c **** 		}
2891:../../Source/tasks.c **** 		else
2892:../../Source/tasks.c **** 		{
2893:../../Source/tasks.c **** 			xTCB = xTask;
2894:../../Source/tasks.c **** 		}
2895:../../Source/tasks.c **** 
2896:../../Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2897:../../Source/tasks.c **** 		the value can be accessed from an interrupt. */
2898:../../Source/tasks.c **** 		taskENTER_CRITICAL();
2899:../../Source/tasks.c **** 		{
2900:../../Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2901:../../Source/tasks.c **** 		}
2902:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
2903:../../Source/tasks.c **** 	}
2904:../../Source/tasks.c **** 
2905:../../Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2906:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2907:../../Source/tasks.c **** 
2908:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2909:../../Source/tasks.c **** 
2910:../../Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2911:../../Source/tasks.c **** 	{
2912:../../Source/tasks.c **** 	TCB_t *pxTCB;
2913:../../Source/tasks.c **** 	TaskHookFunction_t xReturn;
2914:../../Source/tasks.c **** 
2915:../../Source/tasks.c **** 		/* If xTask is NULL then set the calling task's hook. */
2916:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2917:../../Source/tasks.c **** 
2918:../../Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2919:../../Source/tasks.c **** 		the value can be accessed from an interrupt. */
2920:../../Source/tasks.c **** 		taskENTER_CRITICAL();
2921:../../Source/tasks.c **** 		{
2922:../../Source/tasks.c **** 			xReturn = pxTCB->pxTaskTag;
2923:../../Source/tasks.c **** 		}
2924:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
2925:../../Source/tasks.c **** 
2926:../../Source/tasks.c **** 		return xReturn;
2927:../../Source/tasks.c **** 	}
2928:../../Source/tasks.c **** 
2929:../../Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2930:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2931:../../Source/tasks.c **** 
2932:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2933:../../Source/tasks.c **** 
2934:../../Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
2935:../../Source/tasks.c **** 	{
2936:../../Source/tasks.c **** 	TCB_t *pxTCB;
2937:../../Source/tasks.c **** 	TaskHookFunction_t xReturn;
2938:../../Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
2939:../../Source/tasks.c **** 
2940:../../Source/tasks.c **** 		/* If xTask is NULL then set the calling task's hook. */
2941:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2942:../../Source/tasks.c **** 
2943:../../Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2944:../../Source/tasks.c **** 		the value can be accessed from an interrupt. */
2945:../../Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2946:../../Source/tasks.c **** 		{
2947:../../Source/tasks.c **** 			xReturn = pxTCB->pxTaskTag;
2948:../../Source/tasks.c **** 		}
2949:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2950:../../Source/tasks.c **** 
2951:../../Source/tasks.c **** 		return xReturn;
2952:../../Source/tasks.c **** 	}
2953:../../Source/tasks.c **** 
2954:../../Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2955:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2956:../../Source/tasks.c **** 
2957:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2958:../../Source/tasks.c **** 
2959:../../Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2960:../../Source/tasks.c **** 	{
2961:../../Source/tasks.c **** 	TCB_t *xTCB;
2962:../../Source/tasks.c **** 	BaseType_t xReturn;
2963:../../Source/tasks.c **** 
2964:../../Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2965:../../Source/tasks.c **** 		if( xTask == NULL )
2966:../../Source/tasks.c **** 		{
2967:../../Source/tasks.c **** 			xTCB = pxCurrentTCB;
2968:../../Source/tasks.c **** 		}
2969:../../Source/tasks.c **** 		else
2970:../../Source/tasks.c **** 		{
2971:../../Source/tasks.c **** 			xTCB = xTask;
2972:../../Source/tasks.c **** 		}
2973:../../Source/tasks.c **** 
2974:../../Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2975:../../Source/tasks.c **** 		{
2976:../../Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2977:../../Source/tasks.c **** 		}
2978:../../Source/tasks.c **** 		else
2979:../../Source/tasks.c **** 		{
2980:../../Source/tasks.c **** 			xReturn = pdFAIL;
2981:../../Source/tasks.c **** 		}
2982:../../Source/tasks.c **** 
2983:../../Source/tasks.c **** 		return xReturn;
2984:../../Source/tasks.c **** 	}
2985:../../Source/tasks.c **** 
2986:../../Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2987:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2988:../../Source/tasks.c **** 
2989:../../Source/tasks.c **** void vTaskSwitchContext( void )
2990:../../Source/tasks.c **** {
2991:../../Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2992:../../Source/tasks.c **** 	{
2993:../../Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2994:../../Source/tasks.c **** 		switch. */
2995:../../Source/tasks.c **** 		xYieldPending = pdTRUE;
2996:../../Source/tasks.c **** 	}
2997:../../Source/tasks.c **** 	else
2998:../../Source/tasks.c **** 	{
2999:../../Source/tasks.c **** 		xYieldPending = pdFALSE;
3000:../../Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
3001:../../Source/tasks.c **** 
3002:../../Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3003:../../Source/tasks.c **** 		{
3004:../../Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
3005:../../Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
3006:../../Source/tasks.c **** 			#else
3007:../../Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
3008:../../Source/tasks.c **** 			#endif
3009:../../Source/tasks.c **** 
3010:../../Source/tasks.c **** 			/* Add the amount of time the task has been running to the
3011:../../Source/tasks.c **** 			accumulated time so far.  The time the task started running was
3012:../../Source/tasks.c **** 			stored in ulTaskSwitchedInTime.  Note that there is no overflow
3013:../../Source/tasks.c **** 			protection here so count values are only valid until the timer
3014:../../Source/tasks.c **** 			overflows.  The guard against negative values is to protect
3015:../../Source/tasks.c **** 			against suspect run time stat counter implementations - which
3016:../../Source/tasks.c **** 			are provided by the application, not the kernel. */
3017:../../Source/tasks.c **** 			if( ulTotalRunTime > ulTaskSwitchedInTime )
3018:../../Source/tasks.c **** 			{
3019:../../Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
3020:../../Source/tasks.c **** 			}
3021:../../Source/tasks.c **** 			else
3022:../../Source/tasks.c **** 			{
3023:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3024:../../Source/tasks.c **** 			}
3025:../../Source/tasks.c **** 			ulTaskSwitchedInTime = ulTotalRunTime;
3026:../../Source/tasks.c **** 		}
3027:../../Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
3028:../../Source/tasks.c **** 
3029:../../Source/tasks.c **** 		/* Check for stack overflow, if configured. */
3030:../../Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
3031:../../Source/tasks.c **** 
3032:../../Source/tasks.c **** 		/* Before the currently running task is switched out, save its errno. */
3033:../../Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
3034:../../Source/tasks.c **** 		{
3035:../../Source/tasks.c **** 			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
3036:../../Source/tasks.c **** 		}
3037:../../Source/tasks.c **** 		#endif
3038:../../Source/tasks.c **** 
3039:../../Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
3040:../../Source/tasks.c **** 		optimised asm code. */
3041:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timer
3042:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
3043:../../Source/tasks.c **** 
3044:../../Source/tasks.c **** 		/* After the new task is switched in, update the global errno. */
3045:../../Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
3046:../../Source/tasks.c **** 		{
3047:../../Source/tasks.c **** 			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
3048:../../Source/tasks.c **** 		}
3049:../../Source/tasks.c **** 		#endif
3050:../../Source/tasks.c **** 
3051:../../Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3052:../../Source/tasks.c **** 		{
3053:../../Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
3054:../../Source/tasks.c **** 			structure specific to this task.
3055:../../Source/tasks.c **** 			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3056:../../Source/tasks.c **** 			for additional information. */
3057:../../Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
3058:../../Source/tasks.c **** 		}
3059:../../Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3060:../../Source/tasks.c **** 	}
3061:../../Source/tasks.c **** }
3062:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3063:../../Source/tasks.c **** 
3064:../../Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
3065:../../Source/tasks.c **** {
3066:../../Source/tasks.c **** 	configASSERT( pxEventList );
3067:../../Source/tasks.c **** 
3068:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
3069:../../Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
3070:../../Source/tasks.c **** 
3071:../../Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
3072:../../Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
3073:../../Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
3074:../../Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
3075:../../Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3076:../../Source/tasks.c **** 
3077:../../Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3078:../../Source/tasks.c **** }
3079:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3080:../../Source/tasks.c **** 
3081:../../Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
3082:../../Source/tasks.c **** {
3083:../../Source/tasks.c **** 	configASSERT( pxEventList );
3084:../../Source/tasks.c **** 
3085:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3086:../../Source/tasks.c **** 	the event groups implementation. */
3087:../../Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
3088:../../Source/tasks.c **** 
3089:../../Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
3090:../../Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
3091:../../Source/tasks.c **** 	task that is not in the Blocked state. */
3092:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
3093:../../Source/tasks.c **** 
3094:../../Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
3095:../../Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
3096:../../Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
3097:../../Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
3098:../../Source/tasks.c **** 	the task level). */
3099:../../Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3100:../../Source/tasks.c **** 
3101:../../Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3102:../../Source/tasks.c **** }
3103:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3104:../../Source/tasks.c **** 
3105:../../Source/tasks.c **** #if( configUSE_TIMERS == 1 )
3106:../../Source/tasks.c **** 
3107:../../Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
3108:../../Source/tasks.c **** 	{
3109:../../Source/tasks.c **** 		configASSERT( pxEventList );
3110:../../Source/tasks.c **** 
3111:../../Source/tasks.c **** 		/* This function should not be called by application code hence the
3112:../../Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
3113:../../Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
3114:../../Source/tasks.c **** 		it should be called with the scheduler suspended. */
3115:../../Source/tasks.c **** 
3116:../../Source/tasks.c **** 
3117:../../Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
3118:../../Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
3119:../../Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
3120:../../Source/tasks.c **** 		can be used in place of vListInsert. */
3121:../../Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3122:../../Source/tasks.c **** 
3123:../../Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
3124:../../Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
3125:../../Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
3126:../../Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
3127:../../Source/tasks.c **** 		{
3128:../../Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
3129:../../Source/tasks.c **** 		}
3130:../../Source/tasks.c **** 
3131:../../Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3132:../../Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3133:../../Source/tasks.c **** 	}
3134:../../Source/tasks.c **** 
3135:../../Source/tasks.c **** #endif /* configUSE_TIMERS */
3136:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3137:../../Source/tasks.c **** 
3138:../../Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3139:../../Source/tasks.c **** {
3140:../../Source/tasks.c **** TCB_t *pxUnblockedTCB;
3141:../../Source/tasks.c **** BaseType_t xReturn;
3142:../../Source/tasks.c **** 
3143:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3144:../../Source/tasks.c **** 	called from a critical section within an ISR. */
3145:../../Source/tasks.c **** 
3146:../../Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
3147:../../Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
3148:../../Source/tasks.c **** 	the delayed list, and add it to the ready list.
3149:../../Source/tasks.c **** 
3150:../../Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
3151:../../Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
3152:../../Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
3153:../../Source/tasks.c **** 
3154:../../Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
3155:../../Source/tasks.c **** 	pxEventList is not empty. */
3156:../../Source/tasks.c **** 	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this 
3157:../../Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3158:../../Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
3159:../../Source/tasks.c **** 
3160:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3161:../../Source/tasks.c **** 	{
3162:../../Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3163:../../Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
3164:../../Source/tasks.c **** 
3165:../../Source/tasks.c **** 		#if( configUSE_TICKLESS_IDLE != 0 )
3166:../../Source/tasks.c **** 		{
3167:../../Source/tasks.c **** 			/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3168:../../Source/tasks.c **** 			might be set to the blocked task's time out time.  If the task is
3169:../../Source/tasks.c **** 			unblocked for a reason other than a timeout xNextTaskUnblockTime is
3170:../../Source/tasks.c **** 			normally left unchanged, because it is automatically reset to a new
3171:../../Source/tasks.c **** 			value when the tick count equals xNextTaskUnblockTime.  However if
3172:../../Source/tasks.c **** 			tickless idling is used it might be more important to enter sleep mode
3173:../../Source/tasks.c **** 			at the earliest possible time - so reset xNextTaskUnblockTime here to
3174:../../Source/tasks.c **** 			ensure it is updated at the earliest possible time. */
3175:../../Source/tasks.c **** 			prvResetNextTaskUnblockTime();
3176:../../Source/tasks.c **** 		}
3177:../../Source/tasks.c **** 		#endif
3178:../../Source/tasks.c **** 	}
3179:../../Source/tasks.c **** 	else
3180:../../Source/tasks.c **** 	{
3181:../../Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3182:../../Source/tasks.c **** 		pending until the scheduler is resumed. */
3183:../../Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3184:../../Source/tasks.c **** 	}
3185:../../Source/tasks.c **** 
3186:../../Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3187:../../Source/tasks.c **** 	{
3188:../../Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3189:../../Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3190:../../Source/tasks.c **** 		it should force a context switch now. */
3191:../../Source/tasks.c **** 		xReturn = pdTRUE;
3192:../../Source/tasks.c **** 
3193:../../Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3194:../../Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3195:../../Source/tasks.c **** 		xYieldPending = pdTRUE;
3196:../../Source/tasks.c **** 	}
3197:../../Source/tasks.c **** 	else
3198:../../Source/tasks.c **** 	{
3199:../../Source/tasks.c **** 		xReturn = pdFALSE;
3200:../../Source/tasks.c **** 	}
3201:../../Source/tasks.c **** 
3202:../../Source/tasks.c **** 	return xReturn;
3203:../../Source/tasks.c **** }
3204:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3205:../../Source/tasks.c **** 
3206:../../Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3207:../../Source/tasks.c **** {
3208:../../Source/tasks.c **** TCB_t *pxUnblockedTCB;
3209:../../Source/tasks.c **** 
3210:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3211:../../Source/tasks.c **** 	the event flags implementation. */
3212:../../Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3213:../../Source/tasks.c **** 
3214:../../Source/tasks.c **** 	/* Store the new item value in the event list. */
3215:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3216:../../Source/tasks.c **** 
3217:../../Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3218:../../Source/tasks.c **** 	event flags. */
3219:../../Source/tasks.c **** 	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this 
3220:../../Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3221:../../Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
3222:../../Source/tasks.c **** 
3223:../../Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3224:../../Source/tasks.c **** 	{
3225:../../Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3226:../../Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3227:../../Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3228:../../Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3229:../../Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3230:../../Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3231:../../Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3232:../../Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
3233:../../Source/tasks.c **** 		prvResetNextTaskUnblockTime();
3234:../../Source/tasks.c **** 	}
3235:../../Source/tasks.c **** 	#endif
3236:../../Source/tasks.c **** 
3237:../../Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3238:../../Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3239:../../Source/tasks.c **** 	lists. */
3240:../../Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3241:../../Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
3242:../../Source/tasks.c **** 
3243:../../Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3244:../../Source/tasks.c **** 	{
3245:../../Source/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3246:../../Source/tasks.c **** 		a context switch is required.  This function is called with the
3247:../../Source/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3248:../../Source/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3249:../../Source/tasks.c **** 		xYieldPending = pdTRUE;
3250:../../Source/tasks.c **** 	}
3251:../../Source/tasks.c **** }
3252:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3253:../../Source/tasks.c **** 
3254:../../Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3255:../../Source/tasks.c **** {
3256:../../Source/tasks.c **** 	configASSERT( pxTimeOut );
3257:../../Source/tasks.c **** 	taskENTER_CRITICAL();
3258:../../Source/tasks.c **** 	{
3259:../../Source/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
3260:../../Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
3261:../../Source/tasks.c **** 	}
3262:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
3263:../../Source/tasks.c **** }
3264:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3265:../../Source/tasks.c **** 
3266:../../Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3267:../../Source/tasks.c **** {
3268:../../Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3269:../../Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
3270:../../Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
3271:../../Source/tasks.c **** }
3272:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3273:../../Source/tasks.c **** 
3274:../../Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3275:../../Source/tasks.c **** {
3276:../../Source/tasks.c **** BaseType_t xReturn;
3277:../../Source/tasks.c **** 
3278:../../Source/tasks.c **** 	configASSERT( pxTimeOut );
3279:../../Source/tasks.c **** 	configASSERT( pxTicksToWait );
3280:../../Source/tasks.c **** 
3281:../../Source/tasks.c **** 	taskENTER_CRITICAL();
3282:../../Source/tasks.c **** 	{
3283:../../Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3284:../../Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
3285:../../Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3286:../../Source/tasks.c **** 
3287:../../Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3288:../../Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3289:../../Source/tasks.c **** 			{
3290:../../Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3291:../../Source/tasks.c **** 				but has the same result. */
3292:../../Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3293:../../Source/tasks.c **** 				xReturn = pdTRUE;
3294:../../Source/tasks.c **** 			}
3295:../../Source/tasks.c **** 			else
3296:../../Source/tasks.c **** 		#endif
3297:../../Source/tasks.c **** 
3298:../../Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3299:../../Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
3300:../../Source/tasks.c **** 			{
3301:../../Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3302:../../Source/tasks.c **** 				specified is the maximum block time then the task should block
3303:../../Source/tasks.c **** 				indefinitely, and therefore never time out. */
3304:../../Source/tasks.c **** 				xReturn = pdFALSE;
3305:../../Source/tasks.c **** 			}
3306:../../Source/tasks.c **** 			else
3307:../../Source/tasks.c **** 		#endif
3308:../../Source/tasks.c **** 
3309:../../Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
3310:../../Source/tasks.c **** 		{
3311:../../Source/tasks.c **** 			/* The tick count is greater than the time at which
3312:../../Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3313:../../Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3314:../../Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3315:../../Source/tasks.c **** 			was called. */
3316:../../Source/tasks.c **** 			xReturn = pdTRUE;
3317:../../Source/tasks.c **** 		}
3318:../../Source/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
3319:../../Source/tasks.c **** 		{
3320:../../Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3321:../../Source/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
3322:../../Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
3323:../../Source/tasks.c **** 			xReturn = pdFALSE;
3324:../../Source/tasks.c **** 		}
3325:../../Source/tasks.c **** 		else
3326:../../Source/tasks.c **** 		{
3327:../../Source/tasks.c **** 			*pxTicksToWait = 0;
3328:../../Source/tasks.c **** 			xReturn = pdTRUE;
3329:../../Source/tasks.c **** 		}
3330:../../Source/tasks.c **** 	}
3331:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
3332:../../Source/tasks.c **** 
3333:../../Source/tasks.c **** 	return xReturn;
3334:../../Source/tasks.c **** }
3335:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3336:../../Source/tasks.c **** 
3337:../../Source/tasks.c **** void vTaskMissedYield( void )
3338:../../Source/tasks.c **** {
3339:../../Source/tasks.c **** 	xYieldPending = pdTRUE;
3340:../../Source/tasks.c **** }
3341:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3342:../../Source/tasks.c **** 
3343:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3344:../../Source/tasks.c **** 
3345:../../Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3346:../../Source/tasks.c **** 	{
3347:../../Source/tasks.c **** 	UBaseType_t uxReturn;
3348:../../Source/tasks.c **** 	TCB_t const *pxTCB;
3349:../../Source/tasks.c **** 
3350:../../Source/tasks.c **** 		if( xTask != NULL )
3351:../../Source/tasks.c **** 		{
3352:../../Source/tasks.c **** 			pxTCB = xTask;
3353:../../Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3354:../../Source/tasks.c **** 		}
3355:../../Source/tasks.c **** 		else
3356:../../Source/tasks.c **** 		{
3357:../../Source/tasks.c **** 			uxReturn = 0U;
3358:../../Source/tasks.c **** 		}
3359:../../Source/tasks.c **** 
3360:../../Source/tasks.c **** 		return uxReturn;
3361:../../Source/tasks.c **** 	}
3362:../../Source/tasks.c **** 
3363:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3364:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3365:../../Source/tasks.c **** 
3366:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3367:../../Source/tasks.c **** 
3368:../../Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3369:../../Source/tasks.c **** 	{
3370:../../Source/tasks.c **** 	TCB_t * pxTCB;
3371:../../Source/tasks.c **** 
3372:../../Source/tasks.c **** 		if( xTask != NULL )
3373:../../Source/tasks.c **** 		{
3374:../../Source/tasks.c **** 			pxTCB = xTask;
3375:../../Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3376:../../Source/tasks.c **** 		}
3377:../../Source/tasks.c **** 	}
3378:../../Source/tasks.c **** 
3379:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3380:../../Source/tasks.c **** 
3381:../../Source/tasks.c **** /*
3382:../../Source/tasks.c ****  * -----------------------------------------------------------
3383:../../Source/tasks.c ****  * The Idle task.
3384:../../Source/tasks.c ****  * ----------------------------------------------------------
3385:../../Source/tasks.c ****  *
3386:../../Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3387:../../Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3388:../../Source/tasks.c ****  *
3389:../../Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3390:../../Source/tasks.c ****  *
3391:../../Source/tasks.c ****  */
3392:../../Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3393:../../Source/tasks.c **** {
3394:../../Source/tasks.c **** 	/* Stop warnings. */
3395:../../Source/tasks.c **** 	( void ) pvParameters;
3396:../../Source/tasks.c **** 
3397:../../Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3398:../../Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3399:../../Source/tasks.c **** 
3400:../../Source/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3401:../../Source/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3402:../../Source/tasks.c **** 	any. */
3403:../../Source/tasks.c **** 	portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
3404:../../Source/tasks.c **** 
3405:../../Source/tasks.c **** 	for( ;; )
3406:../../Source/tasks.c **** 	{
3407:../../Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3408:../../Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3409:../../Source/tasks.c **** 		prvCheckTasksWaitingTermination();
3410:../../Source/tasks.c **** 
3411:../../Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3412:../../Source/tasks.c **** 		{
3413:../../Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3414:../../Source/tasks.c **** 			see if any other task has become available.  If we are using
3415:../../Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3416:../../Source/tasks.c **** 			will automatically get the processor anyway. */
3417:../../Source/tasks.c **** 			taskYIELD();
3418:../../Source/tasks.c **** 		}
3419:../../Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3420:../../Source/tasks.c **** 
3421:../../Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3422:../../Source/tasks.c **** 		{
3423:../../Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3424:../../Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3425:../../Source/tasks.c **** 			to run then the idle task should yield before the end of the
3426:../../Source/tasks.c **** 			timeslice.
3427:../../Source/tasks.c **** 
3428:../../Source/tasks.c **** 			A critical region is not required here as we are just reading from
3429:../../Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3430:../../Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3431:../../Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3432:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3433:../../Source/tasks.c **** 			{
3434:../../Source/tasks.c **** 				taskYIELD();
3435:../../Source/tasks.c **** 			}
3436:../../Source/tasks.c **** 			else
3437:../../Source/tasks.c **** 			{
3438:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3439:../../Source/tasks.c **** 			}
3440:../../Source/tasks.c **** 		}
3441:../../Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3442:../../Source/tasks.c **** 
3443:../../Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3444:../../Source/tasks.c **** 		{
3445:../../Source/tasks.c **** 			extern void vApplicationIdleHook( void );
3446:../../Source/tasks.c **** 
3447:../../Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3448:../../Source/tasks.c **** 			allows the application designer to add background functionality
3449:../../Source/tasks.c **** 			without the overhead of a separate task.
3450:../../Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3451:../../Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3452:../../Source/tasks.c **** 			vApplicationIdleHook();
3453:../../Source/tasks.c **** 		}
3454:../../Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3455:../../Source/tasks.c **** 
3456:../../Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3457:../../Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3458:../../Source/tasks.c **** 		user defined low power mode	implementations require
3459:../../Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3460:../../Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3461:../../Source/tasks.c **** 		{
3462:../../Source/tasks.c **** 		TickType_t xExpectedIdleTime;
3463:../../Source/tasks.c **** 
3464:../../Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3465:../../Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3466:../../Source/tasks.c **** 			test of the expected idle time is performed without the
3467:../../Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3468:../../Source/tasks.c **** 			valid. */
3469:../../Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3470:../../Source/tasks.c **** 
3471:../../Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3472:../../Source/tasks.c **** 			{
3473:../../Source/tasks.c **** 				vTaskSuspendAll();
3474:../../Source/tasks.c **** 				{
3475:../../Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3476:../../Source/tasks.c **** 					time can be sampled again, and this time its value can
3477:../../Source/tasks.c **** 					be used. */
3478:../../Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3479:../../Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3480:../../Source/tasks.c **** 
3481:../../Source/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3482:../../Source/tasks.c **** 					if the application does not want
3483:../../Source/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3484:../../Source/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3485:../../Source/tasks.c **** 
3486:../../Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3487:../../Source/tasks.c **** 					{
3488:../../Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3489:../../Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3490:../../Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3491:../../Source/tasks.c **** 					}
3492:../../Source/tasks.c **** 					else
3493:../../Source/tasks.c **** 					{
3494:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3495:../../Source/tasks.c **** 					}
3496:../../Source/tasks.c **** 				}
3497:../../Source/tasks.c **** 				( void ) xTaskResumeAll();
3498:../../Source/tasks.c **** 			}
3499:../../Source/tasks.c **** 			else
3500:../../Source/tasks.c **** 			{
3501:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3502:../../Source/tasks.c **** 			}
3503:../../Source/tasks.c **** 		}
3504:../../Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3505:../../Source/tasks.c **** 	}
3506:../../Source/tasks.c **** }
3507:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3508:../../Source/tasks.c **** 
3509:../../Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3510:../../Source/tasks.c **** 
3511:../../Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3512:../../Source/tasks.c **** 	{
3513:../../Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3514:../../Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3515:../../Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3516:../../Source/tasks.c **** 
3517:../../Source/tasks.c **** 		/* This function must be called from a critical section. */
3518:../../Source/tasks.c **** 
3519:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3520:../../Source/tasks.c **** 		{
3521:../../Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3522:../../Source/tasks.c **** 			eReturn = eAbortSleep;
3523:../../Source/tasks.c **** 		}
3524:../../Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3525:../../Source/tasks.c **** 		{
3526:../../Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3527:../../Source/tasks.c **** 			eReturn = eAbortSleep;
3528:../../Source/tasks.c **** 		}
3529:../../Source/tasks.c **** 		else
3530:../../Source/tasks.c **** 		{
3531:../../Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3532:../../Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3533:../../Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3534:../../Source/tasks.c **** 			interrupts. */
3535:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3536:../../Source/tasks.c **** 			{
3537:../../Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3538:../../Source/tasks.c **** 			}
3539:../../Source/tasks.c **** 			else
3540:../../Source/tasks.c **** 			{
3541:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3542:../../Source/tasks.c **** 			}
3543:../../Source/tasks.c **** 		}
3544:../../Source/tasks.c **** 
3545:../../Source/tasks.c **** 		return eReturn;
3546:../../Source/tasks.c **** 	}
3547:../../Source/tasks.c **** 
3548:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3549:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3550:../../Source/tasks.c **** 
3551:../../Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3552:../../Source/tasks.c **** 
3553:../../Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3554:../../Source/tasks.c **** 	{
3555:../../Source/tasks.c **** 	TCB_t *pxTCB;
3556:../../Source/tasks.c **** 
3557:../../Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3558:../../Source/tasks.c **** 		{
3559:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3560:../../Source/tasks.c **** 			configASSERT( pxTCB != NULL );
3561:../../Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3562:../../Source/tasks.c **** 		}
3563:../../Source/tasks.c **** 	}
3564:../../Source/tasks.c **** 
3565:../../Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3566:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3567:../../Source/tasks.c **** 
3568:../../Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3569:../../Source/tasks.c **** 
3570:../../Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3571:../../Source/tasks.c **** 	{
3572:../../Source/tasks.c **** 	void *pvReturn = NULL;
3573:../../Source/tasks.c **** 	TCB_t *pxTCB;
3574:../../Source/tasks.c **** 
3575:../../Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3576:../../Source/tasks.c **** 		{
3577:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3578:../../Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3579:../../Source/tasks.c **** 		}
3580:../../Source/tasks.c **** 		else
3581:../../Source/tasks.c **** 		{
3582:../../Source/tasks.c **** 			pvReturn = NULL;
3583:../../Source/tasks.c **** 		}
3584:../../Source/tasks.c **** 
3585:../../Source/tasks.c **** 		return pvReturn;
3586:../../Source/tasks.c **** 	}
3587:../../Source/tasks.c **** 
3588:../../Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3589:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3590:../../Source/tasks.c **** 
3591:../../Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3592:../../Source/tasks.c **** 
3593:../../Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3594:../../Source/tasks.c **** 	{
3595:../../Source/tasks.c **** 	TCB_t *pxTCB;
3596:../../Source/tasks.c **** 
3597:../../Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3598:../../Source/tasks.c **** 		the calling task. */
3599:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3600:../../Source/tasks.c **** 
3601:../../Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3602:../../Source/tasks.c **** 	}
3603:../../Source/tasks.c **** 
3604:../../Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3605:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3606:../../Source/tasks.c **** 
3607:../../Source/tasks.c **** static void prvInitialiseTaskLists( void )
3608:../../Source/tasks.c **** {
3609:../../Source/tasks.c **** UBaseType_t uxPriority;
3610:../../Source/tasks.c **** 
3611:../../Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
3612:../../Source/tasks.c **** 	{
3613:../../Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3614:../../Source/tasks.c **** 	}
3615:../../Source/tasks.c **** 
3616:../../Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
3617:../../Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
3618:../../Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
3619:../../Source/tasks.c **** 
3620:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3621:../../Source/tasks.c **** 	{
3622:../../Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3623:../../Source/tasks.c **** 	}
3624:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3625:../../Source/tasks.c **** 
3626:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3627:../../Source/tasks.c **** 	{
3628:../../Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
3629:../../Source/tasks.c **** 	}
3630:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3631:../../Source/tasks.c **** 
3632:../../Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3633:../../Source/tasks.c **** 	using list2. */
3634:../../Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
3635:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
3636:../../Source/tasks.c **** }
3637:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3638:../../Source/tasks.c **** 
3639:../../Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3640:../../Source/tasks.c **** {
3641:../../Source/tasks.c **** 
3642:../../Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3643:../../Source/tasks.c **** 
3644:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3645:../../Source/tasks.c **** 	{
3646:../../Source/tasks.c **** 		TCB_t *pxTCB;
3647:../../Source/tasks.c **** 
3648:../../Source/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3649:../../Source/tasks.c **** 		being called too often in the idle task. */
3650:../../Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3651:../../Source/tasks.c **** 		{
3652:../../Source/tasks.c **** 			taskENTER_CRITICAL();
3653:../../Source/tasks.c **** 			{
3654:../../Source/tasks.c **** 				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is u
3655:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3656:../../Source/tasks.c **** 				--uxCurrentNumberOfTasks;
3657:../../Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
3658:../../Source/tasks.c **** 			}
3659:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
3660:../../Source/tasks.c **** 
3661:../../Source/tasks.c **** 			prvDeleteTCB( pxTCB );
3662:../../Source/tasks.c **** 		}
3663:../../Source/tasks.c **** 	}
3664:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3665:../../Source/tasks.c **** }
3666:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3667:../../Source/tasks.c **** 
3668:../../Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3669:../../Source/tasks.c **** 
3670:../../Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3671:../../Source/tasks.c **** 	{
3672:../../Source/tasks.c **** 	TCB_t *pxTCB;
3673:../../Source/tasks.c **** 
3674:../../Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3675:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3676:../../Source/tasks.c **** 
3677:../../Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3678:../../Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3679:../../Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3680:../../Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3681:../../Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3682:../../Source/tasks.c **** 
3683:../../Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3684:../../Source/tasks.c **** 		{
3685:../../Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3686:../../Source/tasks.c **** 		}
3687:../../Source/tasks.c **** 		#else
3688:../../Source/tasks.c **** 		{
3689:../../Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3690:../../Source/tasks.c **** 		}
3691:../../Source/tasks.c **** 		#endif
3692:../../Source/tasks.c **** 
3693:../../Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3694:../../Source/tasks.c **** 		{
3695:../../Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3696:../../Source/tasks.c **** 		}
3697:../../Source/tasks.c **** 		#else
3698:../../Source/tasks.c **** 		{
3699:../../Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3700:../../Source/tasks.c **** 		}
3701:../../Source/tasks.c **** 		#endif
3702:../../Source/tasks.c **** 
3703:../../Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3704:../../Source/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3705:../../Source/tasks.c **** 		state is just set to whatever is passed in. */
3706:../../Source/tasks.c **** 		if( eState != eInvalid )
3707:../../Source/tasks.c **** 		{
3708:../../Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3709:../../Source/tasks.c **** 			{
3710:../../Source/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3711:../../Source/tasks.c **** 			}
3712:../../Source/tasks.c **** 			else
3713:../../Source/tasks.c **** 			{
3714:../../Source/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3715:../../Source/tasks.c **** 
3716:../../Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3717:../../Source/tasks.c **** 				{
3718:../../Source/tasks.c **** 					/* If the task is in the suspended list then there is a
3719:../../Source/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3720:../../Source/tasks.c **** 					it should be reported as being in the Blocked state. */
3721:../../Source/tasks.c **** 					if( eState == eSuspended )
3722:../../Source/tasks.c **** 					{
3723:../../Source/tasks.c **** 						vTaskSuspendAll();
3724:../../Source/tasks.c **** 						{
3725:../../Source/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3726:../../Source/tasks.c **** 							{
3727:../../Source/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3728:../../Source/tasks.c **** 							}
3729:../../Source/tasks.c **** 						}
3730:../../Source/tasks.c **** 						( void ) xTaskResumeAll();
3731:../../Source/tasks.c **** 					}
3732:../../Source/tasks.c **** 				}
3733:../../Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3734:../../Source/tasks.c **** 			}
3735:../../Source/tasks.c **** 		}
3736:../../Source/tasks.c **** 		else
3737:../../Source/tasks.c **** 		{
3738:../../Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3739:../../Source/tasks.c **** 		}
3740:../../Source/tasks.c **** 
3741:../../Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3742:../../Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3743:../../Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3744:../../Source/tasks.c **** 		{
3745:../../Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3746:../../Source/tasks.c **** 			{
3747:../../Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3748:../../Source/tasks.c **** 			}
3749:../../Source/tasks.c **** 			#else
3750:../../Source/tasks.c **** 			{
3751:../../Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3752:../../Source/tasks.c **** 			}
3753:../../Source/tasks.c **** 			#endif
3754:../../Source/tasks.c **** 		}
3755:../../Source/tasks.c **** 		else
3756:../../Source/tasks.c **** 		{
3757:../../Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3758:../../Source/tasks.c **** 		}
3759:../../Source/tasks.c **** 	}
3760:../../Source/tasks.c **** 
3761:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3762:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3763:../../Source/tasks.c **** 
3764:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3765:../../Source/tasks.c **** 
3766:../../Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3767:../../Source/tasks.c **** 	{
3768:../../Source/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3769:../../Source/tasks.c **** 	UBaseType_t uxTask = 0;
3770:../../Source/tasks.c **** 
3771:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3772:../../Source/tasks.c **** 		{
3773:../../Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is
3774:../../Source/tasks.c **** 
3775:../../Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3776:../../Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3777:../../Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3778:../../Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3779:../../Source/tasks.c **** 			do
3780:../../Source/tasks.c **** 			{
3781:../../Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
3782:../../Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3783:../../Source/tasks.c **** 				uxTask++;
3784:../../Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3785:../../Source/tasks.c **** 		}
3786:../../Source/tasks.c **** 		else
3787:../../Source/tasks.c **** 		{
3788:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3789:../../Source/tasks.c **** 		}
3790:../../Source/tasks.c **** 
3791:../../Source/tasks.c **** 		return uxTask;
3792:../../Source/tasks.c **** 	}
3793:../../Source/tasks.c **** 
3794:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3795:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3796:../../Source/tasks.c **** 
3797:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
3798:../../Source/tasks.c **** 
3799:../../Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3800:../../Source/tasks.c **** 	{
3801:../../Source/tasks.c **** 	uint32_t ulCount = 0U;
3802:../../Source/tasks.c **** 
3803:../../Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3804:../../Source/tasks.c **** 		{
3805:../../Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3806:../../Source/tasks.c **** 			ulCount++;
3807:../../Source/tasks.c **** 		}
3808:../../Source/tasks.c **** 
3809:../../Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3810:../../Source/tasks.c **** 
3811:../../Source/tasks.c **** 		return ( configSTACK_DEPTH_TYPE ) ulCount;
3812:../../Source/tasks.c **** 	}
3813:../../Source/tasks.c **** 
3814:../../Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( 
3815:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3816:../../Source/tasks.c **** 
3817:../../Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
3818:../../Source/tasks.c **** 
3819:../../Source/tasks.c **** 	/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
3820:../../Source/tasks.c **** 	same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
3821:../../Source/tasks.c **** 	user to determine the return type.  It gets around the problem of the value
3822:../../Source/tasks.c **** 	overflowing on 8-bit types without breaking backward compatibility for
3823:../../Source/tasks.c **** 	applications that expect an 8-bit return type. */
3824:../../Source/tasks.c **** 	configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
3825:../../Source/tasks.c **** 	{
3826:../../Source/tasks.c **** 	TCB_t *pxTCB;
3827:../../Source/tasks.c **** 	uint8_t *pucEndOfStack;
3828:../../Source/tasks.c **** 	configSTACK_DEPTH_TYPE uxReturn;
3829:../../Source/tasks.c **** 
3830:../../Source/tasks.c **** 		/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
3831:../../Source/tasks.c **** 		the same except for their return type.  Using configSTACK_DEPTH_TYPE
3832:../../Source/tasks.c **** 		allows the user to determine the return type.  It gets around the
3833:../../Source/tasks.c **** 		problem of the value overflowing on 8-bit types without breaking
3834:../../Source/tasks.c **** 		backward compatibility for applications that expect an 8-bit return
3835:../../Source/tasks.c **** 		type. */
3836:../../Source/tasks.c **** 
3837:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3838:../../Source/tasks.c **** 
3839:../../Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3840:../../Source/tasks.c **** 		{
3841:../../Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3842:../../Source/tasks.c **** 		}
3843:../../Source/tasks.c **** 		#else
3844:../../Source/tasks.c **** 		{
3845:../../Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3846:../../Source/tasks.c **** 		}
3847:../../Source/tasks.c **** 		#endif
3848:../../Source/tasks.c **** 
3849:../../Source/tasks.c **** 		uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
3850:../../Source/tasks.c **** 
3851:../../Source/tasks.c **** 		return uxReturn;
3852:../../Source/tasks.c **** 	}
3853:../../Source/tasks.c **** 
3854:../../Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
3855:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3856:../../Source/tasks.c **** 
3857:../../Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3858:../../Source/tasks.c **** 
3859:../../Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3860:../../Source/tasks.c **** 	{
3861:../../Source/tasks.c **** 	TCB_t *pxTCB;
3862:../../Source/tasks.c **** 	uint8_t *pucEndOfStack;
3863:../../Source/tasks.c **** 	UBaseType_t uxReturn;
3864:../../Source/tasks.c **** 
3865:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3866:../../Source/tasks.c **** 
3867:../../Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3868:../../Source/tasks.c **** 		{
3869:../../Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3870:../../Source/tasks.c **** 		}
3871:../../Source/tasks.c **** 		#else
3872:../../Source/tasks.c **** 		{
3873:../../Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3874:../../Source/tasks.c **** 		}
3875:../../Source/tasks.c **** 		#endif
3876:../../Source/tasks.c **** 
3877:../../Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3878:../../Source/tasks.c **** 
3879:../../Source/tasks.c **** 		return uxReturn;
3880:../../Source/tasks.c **** 	}
3881:../../Source/tasks.c **** 
3882:../../Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3883:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3884:../../Source/tasks.c **** 
3885:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3886:../../Source/tasks.c **** 
3887:../../Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3888:../../Source/tasks.c **** 	{
3889:../../Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3890:../../Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3891:../../Source/tasks.c **** 		want to allocate and clean RAM statically. */
3892:../../Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3893:../../Source/tasks.c **** 
3894:../../Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3895:../../Source/tasks.c **** 		to the task to free any memory allocated at the application level.
3896:../../Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3897:../../Source/tasks.c **** 		for additional information. */
3898:../../Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3899:../../Source/tasks.c **** 		{
3900:../../Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3901:../../Source/tasks.c **** 		}
3902:../../Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3903:../../Source/tasks.c **** 
3904:../../Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3905:../../Source/tasks.c **** 		{
3906:../../Source/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3907:../../Source/tasks.c **** 			the stack and TCB. */
3908:../../Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
3909:../../Source/tasks.c **** 			vPortFree( pxTCB );
3910:../../Source/tasks.c **** 		}
3911:../../Source/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consol
3912:../../Source/tasks.c **** 		{
3913:../../Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3914:../../Source/tasks.c **** 			check what was statically allocated before trying to free the
3915:../../Source/tasks.c **** 			memory. */
3916:../../Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3917:../../Source/tasks.c **** 			{
3918:../../Source/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3919:../../Source/tasks.c **** 				must be freed. */
3920:../../Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3921:../../Source/tasks.c **** 				vPortFree( pxTCB );
3922:../../Source/tasks.c **** 			}
3923:../../Source/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3924:../../Source/tasks.c **** 			{
3925:../../Source/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3926:../../Source/tasks.c **** 				only memory that must be freed. */
3927:../../Source/tasks.c **** 				vPortFree( pxTCB );
3928:../../Source/tasks.c **** 			}
3929:../../Source/tasks.c **** 			else
3930:../../Source/tasks.c **** 			{
3931:../../Source/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3932:../../Source/tasks.c **** 				nothing needs to be freed. */
3933:../../Source/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3934:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3935:../../Source/tasks.c **** 			}
3936:../../Source/tasks.c **** 		}
3937:../../Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3938:../../Source/tasks.c **** 	}
3939:../../Source/tasks.c **** 
3940:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3941:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3942:../../Source/tasks.c **** 
3943:../../Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3944:../../Source/tasks.c **** {
 194               	.LM0:
 195               	.LFBB1:
 196               	/* prologue: function */
 197               	/* frame size = 0 */
 198               	/* stack size = 0 */
 199               	.L__stack_usage = 0
3945:../../Source/tasks.c **** TCB_t *pxTCB;
3946:../../Source/tasks.c **** 
3947:../../Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 201               	.LM1:
 202 0000 E091 0000 		lds r30,pxDelayedTaskList
 203 0004 F091 0000 		lds r31,pxDelayedTaskList+1
 204 0008 8081      		ld r24,Z
 205 000a 8111      		cpse r24,__zero_reg__
 206 000c 00C0      		rjmp .L2
3948:../../Source/tasks.c **** 	{
3949:../../Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3950:../../Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3951:../../Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3952:../../Source/tasks.c **** 		there is an item in the delayed list. */
3953:../../Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 208               	.LM2:
 209 000e 8FEF      		ldi r24,lo8(-1)
 210 0010 9FEF      		ldi r25,lo8(-1)
 211 0012 00C0      		rjmp .L4
 212               	.L2:
 213               	.LBB6:
 214               	.LBB7:
3954:../../Source/tasks.c **** 	}
3955:../../Source/tasks.c **** 	else
3956:../../Source/tasks.c **** 	{
3957:../../Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3958:../../Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3959:../../Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3960:../../Source/tasks.c **** 		from the Blocked state. */
3961:../../Source/tasks.c **** 		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as thi
 216               	.LM3:
 217 0014 E091 0000 		lds r30,pxDelayedTaskList
 218 0018 F091 0000 		lds r31,pxDelayedTaskList+1
 219 001c 0580      		ldd __tmp_reg__,Z+5
 220 001e F681      		ldd r31,Z+6
 221 0020 E02D      		mov r30,__tmp_reg__
3962:../../Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 223               	.LM4:
 224 0022 0680      		ldd __tmp_reg__,Z+6
 225 0024 F781      		ldd r31,Z+7
 226 0026 E02D      		mov r30,__tmp_reg__
 227 0028 8281      		ldd r24,Z+2
 228 002a 9381      		ldd r25,Z+3
 229               	.L4:
 230 002c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 231 0030 8093 0000 		sts xNextTaskUnblockTime,r24
 232 0034 0895      		ret
 233               	.LBE7:
 234               	.LBE6:
 236               	.Lscope1:
 238               		.stabd	78,0,0
 242               	prvAddCurrentTaskToDelayedList.isra.2:
 243               		.stabd	46,0,0
3963:../../Source/tasks.c **** 	}
3964:../../Source/tasks.c **** }
3965:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3966:../../Source/tasks.c **** 
3967:../../Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3968:../../Source/tasks.c **** 
3969:../../Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3970:../../Source/tasks.c **** 	{
3971:../../Source/tasks.c **** 	TaskHandle_t xReturn;
3972:../../Source/tasks.c **** 
3973:../../Source/tasks.c **** 		/* A critical section is not required as this is not called from
3974:../../Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3975:../../Source/tasks.c **** 		individual execution thread. */
3976:../../Source/tasks.c **** 		xReturn = pxCurrentTCB;
3977:../../Source/tasks.c **** 
3978:../../Source/tasks.c **** 		return xReturn;
3979:../../Source/tasks.c **** 	}
3980:../../Source/tasks.c **** 
3981:../../Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3982:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3983:../../Source/tasks.c **** 
3984:../../Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3985:../../Source/tasks.c **** 
3986:../../Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3987:../../Source/tasks.c **** 	{
3988:../../Source/tasks.c **** 	BaseType_t xReturn;
3989:../../Source/tasks.c **** 
3990:../../Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3991:../../Source/tasks.c **** 		{
3992:../../Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3993:../../Source/tasks.c **** 		}
3994:../../Source/tasks.c **** 		else
3995:../../Source/tasks.c **** 		{
3996:../../Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3997:../../Source/tasks.c **** 			{
3998:../../Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3999:../../Source/tasks.c **** 			}
4000:../../Source/tasks.c **** 			else
4001:../../Source/tasks.c **** 			{
4002:../../Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
4003:../../Source/tasks.c **** 			}
4004:../../Source/tasks.c **** 		}
4005:../../Source/tasks.c **** 
4006:../../Source/tasks.c **** 		return xReturn;
4007:../../Source/tasks.c **** 	}
4008:../../Source/tasks.c **** 
4009:../../Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
4010:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4011:../../Source/tasks.c **** 
4012:../../Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4013:../../Source/tasks.c **** 
4014:../../Source/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
4015:../../Source/tasks.c **** 	{
4016:../../Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
4017:../../Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
4018:../../Source/tasks.c **** 
4019:../../Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
4020:../../Source/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
4021:../../Source/tasks.c **** 		needed as interrupts can no longer use mutexes? */
4022:../../Source/tasks.c **** 		if( pxMutexHolder != NULL )
4023:../../Source/tasks.c **** 		{
4024:../../Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
4025:../../Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
4026:../../Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
4027:../../Source/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
4028:../../Source/tasks.c **** 			{
4029:../../Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
4030:../../Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
4031:../../Source/tasks.c **** 				not being used for anything else. */
4032:../../Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
4033:../../Source/tasks.c **** 				{
4034:../../Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
4035:../../Source/tasks.c **** 				}
4036:../../Source/tasks.c **** 				else
4037:../../Source/tasks.c **** 				{
4038:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4039:../../Source/tasks.c **** 				}
4040:../../Source/tasks.c **** 
4041:../../Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
4042:../../Source/tasks.c **** 				to be moved into a new list. */
4043:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
4044:../../Source/tasks.c **** 				{
4045:../../Source/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4046:../../Source/tasks.c **** 					{
4047:../../Source/tasks.c **** 						/* It is known that the task is in its ready list so
4048:../../Source/tasks.c **** 						there is no need to check again and the port level
4049:../../Source/tasks.c **** 						reset macro can be called directly. */
4050:../../Source/tasks.c **** 						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
4051:../../Source/tasks.c **** 					}
4052:../../Source/tasks.c **** 					else
4053:../../Source/tasks.c **** 					{
4054:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4055:../../Source/tasks.c **** 					}
4056:../../Source/tasks.c **** 
4057:../../Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
4058:../../Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
4059:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
4060:../../Source/tasks.c **** 				}
4061:../../Source/tasks.c **** 				else
4062:../../Source/tasks.c **** 				{
4063:../../Source/tasks.c **** 					/* Just inherit the priority. */
4064:../../Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
4065:../../Source/tasks.c **** 				}
4066:../../Source/tasks.c **** 
4067:../../Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
4068:../../Source/tasks.c **** 
4069:../../Source/tasks.c **** 				/* Inheritance occurred. */
4070:../../Source/tasks.c **** 				xReturn = pdTRUE;
4071:../../Source/tasks.c **** 			}
4072:../../Source/tasks.c **** 			else
4073:../../Source/tasks.c **** 			{
4074:../../Source/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
4075:../../Source/tasks.c **** 				{
4076:../../Source/tasks.c **** 					/* The base priority of the mutex holder is lower than the
4077:../../Source/tasks.c **** 					priority of the task attempting to take the mutex, but the
4078:../../Source/tasks.c **** 					current priority of the mutex holder is not lower than the
4079:../../Source/tasks.c **** 					priority of the task attempting to take the mutex.
4080:../../Source/tasks.c **** 					Therefore the mutex holder must have already inherited a
4081:../../Source/tasks.c **** 					priority, but inheritance would have occurred if that had
4082:../../Source/tasks.c **** 					not been the case. */
4083:../../Source/tasks.c **** 					xReturn = pdTRUE;
4084:../../Source/tasks.c **** 				}
4085:../../Source/tasks.c **** 				else
4086:../../Source/tasks.c **** 				{
4087:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4088:../../Source/tasks.c **** 				}
4089:../../Source/tasks.c **** 			}
4090:../../Source/tasks.c **** 		}
4091:../../Source/tasks.c **** 		else
4092:../../Source/tasks.c **** 		{
4093:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4094:../../Source/tasks.c **** 		}
4095:../../Source/tasks.c **** 
4096:../../Source/tasks.c **** 		return xReturn;
4097:../../Source/tasks.c **** 	}
4098:../../Source/tasks.c **** 
4099:../../Source/tasks.c **** #endif /* configUSE_MUTEXES */
4100:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4101:../../Source/tasks.c **** 
4102:../../Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4103:../../Source/tasks.c **** 
4104:../../Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
4105:../../Source/tasks.c **** 	{
4106:../../Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
4107:../../Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
4108:../../Source/tasks.c **** 
4109:../../Source/tasks.c **** 		if( pxMutexHolder != NULL )
4110:../../Source/tasks.c **** 		{
4111:../../Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
4112:../../Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
4113:../../Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
4114:../../Source/tasks.c **** 			be the running state task. */
4115:../../Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
4116:../../Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4117:../../Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
4118:../../Source/tasks.c **** 
4119:../../Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
4120:../../Source/tasks.c **** 			task? */
4121:../../Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
4122:../../Source/tasks.c **** 			{
4123:../../Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
4124:../../Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
4125:../../Source/tasks.c **** 				{
4126:../../Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
4127:../../Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
4128:../../Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
4129:../../Source/tasks.c **** 					holding task then it must be the running state task.  Remove
4130:../../Source/tasks.c **** 					the holding task from the ready/delayed list. */
4131:../../Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4132:../../Source/tasks.c **** 					{
4133:../../Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4134:../../Source/tasks.c **** 					}
4135:../../Source/tasks.c **** 					else
4136:../../Source/tasks.c **** 					{
4137:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4138:../../Source/tasks.c **** 					}
4139:../../Source/tasks.c **** 
4140:../../Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
4141:../../Source/tasks.c **** 					new	ready list. */
4142:../../Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4143:../../Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
4144:../../Source/tasks.c **** 
4145:../../Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
4146:../../Source/tasks.c **** 					any other purpose if this task is running, and it must be
4147:../../Source/tasks.c **** 					running to give back the mutex. */
4148:../../Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
4149:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4150:../../Source/tasks.c **** 
4151:../../Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
4152:../../Source/tasks.c **** 					This is only actually required in the corner case whereby
4153:../../Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
4154:../../Source/tasks.c **** 					in an order different to that in which they were taken.
4155:../../Source/tasks.c **** 					If a context switch did not occur when the first mutex was
4156:../../Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
4157:../../Source/tasks.c **** 					switch should occur when the last mutex is returned whether
4158:../../Source/tasks.c **** 					a task is waiting on it or not. */
4159:../../Source/tasks.c **** 					xReturn = pdTRUE;
4160:../../Source/tasks.c **** 				}
4161:../../Source/tasks.c **** 				else
4162:../../Source/tasks.c **** 				{
4163:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4164:../../Source/tasks.c **** 				}
4165:../../Source/tasks.c **** 			}
4166:../../Source/tasks.c **** 			else
4167:../../Source/tasks.c **** 			{
4168:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4169:../../Source/tasks.c **** 			}
4170:../../Source/tasks.c **** 		}
4171:../../Source/tasks.c **** 		else
4172:../../Source/tasks.c **** 		{
4173:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4174:../../Source/tasks.c **** 		}
4175:../../Source/tasks.c **** 
4176:../../Source/tasks.c **** 		return xReturn;
4177:../../Source/tasks.c **** 	}
4178:../../Source/tasks.c **** 
4179:../../Source/tasks.c **** #endif /* configUSE_MUTEXES */
4180:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4181:../../Source/tasks.c **** 
4182:../../Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4183:../../Source/tasks.c **** 
4184:../../Source/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
4185:../../Source/tasks.c **** 	{
4186:../../Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
4187:../../Source/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4188:../../Source/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4189:../../Source/tasks.c **** 
4190:../../Source/tasks.c **** 		if( pxMutexHolder != NULL )
4191:../../Source/tasks.c **** 		{
4192:../../Source/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
4193:../../Source/tasks.c **** 			one mutex. */
4194:../../Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4195:../../Source/tasks.c **** 
4196:../../Source/tasks.c **** 			/* Determine the priority to which the priority of the task that
4197:../../Source/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
4198:../../Source/tasks.c **** 			holding task's base priority and the priority of the highest
4199:../../Source/tasks.c **** 			priority task that is waiting to obtain the mutex. */
4200:../../Source/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4201:../../Source/tasks.c **** 			{
4202:../../Source/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
4203:../../Source/tasks.c **** 			}
4204:../../Source/tasks.c **** 			else
4205:../../Source/tasks.c **** 			{
4206:../../Source/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
4207:../../Source/tasks.c **** 			}
4208:../../Source/tasks.c **** 
4209:../../Source/tasks.c **** 			/* Does the priority need to change? */
4210:../../Source/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
4211:../../Source/tasks.c **** 			{
4212:../../Source/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
4213:../../Source/tasks.c **** 				simplification in the priority inheritance implementation.  If
4214:../../Source/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
4215:../../Source/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4216:../../Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4217:../../Source/tasks.c **** 				{
4218:../../Source/tasks.c **** 					/* If a task has timed out because it already holds the
4219:../../Source/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4220:../../Source/tasks.c **** 					its own priority. */
4221:../../Source/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4222:../../Source/tasks.c **** 
4223:../../Source/tasks.c **** 					/* Disinherit the priority, remembering the previous
4224:../../Source/tasks.c **** 					priority to facilitate determining the subject task's
4225:../../Source/tasks.c **** 					state. */
4226:../../Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4227:../../Source/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4228:../../Source/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
4229:../../Source/tasks.c **** 
4230:../../Source/tasks.c **** 					/* Only reset the event list item value if the value is not
4231:../../Source/tasks.c **** 					being used for anything else. */
4232:../../Source/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
4233:../../Source/tasks.c **** 					{
4234:../../Source/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
4235:../../Source/tasks.c **** 					}
4236:../../Source/tasks.c **** 					else
4237:../../Source/tasks.c **** 					{
4238:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4239:../../Source/tasks.c **** 					}
4240:../../Source/tasks.c **** 
4241:../../Source/tasks.c **** 					/* If the running task is not the task that holds the mutex
4242:../../Source/tasks.c **** 					then the task that holds the mutex could be in either the
4243:../../Source/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
4244:../../Source/tasks.c **** 					from its current state list if it is in the Ready state as
4245:../../Source/tasks.c **** 					the task's priority is going to change and there is one
4246:../../Source/tasks.c **** 					Ready list per priority. */
4247:../../Source/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
4248:../../Source/tasks.c **** 					{
4249:../../Source/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4250:../../Source/tasks.c **** 						{
4251:../../Source/tasks.c **** 							/* It is known that the task is in its ready list so
4252:../../Source/tasks.c **** 							there is no need to check again and the port level
4253:../../Source/tasks.c **** 							reset macro can be called directly. */
4254:../../Source/tasks.c **** 							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
4255:../../Source/tasks.c **** 						}
4256:../../Source/tasks.c **** 						else
4257:../../Source/tasks.c **** 						{
4258:../../Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4259:../../Source/tasks.c **** 						}
4260:../../Source/tasks.c **** 
4261:../../Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
4262:../../Source/tasks.c **** 					}
4263:../../Source/tasks.c **** 					else
4264:../../Source/tasks.c **** 					{
4265:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4266:../../Source/tasks.c **** 					}
4267:../../Source/tasks.c **** 				}
4268:../../Source/tasks.c **** 				else
4269:../../Source/tasks.c **** 				{
4270:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4271:../../Source/tasks.c **** 				}
4272:../../Source/tasks.c **** 			}
4273:../../Source/tasks.c **** 			else
4274:../../Source/tasks.c **** 			{
4275:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4276:../../Source/tasks.c **** 			}
4277:../../Source/tasks.c **** 		}
4278:../../Source/tasks.c **** 		else
4279:../../Source/tasks.c **** 		{
4280:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4281:../../Source/tasks.c **** 		}
4282:../../Source/tasks.c **** 	}
4283:../../Source/tasks.c **** 
4284:../../Source/tasks.c **** #endif /* configUSE_MUTEXES */
4285:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4286:../../Source/tasks.c **** 
4287:../../Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4288:../../Source/tasks.c **** 
4289:../../Source/tasks.c **** 	void vTaskEnterCritical( void )
4290:../../Source/tasks.c **** 	{
4291:../../Source/tasks.c **** 		portDISABLE_INTERRUPTS();
4292:../../Source/tasks.c **** 
4293:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4294:../../Source/tasks.c **** 		{
4295:../../Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4296:../../Source/tasks.c **** 
4297:../../Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4298:../../Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
4299:../../Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4300:../../Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
4301:../../Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
4302:../../Source/tasks.c **** 			critical section. */
4303:../../Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4304:../../Source/tasks.c **** 			{
4305:../../Source/tasks.c **** 				portASSERT_IF_IN_ISR();
4306:../../Source/tasks.c **** 			}
4307:../../Source/tasks.c **** 		}
4308:../../Source/tasks.c **** 		else
4309:../../Source/tasks.c **** 		{
4310:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4311:../../Source/tasks.c **** 		}
4312:../../Source/tasks.c **** 	}
4313:../../Source/tasks.c **** 
4314:../../Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4315:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4316:../../Source/tasks.c **** 
4317:../../Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4318:../../Source/tasks.c **** 
4319:../../Source/tasks.c **** 	void vTaskExitCritical( void )
4320:../../Source/tasks.c **** 	{
4321:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4322:../../Source/tasks.c **** 		{
4323:../../Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4324:../../Source/tasks.c **** 			{
4325:../../Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4326:../../Source/tasks.c **** 
4327:../../Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4328:../../Source/tasks.c **** 				{
4329:../../Source/tasks.c **** 					portENABLE_INTERRUPTS();
4330:../../Source/tasks.c **** 				}
4331:../../Source/tasks.c **** 				else
4332:../../Source/tasks.c **** 				{
4333:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4334:../../Source/tasks.c **** 				}
4335:../../Source/tasks.c **** 			}
4336:../../Source/tasks.c **** 			else
4337:../../Source/tasks.c **** 			{
4338:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4339:../../Source/tasks.c **** 			}
4340:../../Source/tasks.c **** 		}
4341:../../Source/tasks.c **** 		else
4342:../../Source/tasks.c **** 		{
4343:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4344:../../Source/tasks.c **** 		}
4345:../../Source/tasks.c **** 	}
4346:../../Source/tasks.c **** 
4347:../../Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4348:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4349:../../Source/tasks.c **** 
4350:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4351:../../Source/tasks.c **** 
4352:../../Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4353:../../Source/tasks.c **** 	{
4354:../../Source/tasks.c **** 	size_t x;
4355:../../Source/tasks.c **** 
4356:../../Source/tasks.c **** 		/* Start by copying the entire string. */
4357:../../Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
4358:../../Source/tasks.c **** 
4359:../../Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4360:../../Source/tasks.c **** 		printed out. */
4361:../../Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4362:../../Source/tasks.c **** 		{
4363:../../Source/tasks.c **** 			pcBuffer[ x ] = ' ';
4364:../../Source/tasks.c **** 		}
4365:../../Source/tasks.c **** 
4366:../../Source/tasks.c **** 		/* Terminate. */
4367:../../Source/tasks.c **** 		pcBuffer[ x ] = ( char ) 0x00;
4368:../../Source/tasks.c **** 
4369:../../Source/tasks.c **** 		/* Return the new end of string. */
4370:../../Source/tasks.c **** 		return &( pcBuffer[ x ] );
4371:../../Source/tasks.c **** 	}
4372:../../Source/tasks.c **** 
4373:../../Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4374:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4375:../../Source/tasks.c **** 
4376:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4377:../../Source/tasks.c **** 
4378:../../Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4379:../../Source/tasks.c **** 	{
4380:../../Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4381:../../Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4382:../../Source/tasks.c **** 	char cStatus;
4383:../../Source/tasks.c **** 
4384:../../Source/tasks.c **** 		/*
4385:../../Source/tasks.c **** 		 * PLEASE NOTE:
4386:../../Source/tasks.c **** 		 *
4387:../../Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4388:../../Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4389:../../Source/tasks.c **** 		 * scheduler.
4390:../../Source/tasks.c **** 		 *
4391:../../Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4392:../../Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4393:../../Source/tasks.c **** 		 * displays task names, states and stack usage.
4394:../../Source/tasks.c **** 		 *
4395:../../Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4396:../../Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4397:../../Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4398:../../Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4399:../../Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4400:../../Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4401:../../Source/tasks.c **** 		 * snprintf() implementation!).
4402:../../Source/tasks.c **** 		 *
4403:../../Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4404:../../Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4405:../../Source/tasks.c **** 		 * through a call to vTaskList().
4406:../../Source/tasks.c **** 		 */
4407:../../Source/tasks.c **** 
4408:../../Source/tasks.c **** 
4409:../../Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4410:../../Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4411:../../Source/tasks.c **** 
4412:../../Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4413:../../Source/tasks.c **** 		function is executing. */
4414:../../Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4415:../../Source/tasks.c **** 
4416:../../Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4417:../../Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4418:../../Source/tasks.c **** 		equate to NULL. */
4419:../../Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4420:../../Source/tasks.c **** 
4421:../../Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4422:../../Source/tasks.c **** 		{
4423:../../Source/tasks.c **** 			/* Generate the (binary) data. */
4424:../../Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4425:../../Source/tasks.c **** 
4426:../../Source/tasks.c **** 			/* Create a human readable table from the binary data. */
4427:../../Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4428:../../Source/tasks.c **** 			{
4429:../../Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4430:../../Source/tasks.c **** 				{
4431:../../Source/tasks.c **** 					case eRunning:		cStatus = tskRUNNING_CHAR;
4432:../../Source/tasks.c **** 										break;
4433:../../Source/tasks.c **** 
4434:../../Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4435:../../Source/tasks.c **** 										break;
4436:../../Source/tasks.c **** 
4437:../../Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4438:../../Source/tasks.c **** 										break;
4439:../../Source/tasks.c **** 
4440:../../Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4441:../../Source/tasks.c **** 										break;
4442:../../Source/tasks.c **** 
4443:../../Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4444:../../Source/tasks.c **** 										break;
4445:../../Source/tasks.c **** 
4446:../../Source/tasks.c **** 					case eInvalid:		/* Fall through. */
4447:../../Source/tasks.c **** 					default:			/* Should not get here, but it is included
4448:../../Source/tasks.c **** 										to prevent static checking errors. */
4449:../../Source/tasks.c **** 										cStatus = ( char ) 0x00;
4450:../../Source/tasks.c **** 										break;
4451:../../Source/tasks.c **** 				}
4452:../../Source/tasks.c **** 
4453:../../Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4454:../../Source/tasks.c **** 				can be printed in tabular form more easily. */
4455:../../Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4456:../../Source/tasks.c **** 
4457:../../Source/tasks.c **** 				/* Write the rest of the string. */
4458:../../Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4459:../../Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers 
4460:../../Source/tasks.c **** 			}
4461:../../Source/tasks.c **** 
4462:../../Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4463:../../Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4464:../../Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4465:../../Source/tasks.c **** 		}
4466:../../Source/tasks.c **** 		else
4467:../../Source/tasks.c **** 		{
4468:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4469:../../Source/tasks.c **** 		}
4470:../../Source/tasks.c **** 	}
4471:../../Source/tasks.c **** 
4472:../../Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4473:../../Source/tasks.c **** /*----------------------------------------------------------*/
4474:../../Source/tasks.c **** 
4475:../../Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4476:../../Source/tasks.c **** 
4477:../../Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4478:../../Source/tasks.c **** 	{
4479:../../Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4480:../../Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4481:../../Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4482:../../Source/tasks.c **** 
4483:../../Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4484:../../Source/tasks.c **** 		{
4485:../../Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4486:../../Source/tasks.c **** 		}
4487:../../Source/tasks.c **** 		#endif
4488:../../Source/tasks.c **** 
4489:../../Source/tasks.c **** 		/*
4490:../../Source/tasks.c **** 		 * PLEASE NOTE:
4491:../../Source/tasks.c **** 		 *
4492:../../Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4493:../../Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4494:../../Source/tasks.c **** 		 * scheduler.
4495:../../Source/tasks.c **** 		 *
4496:../../Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4497:../../Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4498:../../Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4499:../../Source/tasks.c **** 		 * in both absolute and percentage terms.
4500:../../Source/tasks.c **** 		 *
4501:../../Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4502:../../Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4503:../../Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4504:../../Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4505:../../Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4506:../../Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4507:../../Source/tasks.c **** 		 * a full snprintf() implementation!).
4508:../../Source/tasks.c **** 		 *
4509:../../Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4510:../../Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4511:../../Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4512:../../Source/tasks.c **** 		 */
4513:../../Source/tasks.c **** 
4514:../../Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4515:../../Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4516:../../Source/tasks.c **** 
4517:../../Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4518:../../Source/tasks.c **** 		function is executing. */
4519:../../Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4520:../../Source/tasks.c **** 
4521:../../Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4522:../../Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4523:../../Source/tasks.c **** 		equate to NULL. */
4524:../../Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4525:../../Source/tasks.c **** 
4526:../../Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4527:../../Source/tasks.c **** 		{
4528:../../Source/tasks.c **** 			/* Generate the (binary) data. */
4529:../../Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4530:../../Source/tasks.c **** 
4531:../../Source/tasks.c **** 			/* For percentage calculations. */
4532:../../Source/tasks.c **** 			ulTotalTime /= 100UL;
4533:../../Source/tasks.c **** 
4534:../../Source/tasks.c **** 			/* Avoid divide by zero errors. */
4535:../../Source/tasks.c **** 			if( ulTotalTime > 0UL )
4536:../../Source/tasks.c **** 			{
4537:../../Source/tasks.c **** 				/* Create a human readable table from the binary data. */
4538:../../Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4539:../../Source/tasks.c **** 				{
4540:../../Source/tasks.c **** 					/* What percentage of the total run time has the task used?
4541:../../Source/tasks.c **** 					This will always be rounded down to the nearest integer.
4542:../../Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4543:../../Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4544:../../Source/tasks.c **** 
4545:../../Source/tasks.c **** 					/* Write the task name to the string, padding with
4546:../../Source/tasks.c **** 					spaces so it can be printed in tabular form more
4547:../../Source/tasks.c **** 					easily. */
4548:../../Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4549:../../Source/tasks.c **** 
4550:../../Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4551:../../Source/tasks.c **** 					{
4552:../../Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4553:../../Source/tasks.c **** 						{
4554:../../Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4555:../../Source/tasks.c **** 						}
4556:../../Source/tasks.c **** 						#else
4557:../../Source/tasks.c **** 						{
4558:../../Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4559:../../Source/tasks.c **** 							printf() library can be used. */
4560:../../Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4561:../../Source/tasks.c **** 						}
4562:../../Source/tasks.c **** 						#endif
4563:../../Source/tasks.c **** 					}
4564:../../Source/tasks.c **** 					else
4565:../../Source/tasks.c **** 					{
4566:../../Source/tasks.c **** 						/* If the percentage is zero here then the task has
4567:../../Source/tasks.c **** 						consumed less than 1% of the total run time. */
4568:../../Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4569:../../Source/tasks.c **** 						{
4570:../../Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4571:../../Source/tasks.c **** 						}
4572:../../Source/tasks.c **** 						#else
4573:../../Source/tasks.c **** 						{
4574:../../Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4575:../../Source/tasks.c **** 							printf() library can be used. */
4576:../../Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4577:../../Source/tasks.c **** 						}
4578:../../Source/tasks.c **** 						#endif
4579:../../Source/tasks.c **** 					}
4580:../../Source/tasks.c **** 
4581:../../Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers
4582:../../Source/tasks.c **** 				}
4583:../../Source/tasks.c **** 			}
4584:../../Source/tasks.c **** 			else
4585:../../Source/tasks.c **** 			{
4586:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4587:../../Source/tasks.c **** 			}
4588:../../Source/tasks.c **** 
4589:../../Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4590:../../Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4591:../../Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4592:../../Source/tasks.c **** 		}
4593:../../Source/tasks.c **** 		else
4594:../../Source/tasks.c **** 		{
4595:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4596:../../Source/tasks.c **** 		}
4597:../../Source/tasks.c **** 	}
4598:../../Source/tasks.c **** 
4599:../../Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4600:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4601:../../Source/tasks.c **** 
4602:../../Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4603:../../Source/tasks.c **** {
4604:../../Source/tasks.c **** TickType_t uxReturn;
4605:../../Source/tasks.c **** 
4606:../../Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4607:../../Source/tasks.c **** 
4608:../../Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4609:../../Source/tasks.c **** 	queues and semaphores. */
4610:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
4611:../../Source/tasks.c **** 
4612:../../Source/tasks.c **** 	return uxReturn;
4613:../../Source/tasks.c **** }
4614:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4615:../../Source/tasks.c **** 
4616:../../Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4617:../../Source/tasks.c **** 
4618:../../Source/tasks.c **** 	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4619:../../Source/tasks.c **** 	{
4620:../../Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4621:../../Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4622:../../Source/tasks.c **** 		if( pxCurrentTCB != NULL )
4623:../../Source/tasks.c **** 		{
4624:../../Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
4625:../../Source/tasks.c **** 		}
4626:../../Source/tasks.c **** 
4627:../../Source/tasks.c **** 		return pxCurrentTCB;
4628:../../Source/tasks.c **** 	}
4629:../../Source/tasks.c **** 
4630:../../Source/tasks.c **** #endif /* configUSE_MUTEXES */
4631:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4632:../../Source/tasks.c **** 
4633:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4634:../../Source/tasks.c **** 
4635:../../Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4636:../../Source/tasks.c **** 	{
4637:../../Source/tasks.c **** 	uint32_t ulReturn;
4638:../../Source/tasks.c **** 
4639:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4640:../../Source/tasks.c **** 		{
4641:../../Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4642:../../Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
4643:../../Source/tasks.c **** 			{
4644:../../Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4645:../../Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4646:../../Source/tasks.c **** 
4647:../../Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4648:../../Source/tasks.c **** 				{
4649:../../Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4650:../../Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4651:../../Source/tasks.c **** 
4652:../../Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4653:../../Source/tasks.c **** 					section (some will yield immediately, others wait until the
4654:../../Source/tasks.c **** 					critical section exits) - but it is not something that
4655:../../Source/tasks.c **** 					application code should ever do. */
4656:../../Source/tasks.c **** 					portYIELD_WITHIN_API();
4657:../../Source/tasks.c **** 				}
4658:../../Source/tasks.c **** 				else
4659:../../Source/tasks.c **** 				{
4660:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4661:../../Source/tasks.c **** 				}
4662:../../Source/tasks.c **** 			}
4663:../../Source/tasks.c **** 			else
4664:../../Source/tasks.c **** 			{
4665:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4666:../../Source/tasks.c **** 			}
4667:../../Source/tasks.c **** 		}
4668:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4669:../../Source/tasks.c **** 
4670:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4671:../../Source/tasks.c **** 		{
4672:../../Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4673:../../Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
4674:../../Source/tasks.c **** 
4675:../../Source/tasks.c **** 			if( ulReturn != 0UL )
4676:../../Source/tasks.c **** 			{
4677:../../Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
4678:../../Source/tasks.c **** 				{
4679:../../Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
4680:../../Source/tasks.c **** 				}
4681:../../Source/tasks.c **** 				else
4682:../../Source/tasks.c **** 				{
4683:../../Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
4684:../../Source/tasks.c **** 				}
4685:../../Source/tasks.c **** 			}
4686:../../Source/tasks.c **** 			else
4687:../../Source/tasks.c **** 			{
4688:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4689:../../Source/tasks.c **** 			}
4690:../../Source/tasks.c **** 
4691:../../Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4692:../../Source/tasks.c **** 		}
4693:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4694:../../Source/tasks.c **** 
4695:../../Source/tasks.c **** 		return ulReturn;
4696:../../Source/tasks.c **** 	}
4697:../../Source/tasks.c **** 
4698:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4699:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4700:../../Source/tasks.c **** 
4701:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4702:../../Source/tasks.c **** 
4703:../../Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4704:../../Source/tasks.c **** 	{
4705:../../Source/tasks.c **** 	BaseType_t xReturn;
4706:../../Source/tasks.c **** 
4707:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4708:../../Source/tasks.c **** 		{
4709:../../Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4710:../../Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4711:../../Source/tasks.c **** 			{
4712:../../Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4713:../../Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4714:../../Source/tasks.c **** 				clear the value to zero. */
4715:../../Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
4716:../../Source/tasks.c **** 
4717:../../Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4718:../../Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4719:../../Source/tasks.c **** 
4720:../../Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4721:../../Source/tasks.c **** 				{
4722:../../Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4723:../../Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4724:../../Source/tasks.c **** 
4725:../../Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4726:../../Source/tasks.c **** 					section (some will yield immediately, others wait until the
4727:../../Source/tasks.c **** 					critical section exits) - but it is not something that
4728:../../Source/tasks.c **** 					application code should ever do. */
4729:../../Source/tasks.c **** 					portYIELD_WITHIN_API();
4730:../../Source/tasks.c **** 				}
4731:../../Source/tasks.c **** 				else
4732:../../Source/tasks.c **** 				{
4733:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4734:../../Source/tasks.c **** 				}
4735:../../Source/tasks.c **** 			}
4736:../../Source/tasks.c **** 			else
4737:../../Source/tasks.c **** 			{
4738:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4739:../../Source/tasks.c **** 			}
4740:../../Source/tasks.c **** 		}
4741:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4742:../../Source/tasks.c **** 
4743:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4744:../../Source/tasks.c **** 		{
4745:../../Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4746:../../Source/tasks.c **** 
4747:../../Source/tasks.c **** 			if( pulNotificationValue != NULL )
4748:../../Source/tasks.c **** 			{
4749:../../Source/tasks.c **** 				/* Output the current notification value, which may or may not
4750:../../Source/tasks.c **** 				have changed. */
4751:../../Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
4752:../../Source/tasks.c **** 			}
4753:../../Source/tasks.c **** 
4754:../../Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4755:../../Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4756:../../Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4757:../../Source/tasks.c **** 			unblocked because of a timeout. */
4758:../../Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4759:../../Source/tasks.c **** 			{
4760:../../Source/tasks.c **** 				/* A notification was not received. */
4761:../../Source/tasks.c **** 				xReturn = pdFALSE;
4762:../../Source/tasks.c **** 			}
4763:../../Source/tasks.c **** 			else
4764:../../Source/tasks.c **** 			{
4765:../../Source/tasks.c **** 				/* A notification was already pending or a notification was
4766:../../Source/tasks.c **** 				received while the task was waiting. */
4767:../../Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
4768:../../Source/tasks.c **** 				xReturn = pdTRUE;
4769:../../Source/tasks.c **** 			}
4770:../../Source/tasks.c **** 
4771:../../Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4772:../../Source/tasks.c **** 		}
4773:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4774:../../Source/tasks.c **** 
4775:../../Source/tasks.c **** 		return xReturn;
4776:../../Source/tasks.c **** 	}
4777:../../Source/tasks.c **** 
4778:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4779:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4780:../../Source/tasks.c **** 
4781:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4782:../../Source/tasks.c **** 
4783:../../Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4784:../../Source/tasks.c **** 	{
4785:../../Source/tasks.c **** 	TCB_t * pxTCB;
4786:../../Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4787:../../Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4788:../../Source/tasks.c **** 
4789:../../Source/tasks.c **** 		configASSERT( xTaskToNotify );
4790:../../Source/tasks.c **** 		pxTCB = xTaskToNotify;
4791:../../Source/tasks.c **** 
4792:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4793:../../Source/tasks.c **** 		{
4794:../../Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4795:../../Source/tasks.c **** 			{
4796:../../Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4797:../../Source/tasks.c **** 			}
4798:../../Source/tasks.c **** 
4799:../../Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4800:../../Source/tasks.c **** 
4801:../../Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4802:../../Source/tasks.c **** 
4803:../../Source/tasks.c **** 			switch( eAction )
4804:../../Source/tasks.c **** 			{
4805:../../Source/tasks.c **** 				case eSetBits	:
4806:../../Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4807:../../Source/tasks.c **** 					break;
4808:../../Source/tasks.c **** 
4809:../../Source/tasks.c **** 				case eIncrement	:
4810:../../Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4811:../../Source/tasks.c **** 					break;
4812:../../Source/tasks.c **** 
4813:../../Source/tasks.c **** 				case eSetValueWithOverwrite	:
4814:../../Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4815:../../Source/tasks.c **** 					break;
4816:../../Source/tasks.c **** 
4817:../../Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4818:../../Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4819:../../Source/tasks.c **** 					{
4820:../../Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4821:../../Source/tasks.c **** 					}
4822:../../Source/tasks.c **** 					else
4823:../../Source/tasks.c **** 					{
4824:../../Source/tasks.c **** 						/* The value could not be written to the task. */
4825:../../Source/tasks.c **** 						xReturn = pdFAIL;
4826:../../Source/tasks.c **** 					}
4827:../../Source/tasks.c **** 					break;
4828:../../Source/tasks.c **** 
4829:../../Source/tasks.c **** 				case eNoAction:
4830:../../Source/tasks.c **** 					/* The task is being notified without its notify value being
4831:../../Source/tasks.c **** 					updated. */
4832:../../Source/tasks.c **** 					break;
4833:../../Source/tasks.c **** 
4834:../../Source/tasks.c **** 				default:
4835:../../Source/tasks.c **** 					/* Should not get here if all enums are handled.
4836:../../Source/tasks.c **** 					Artificially force an assert by testing a value the
4837:../../Source/tasks.c **** 					compiler can't assume is const. */
4838:../../Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4839:../../Source/tasks.c **** 
4840:../../Source/tasks.c **** 					break;
4841:../../Source/tasks.c **** 			}
4842:../../Source/tasks.c **** 
4843:../../Source/tasks.c **** 			traceTASK_NOTIFY();
4844:../../Source/tasks.c **** 
4845:../../Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4846:../../Source/tasks.c **** 			notification then unblock it now. */
4847:../../Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4848:../../Source/tasks.c **** 			{
4849:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4850:../../Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
4851:../../Source/tasks.c **** 
4852:../../Source/tasks.c **** 				/* The task should not have been on an event list. */
4853:../../Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4854:../../Source/tasks.c **** 
4855:../../Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4856:../../Source/tasks.c **** 				{
4857:../../Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4858:../../Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4859:../../Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4860:../../Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4861:../../Source/tasks.c **** 					because it will automatically get reset to a new value when
4862:../../Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4863:../../Source/tasks.c **** 					tickless idling is used it might be more important to enter
4864:../../Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4865:../../Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4866:../../Source/tasks.c **** 					earliest possible time. */
4867:../../Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4868:../../Source/tasks.c **** 				}
4869:../../Source/tasks.c **** 				#endif
4870:../../Source/tasks.c **** 
4871:../../Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4872:../../Source/tasks.c **** 				{
4873:../../Source/tasks.c **** 					/* The notified task has a priority above the currently
4874:../../Source/tasks.c **** 					executing task so a yield is required. */
4875:../../Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4876:../../Source/tasks.c **** 				}
4877:../../Source/tasks.c **** 				else
4878:../../Source/tasks.c **** 				{
4879:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4880:../../Source/tasks.c **** 				}
4881:../../Source/tasks.c **** 			}
4882:../../Source/tasks.c **** 			else
4883:../../Source/tasks.c **** 			{
4884:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4885:../../Source/tasks.c **** 			}
4886:../../Source/tasks.c **** 		}
4887:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4888:../../Source/tasks.c **** 
4889:../../Source/tasks.c **** 		return xReturn;
4890:../../Source/tasks.c **** 	}
4891:../../Source/tasks.c **** 
4892:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4893:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4894:../../Source/tasks.c **** 
4895:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4896:../../Source/tasks.c **** 
4897:../../Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4898:../../Source/tasks.c **** 	{
4899:../../Source/tasks.c **** 	TCB_t * pxTCB;
4900:../../Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4901:../../Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4902:../../Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4903:../../Source/tasks.c **** 
4904:../../Source/tasks.c **** 		configASSERT( xTaskToNotify );
4905:../../Source/tasks.c **** 
4906:../../Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4907:../../Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4908:../../Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4909:../../Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4910:../../Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4911:../../Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4912:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4913:../../Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4914:../../Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4915:../../Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4916:../../Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4917:../../Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4918:../../Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4919:../../Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4920:../../Source/tasks.c **** 		provided on the following link:
4921:../../Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4922:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4923:../../Source/tasks.c **** 
4924:../../Source/tasks.c **** 		pxTCB = xTaskToNotify;
4925:../../Source/tasks.c **** 
4926:../../Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4927:../../Source/tasks.c **** 		{
4928:../../Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4929:../../Source/tasks.c **** 			{
4930:../../Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4931:../../Source/tasks.c **** 			}
4932:../../Source/tasks.c **** 
4933:../../Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4934:../../Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4935:../../Source/tasks.c **** 
4936:../../Source/tasks.c **** 			switch( eAction )
4937:../../Source/tasks.c **** 			{
4938:../../Source/tasks.c **** 				case eSetBits	:
4939:../../Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4940:../../Source/tasks.c **** 					break;
4941:../../Source/tasks.c **** 
4942:../../Source/tasks.c **** 				case eIncrement	:
4943:../../Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4944:../../Source/tasks.c **** 					break;
4945:../../Source/tasks.c **** 
4946:../../Source/tasks.c **** 				case eSetValueWithOverwrite	:
4947:../../Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4948:../../Source/tasks.c **** 					break;
4949:../../Source/tasks.c **** 
4950:../../Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4951:../../Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4952:../../Source/tasks.c **** 					{
4953:../../Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4954:../../Source/tasks.c **** 					}
4955:../../Source/tasks.c **** 					else
4956:../../Source/tasks.c **** 					{
4957:../../Source/tasks.c **** 						/* The value could not be written to the task. */
4958:../../Source/tasks.c **** 						xReturn = pdFAIL;
4959:../../Source/tasks.c **** 					}
4960:../../Source/tasks.c **** 					break;
4961:../../Source/tasks.c **** 
4962:../../Source/tasks.c **** 				case eNoAction :
4963:../../Source/tasks.c **** 					/* The task is being notified without its notify value being
4964:../../Source/tasks.c **** 					updated. */
4965:../../Source/tasks.c **** 					break;
4966:../../Source/tasks.c **** 
4967:../../Source/tasks.c **** 				default:
4968:../../Source/tasks.c **** 					/* Should not get here if all enums are handled.
4969:../../Source/tasks.c **** 					Artificially force an assert by testing a value the
4970:../../Source/tasks.c **** 					compiler can't assume is const. */
4971:../../Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4972:../../Source/tasks.c **** 					break;
4973:../../Source/tasks.c **** 			}
4974:../../Source/tasks.c **** 
4975:../../Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4976:../../Source/tasks.c **** 
4977:../../Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4978:../../Source/tasks.c **** 			notification then unblock it now. */
4979:../../Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4980:../../Source/tasks.c **** 			{
4981:../../Source/tasks.c **** 				/* The task should not have been on an event list. */
4982:../../Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4983:../../Source/tasks.c **** 
4984:../../Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4985:../../Source/tasks.c **** 				{
4986:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4987:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4988:../../Source/tasks.c **** 				}
4989:../../Source/tasks.c **** 				else
4990:../../Source/tasks.c **** 				{
4991:../../Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4992:../../Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4993:../../Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4994:../../Source/tasks.c **** 				}
4995:../../Source/tasks.c **** 
4996:../../Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4997:../../Source/tasks.c **** 				{
4998:../../Source/tasks.c **** 					/* The notified task has a priority above the currently
4999:../../Source/tasks.c **** 					executing task so a yield is required. */
5000:../../Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
5001:../../Source/tasks.c **** 					{
5002:../../Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
5003:../../Source/tasks.c **** 					}
5004:../../Source/tasks.c **** 
5005:../../Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
5006:../../Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter to an ISR
5007:../../Source/tasks.c **** 					safe FreeRTOS function. */
5008:../../Source/tasks.c **** 					xYieldPending = pdTRUE;
5009:../../Source/tasks.c **** 				}
5010:../../Source/tasks.c **** 				else
5011:../../Source/tasks.c **** 				{
5012:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5013:../../Source/tasks.c **** 				}
5014:../../Source/tasks.c **** 			}
5015:../../Source/tasks.c **** 		}
5016:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5017:../../Source/tasks.c **** 
5018:../../Source/tasks.c **** 		return xReturn;
5019:../../Source/tasks.c **** 	}
5020:../../Source/tasks.c **** 
5021:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5022:../../Source/tasks.c **** /*-----------------------------------------------------------*/
5023:../../Source/tasks.c **** 
5024:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5025:../../Source/tasks.c **** 
5026:../../Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
5027:../../Source/tasks.c **** 	{
5028:../../Source/tasks.c **** 	TCB_t * pxTCB;
5029:../../Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
5030:../../Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
5031:../../Source/tasks.c **** 
5032:../../Source/tasks.c **** 		configASSERT( xTaskToNotify );
5033:../../Source/tasks.c **** 
5034:../../Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
5035:../../Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
5036:../../Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
5037:../../Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
5038:../../Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
5039:../../Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
5040:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
5041:../../Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
5042:../../Source/tasks.c **** 		been assigned a priority above the configured maximum system call
5043:../../Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
5044:../../Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
5045:../../Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
5046:../../Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
5047:../../Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
5048:../../Source/tasks.c **** 		provided on the following link:
5049:../../Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
5050:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
5051:../../Source/tasks.c **** 
5052:../../Source/tasks.c **** 		pxTCB = xTaskToNotify;
5053:../../Source/tasks.c **** 
5054:../../Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
5055:../../Source/tasks.c **** 		{
5056:../../Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
5057:../../Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
5058:../../Source/tasks.c **** 
5059:../../Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
5060:../../Source/tasks.c **** 			semaphore. */
5061:../../Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
5062:../../Source/tasks.c **** 
5063:../../Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
5064:../../Source/tasks.c **** 
5065:../../Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
5066:../../Source/tasks.c **** 			notification then unblock it now. */
5067:../../Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
5068:../../Source/tasks.c **** 			{
5069:../../Source/tasks.c **** 				/* The task should not have been on an event list. */
5070:../../Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
5071:../../Source/tasks.c **** 
5072:../../Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
5073:../../Source/tasks.c **** 				{
5074:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
5075:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
5076:../../Source/tasks.c **** 				}
5077:../../Source/tasks.c **** 				else
5078:../../Source/tasks.c **** 				{
5079:../../Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
5080:../../Source/tasks.c **** 					this task pending until the scheduler is resumed. */
5081:../../Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
5082:../../Source/tasks.c **** 				}
5083:../../Source/tasks.c **** 
5084:../../Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
5085:../../Source/tasks.c **** 				{
5086:../../Source/tasks.c **** 					/* The notified task has a priority above the currently
5087:../../Source/tasks.c **** 					executing task so a yield is required. */
5088:../../Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
5089:../../Source/tasks.c **** 					{
5090:../../Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
5091:../../Source/tasks.c **** 					}
5092:../../Source/tasks.c **** 
5093:../../Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
5094:../../Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter in an ISR
5095:../../Source/tasks.c **** 					safe FreeRTOS function. */
5096:../../Source/tasks.c **** 					xYieldPending = pdTRUE;
5097:../../Source/tasks.c **** 				}
5098:../../Source/tasks.c **** 				else
5099:../../Source/tasks.c **** 				{
5100:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5101:../../Source/tasks.c **** 				}
5102:../../Source/tasks.c **** 			}
5103:../../Source/tasks.c **** 		}
5104:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5105:../../Source/tasks.c **** 	}
5106:../../Source/tasks.c **** 
5107:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5108:../../Source/tasks.c **** /*-----------------------------------------------------------*/
5109:../../Source/tasks.c **** 
5110:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5111:../../Source/tasks.c **** 
5112:../../Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
5113:../../Source/tasks.c **** 	{
5114:../../Source/tasks.c **** 	TCB_t *pxTCB;
5115:../../Source/tasks.c **** 	BaseType_t xReturn;
5116:../../Source/tasks.c **** 
5117:../../Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
5118:../../Source/tasks.c **** 		its notification state cleared. */
5119:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
5120:../../Source/tasks.c **** 
5121:../../Source/tasks.c **** 		taskENTER_CRITICAL();
5122:../../Source/tasks.c **** 		{
5123:../../Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
5124:../../Source/tasks.c **** 			{
5125:../../Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
5126:../../Source/tasks.c **** 				xReturn = pdPASS;
5127:../../Source/tasks.c **** 			}
5128:../../Source/tasks.c **** 			else
5129:../../Source/tasks.c **** 			{
5130:../../Source/tasks.c **** 				xReturn = pdFAIL;
5131:../../Source/tasks.c **** 			}
5132:../../Source/tasks.c **** 		}
5133:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
5134:../../Source/tasks.c **** 
5135:../../Source/tasks.c **** 		return xReturn;
5136:../../Source/tasks.c **** 	}
5137:../../Source/tasks.c **** 
5138:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5139:../../Source/tasks.c **** /*-----------------------------------------------------------*/
5140:../../Source/tasks.c **** 
5141:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5142:../../Source/tasks.c **** 
5143:../../Source/tasks.c **** 	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
5144:../../Source/tasks.c **** 	{
5145:../../Source/tasks.c **** 	TCB_t *pxTCB;
5146:../../Source/tasks.c **** 	uint32_t ulReturn;
5147:../../Source/tasks.c **** 
5148:../../Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
5149:../../Source/tasks.c **** 		its notification state cleared. */
5150:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
5151:../../Source/tasks.c **** 
5152:../../Source/tasks.c **** 		taskENTER_CRITICAL();
5153:../../Source/tasks.c **** 		{
5154:../../Source/tasks.c **** 			/* Return the notification as it was before the bits were cleared,
5155:../../Source/tasks.c **** 			then clear the bit mask. */
5156:../../Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
5157:../../Source/tasks.c **** 			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
5158:../../Source/tasks.c **** 		}
5159:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
5160:../../Source/tasks.c **** 
5161:../../Source/tasks.c **** 		return ulReturn;
5162:../../Source/tasks.c **** 	}
5163:../../Source/tasks.c **** 
5164:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5165:../../Source/tasks.c **** /*-----------------------------------------------------------*/
5166:../../Source/tasks.c **** 
5167:../../Source/tasks.c **** #if( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
5168:../../Source/tasks.c **** 
5169:../../Source/tasks.c **** 	uint32_t ulTaskGetIdleRunTimeCounter( void )
5170:../../Source/tasks.c **** 	{
5171:../../Source/tasks.c **** 		return xIdleTaskHandle->ulRunTimeCounter;
5172:../../Source/tasks.c **** 	}
5173:../../Source/tasks.c **** 
5174:../../Source/tasks.c **** #endif
5175:../../Source/tasks.c **** /*-----------------------------------------------------------*/
5176:../../Source/tasks.c **** 
5177:../../Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 245               	.LM5:
 246               	.LFBB2:
 247 0036 0F93      		push r16
 248 0038 1F93      		push r17
 249 003a CF93      		push r28
 250 003c DF93      		push r29
 251               	/* prologue: function */
 252               	/* frame size = 0 */
 253               	/* stack size = 4 */
 254               	.L__stack_usage = 4
 255 003e EC01      		movw r28,r24
5178:../../Source/tasks.c **** {
5179:../../Source/tasks.c **** TickType_t xTimeToWake;
5180:../../Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 257               	.LM6:
 258 0040 0091 0000 		lds r16,xTickCount
 259 0044 1091 0000 		lds r17,xTickCount+1
5181:../../Source/tasks.c **** 
5182:../../Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
5183:../../Source/tasks.c **** 	{
5184:../../Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
5185:../../Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
5186:../../Source/tasks.c **** 		when the task leaves the Blocked state. */
5187:../../Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
5188:../../Source/tasks.c **** 	}
5189:../../Source/tasks.c **** 	#endif
5190:../../Source/tasks.c **** 
5191:../../Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
5192:../../Source/tasks.c **** 	as the same list item is used for both lists. */
5193:../../Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 261               	.LM7:
 262 0048 8091 0000 		lds r24,pxCurrentTCB
 263 004c 9091 0000 		lds r25,pxCurrentTCB+1
 264 0050 0296      		adiw r24,2
 265 0052 0E94 0000 		call uxListRemove
5194:../../Source/tasks.c **** 	{
5195:../../Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
5196:../../Source/tasks.c **** 		check, and the port reset macro can be called directly. */
5197:../../Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentT
5198:../../Source/tasks.c **** 	}
5199:../../Source/tasks.c **** 	else
5200:../../Source/tasks.c **** 	{
5201:../../Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
5202:../../Source/tasks.c **** 	}
5203:../../Source/tasks.c **** 
5204:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
5205:../../Source/tasks.c **** 	{
5206:../../Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
5207:../../Source/tasks.c **** 		{
5208:../../Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
5209:../../Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
5210:../../Source/tasks.c **** 			indefinitely. */
5211:../../Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
5212:../../Source/tasks.c **** 		}
5213:../../Source/tasks.c **** 		else
5214:../../Source/tasks.c **** 		{
5215:../../Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
5216:../../Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
5217:../../Source/tasks.c **** 			kernel will manage it correctly. */
5218:../../Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
5219:../../Source/tasks.c **** 
5220:../../Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
5221:../../Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5222:../../Source/tasks.c **** 
5223:../../Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
5224:../../Source/tasks.c **** 			{
5225:../../Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
5226:../../Source/tasks.c **** 				list. */
5227:../../Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5228:../../Source/tasks.c **** 			}
5229:../../Source/tasks.c **** 			else
5230:../../Source/tasks.c **** 			{
5231:../../Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
5232:../../Source/tasks.c **** 				is used. */
5233:../../Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5234:../../Source/tasks.c **** 
5235:../../Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
5236:../../Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
5237:../../Source/tasks.c **** 				needs to be updated too. */
5238:../../Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
5239:../../Source/tasks.c **** 				{
5240:../../Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
5241:../../Source/tasks.c **** 				}
5242:../../Source/tasks.c **** 				else
5243:../../Source/tasks.c **** 				{
5244:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5245:../../Source/tasks.c **** 				}
5246:../../Source/tasks.c **** 			}
5247:../../Source/tasks.c **** 		}
5248:../../Source/tasks.c **** 	}
5249:../../Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
5250:../../Source/tasks.c **** 	{
5251:../../Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
5252:../../Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
5253:../../Source/tasks.c **** 		will manage it correctly. */
5254:../../Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
 267               	.LM8:
 268 0056 C00F      		add r28,r16
 269 0058 D11F      		adc r29,r17
5255:../../Source/tasks.c **** 
5256:../../Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
5257:../../Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 271               	.LM9:
 272 005a E091 0000 		lds r30,pxCurrentTCB
 273 005e F091 0000 		lds r31,pxCurrentTCB+1
 274 0062 D383      		std Z+3,r29
 275 0064 C283      		std Z+2,r28
 276               	.LBB10:
 277               	.LBB11:
5258:../../Source/tasks.c **** 
5259:../../Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
5260:../../Source/tasks.c **** 		{
5261:../../Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
5262:../../Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 279               	.LM10:
 280 0066 6091 0000 		lds r22,pxCurrentTCB
 281 006a 7091 0000 		lds r23,pxCurrentTCB+1
 282               	.LBE11:
 283               	.LBE10:
5259:../../Source/tasks.c **** 		{
 285               	.LM11:
 286 006e C017      		cp r28,r16
 287 0070 D107      		cpc r29,r17
 288 0072 00F4      		brsh .L7
 289               	.LBB14:
 290               	.LBB12:
 292               	.LM12:
 293 0074 8091 0000 		lds r24,pxOverflowDelayedTaskList
 294 0078 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 295 007c 6E5F      		subi r22,-2
 296 007e 7F4F      		sbci r23,-1
 297               	/* epilogue start */
 298               	.LBE12:
 299               	.LBE14:
5263:../../Source/tasks.c **** 		}
5264:../../Source/tasks.c **** 		else
5265:../../Source/tasks.c **** 		{
5266:../../Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
5267:../../Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5268:../../Source/tasks.c **** 
5269:../../Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
5270:../../Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
5271:../../Source/tasks.c **** 			too. */
5272:../../Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
5273:../../Source/tasks.c **** 			{
5274:../../Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
5275:../../Source/tasks.c **** 			}
5276:../../Source/tasks.c **** 			else
5277:../../Source/tasks.c **** 			{
5278:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
5279:../../Source/tasks.c **** 			}
5280:../../Source/tasks.c **** 		}
5281:../../Source/tasks.c **** 
5282:../../Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5283:../../Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
5284:../../Source/tasks.c **** 	}
5285:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
5286:../../Source/tasks.c **** }
 301               	.LM13:
 302 0080 DF91      		pop r29
 303 0082 CF91      		pop r28
 304 0084 1F91      		pop r17
 305 0086 0F91      		pop r16
 306               	.LBB15:
 307               	.LBB13:
5262:../../Source/tasks.c **** 		}
 309               	.LM14:
 310 0088 0C94 0000 		jmp vListInsert
 311               	.L7:
 312               	.LBE13:
 313               	.LBE15:
5267:../../Source/tasks.c **** 
 315               	.LM15:
 316 008c 8091 0000 		lds r24,pxDelayedTaskList
 317 0090 9091 0000 		lds r25,pxDelayedTaskList+1
 318 0094 6E5F      		subi r22,-2
 319 0096 7F4F      		sbci r23,-1
 320 0098 0E94 0000 		call vListInsert
5272:../../Source/tasks.c **** 			{
 322               	.LM16:
 323 009c 8091 0000 		lds r24,xNextTaskUnblockTime
 324 00a0 9091 0000 		lds r25,xNextTaskUnblockTime+1
 325 00a4 C817      		cp r28,r24
 326 00a6 D907      		cpc r29,r25
 327 00a8 00F4      		brsh .L6
5274:../../Source/tasks.c **** 			}
 329               	.LM17:
 330 00aa D093 0000 		sts xNextTaskUnblockTime+1,r29
 331 00ae C093 0000 		sts xNextTaskUnblockTime,r28
 332               	.L6:
 333               	/* epilogue start */
 335               	.LM18:
 336 00b2 DF91      		pop r29
 337 00b4 CF91      		pop r28
 338 00b6 1F91      		pop r17
 339 00b8 0F91      		pop r16
 340 00ba 0895      		ret
 346               	.Lscope2:
 348               		.stabd	78,0,0
 352               	prvIdleTask:
 353               		.stabd	46,0,0
3393:../../Source/tasks.c **** 	/* Stop warnings. */
 355               	.LM19:
 356               	.LFBB3:
 357               	/* prologue: function */
 358               	/* frame size = 0 */
 359               	/* stack size = 0 */
 360               	.L__stack_usage = 0
 361               	.L10:
 362               	.LBB22:
 363               	.LBB23:
3650:../../Source/tasks.c **** 		{
 365               	.LM20:
 366 00bc 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 367 00c0 8823      		tst r24
 368 00c2 01F0      		breq .L14
3652:../../Source/tasks.c **** 			{
 370               	.LM21:
 371               	/* #APP */
 372               	 ;  3652 "../../Source/tasks.c" 1
 373 00c4 0FB6      		in		__tmp_reg__, __SREG__
 374               	 ;  0 "" 2
 375               	 ;  3652 "../../Source/tasks.c" 1
 376 00c6 F894      		cli
 377               	 ;  0 "" 2
 378               	 ;  3652 "../../Source/tasks.c" 1
 379 00c8 0F92      		push	__tmp_reg__
 380               	 ;  0 "" 2
3654:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 382               	.LM22:
 383               	/* #NOAPP */
 384 00ca E091 0000 		lds r30,xTasksWaitingTermination+5
 385 00ce F091 0000 		lds r31,xTasksWaitingTermination+5+1
 386 00d2 C681      		ldd r28,Z+6
 387 00d4 D781      		ldd r29,Z+7
3655:../../Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 389               	.LM23:
 390 00d6 CE01      		movw r24,r28
 391 00d8 0296      		adiw r24,2
 392 00da 0E94 0000 		call uxListRemove
3656:../../Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 394               	.LM24:
 395 00de 8091 0000 		lds r24,uxCurrentNumberOfTasks
 396 00e2 8150      		subi r24,lo8(-(-1))
 397 00e4 8093 0000 		sts uxCurrentNumberOfTasks,r24
3657:../../Source/tasks.c **** 			}
 399               	.LM25:
 400 00e8 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 401 00ec 8150      		subi r24,lo8(-(-1))
 402 00ee 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
3659:../../Source/tasks.c **** 
 404               	.LM26:
 405               	/* #APP */
 406               	 ;  3659 "../../Source/tasks.c" 1
 407 00f2 0F90      		pop		__tmp_reg__
 408               	 ;  0 "" 2
 409               	 ;  3659 "../../Source/tasks.c" 1
 410 00f4 0FBE      		out		__SREG__, __tmp_reg__
 411               	 ;  0 "" 2
 412               	/* #NOAPP */
 413               	.LBB24:
 414               	.LBB25:
3908:../../Source/tasks.c **** 			vPortFree( pxTCB );
 416               	.LM27:
 417 00f6 8F89      		ldd r24,Y+23
 418 00f8 988D      		ldd r25,Y+24
 419 00fa 0E94 0000 		call vPortFree
3909:../../Source/tasks.c **** 		}
 421               	.LM28:
 422 00fe CE01      		movw r24,r28
 423 0100 0E94 0000 		call vPortFree
 424 0104 00C0      		rjmp .L10
 425               	.L14:
 426               	.LBE25:
 427               	.LBE24:
 428               	.LBE23:
 429               	.LBE22:
3432:../../Source/tasks.c **** 			{
 431               	.LM29:
 432 0106 8091 0000 		lds r24,pxReadyTasksLists
 433 010a 8230      		cpi r24,lo8(2)
 434 010c 00F0      		brlo .L12
3434:../../Source/tasks.c **** 			}
 436               	.LM30:
 437 010e 0E94 0000 		call vPortYield
 438               	.L12:
 439               	.LBB26:
3452:../../Source/tasks.c **** 		}
 441               	.LM31:
 442 0112 0E94 0000 		call vApplicationIdleHook
 443               	.LBE26:
3505:../../Source/tasks.c **** }
 445               	.LM32:
 446 0116 00C0      		rjmp .L10
 451               	.Lscope3:
 453               		.stabd	78,0,0
 461               	.global	xTaskCreate
 463               	xTaskCreate:
 464               		.stabd	46,0,0
 739:../../Source/tasks.c **** 	TCB_t *pxNewTCB;
 466               	.LM33:
 467               	.LFBB4:
 468 0118 4F92      		push r4
 469 011a 5F92      		push r5
 470 011c 6F92      		push r6
 471 011e 7F92      		push r7
 472 0120 8F92      		push r8
 473 0122 9F92      		push r9
 474 0124 AF92      		push r10
 475 0126 BF92      		push r11
 476 0128 CF92      		push r12
 477 012a DF92      		push r13
 478 012c EF92      		push r14
 479 012e FF92      		push r15
 480 0130 0F93      		push r16
 481 0132 CF93      		push r28
 482 0134 DF93      		push r29
 483               	/* prologue: function */
 484               	/* frame size = 0 */
 485               	/* stack size = 15 */
 486               	.L__stack_usage = 15
 487 0136 4C01      		movw r8,r24
 488 0138 6B01      		movw r12,r22
 489 013a 5A01      		movw r10,r20
 490 013c 2901      		movw r4,r18
 491               	.LBB34:
 773:../../Source/tasks.c **** 
 493               	.LM34:
 494 013e CA01      		movw r24,r20
 495 0140 0E94 0000 		call pvPortMalloc
 496 0144 3C01      		movw r6,r24
 775:../../Source/tasks.c **** 			{
 498               	.LM35:
 499 0146 892B      		or r24,r25
 500 0148 01F4      		brne .+2
 501 014a 00C0      		rjmp .L16
 778:../../Source/tasks.c **** 
 503               	.LM36:
 504 014c 86E2      		ldi r24,lo8(38)
 505 014e 90E0      		ldi r25,0
 506 0150 0E94 0000 		call pvPortMalloc
 507 0154 EC01      		movw r28,r24
 780:../../Source/tasks.c **** 				{
 509               	.LM37:
 510 0156 0097      		sbiw r24,0
 511 0158 01F0      		breq .L17
 783:../../Source/tasks.c **** 				}
 513               	.LM38:
 514 015a 788E      		std Y+24,r7
 515 015c 6F8A      		std Y+23,r6
 516               	.LBE34:
 517               	.LBB35:
 518               	.LBB36:
 864:../../Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 520               	.LM39:
 521 015e 21E0      		ldi r18,1
 522 0160 A21A      		sub r10,r18
 523 0162 B108      		sbc r11,__zero_reg__
 524 0164 A60C      		add r10,r6
 525 0166 B71C      		adc r11,r7
 892:../../Source/tasks.c **** 	{
 527               	.LM40:
 528 0168 C114      		cp r12,__zero_reg__
 529 016a D104      		cpc r13,__zero_reg__
 530 016c 01F0      		breq .L45
 531 016e BC01      		movw r22,r24
 532 0170 675E      		subi r22,-25
 533 0172 7F4F      		sbci r23,-1
 534 0174 F601      		movw r30,r12
 535 0176 C601      		movw r24,r12
 536 0178 0896      		adiw r24,8
 537 017a 00C0      		rjmp .L21
 538               	.L17:
 539               	.LBE36:
 540               	.LBE35:
 541               	.LBB38:
 789:../../Source/tasks.c **** 				}
 543               	.LM41:
 544 017c C301      		movw r24,r6
 545 017e 0E94 0000 		call vPortFree
 546 0182 00C0      		rjmp .L16
 547               	.L46:
 548               	.LBE38:
 549               	.LBB39:
 550               	.LBB37:
 894:../../Source/tasks.c **** 		{
 552               	.LM42:
 553 0184 E817      		cp r30,r24
 554 0186 F907      		cpc r31,r25
 555 0188 01F0      		breq .L20
 556               	.L21:
 557 018a 9F01      		movw r18,r30
 896:../../Source/tasks.c **** 
 559               	.LM43:
 560 018c 4191      		ld r20,Z+
 561 018e DB01      		movw r26,r22
 562 0190 4D93      		st X+,r20
 563 0192 BD01      		movw r22,r26
 901:../../Source/tasks.c **** 			{
 565               	.LM44:
 566 0194 D901      		movw r26,r18
 567 0196 2C91      		ld r18,X
 568 0198 2111      		cpse r18,__zero_reg__
 569 019a 00C0      		rjmp .L46
 570               	.L20:
 913:../../Source/tasks.c **** 	}
 572               	.LM45:
 573 019c 18A2      		std Y+32,__zero_reg__
 574 019e 00C0      		rjmp .L22
 575               	.L45:
 919:../../Source/tasks.c **** 	}
 577               	.LM46:
 578 01a0 198E      		std Y+25,__zero_reg__
 579               	.L22:
 580 01a2 0430      		cpi r16,lo8(4)
 581 01a4 00F0      		brlo .L23
 582 01a6 03E0      		ldi r16,lo8(3)
 583               	.L23:
 933:../../Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 585               	.LM47:
 586 01a8 0E8B      		std Y+22,r16
 941:../../Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 588               	.LM48:
 589 01aa 6E01      		movw r12,r28
 590 01ac B2E0      		ldi r27,2
 591 01ae CB0E      		add r12,r27
 592 01b0 D11C      		adc r13,__zero_reg__
 593 01b2 C601      		movw r24,r12
 594 01b4 0E94 0000 		call vListInitialiseItem
 942:../../Source/tasks.c **** 
 596               	.LM49:
 597 01b8 CE01      		movw r24,r28
 598 01ba 0C96      		adiw r24,12
 599 01bc 0E94 0000 		call vListInitialiseItem
 946:../../Source/tasks.c **** 
 601               	.LM50:
 602 01c0 D987      		std Y+9,r29
 603 01c2 C887      		std Y+8,r28
 949:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 605               	.LM51:
 606 01c4 84E0      		ldi r24,lo8(4)
 607 01c6 90E0      		ldi r25,0
 608 01c8 801B      		sub r24,r16
 609 01ca 9109      		sbc r25,__zero_reg__
 610 01cc 9D87      		std Y+13,r25
 611 01ce 8C87      		std Y+12,r24
 950:../../Source/tasks.c **** 
 613               	.LM52:
 614 01d0 DB8B      		std Y+19,r29
 615 01d2 CA8B      		std Y+18,r28
 992:../../Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 617               	.LM53:
 618 01d4 19A2      		std Y+33,__zero_reg__
 619 01d6 1AA2      		std Y+34,__zero_reg__
 620 01d8 1BA2      		std Y+35,__zero_reg__
 621 01da 1CA2      		std Y+36,__zero_reg__
 993:../../Source/tasks.c **** 	}
 623               	.LM54:
 624 01dc 1DA2      		std Y+37,__zero_reg__
1058:../../Source/tasks.c **** 		}
 626               	.LM55:
 627 01de A201      		movw r20,r4
 628 01e0 B401      		movw r22,r8
 629 01e2 C501      		movw r24,r10
 630 01e4 0E94 0000 		call pxPortInitialiseStack
 631 01e8 9983      		std Y+1,r25
 632 01ea 8883      		st Y,r24
1064:../../Source/tasks.c **** 	{
 634               	.LM56:
 635 01ec E114      		cp r14,__zero_reg__
 636 01ee F104      		cpc r15,__zero_reg__
 637 01f0 01F0      		breq .L24
1068:../../Source/tasks.c **** 	}
 639               	.LM57:
 640 01f2 F701      		movw r30,r14
 641 01f4 D183      		std Z+1,r29
 642 01f6 C083      		st Z,r28
 643               	.L24:
 644               	.LBE37:
 645               	.LBE39:
 646               	.LBB40:
 647               	.LBB41:
1081:../../Source/tasks.c **** 	{
 649               	.LM58:
 650               	/* #APP */
 651               	 ;  1081 "../../Source/tasks.c" 1
 652 01f8 0FB6      		in		__tmp_reg__, __SREG__
 653               	 ;  0 "" 2
 654               	 ;  1081 "../../Source/tasks.c" 1
 655 01fa F894      		cli
 656               	 ;  0 "" 2
 657               	 ;  1081 "../../Source/tasks.c" 1
 658 01fc 0F92      		push	__tmp_reg__
 659               	 ;  0 "" 2
1083:../../Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 661               	.LM59:
 662               	/* #NOAPP */
 663 01fe 8091 0000 		lds r24,uxCurrentNumberOfTasks
 664 0202 8F5F      		subi r24,lo8(-(1))
 665 0204 8093 0000 		sts uxCurrentNumberOfTasks,r24
1084:../../Source/tasks.c **** 		{
 667               	.LM60:
 668 0208 8091 0000 		lds r24,pxCurrentTCB
 669 020c 9091 0000 		lds r25,pxCurrentTCB+1
 670 0210 892B      		or r24,r25
 671 0212 01F4      		brne .L25
1088:../../Source/tasks.c **** 
 673               	.LM61:
 674 0214 D093 0000 		sts pxCurrentTCB+1,r29
 675 0218 C093 0000 		sts pxCurrentTCB,r28
1090:../../Source/tasks.c **** 			{
 677               	.LM62:
 678 021c 8091 0000 		lds r24,uxCurrentNumberOfTasks
 679 0220 8130      		cpi r24,lo8(1)
 680 0222 01F4      		brne .L27
 681               	.LBB42:
 682               	.LBB43:
3613:../../Source/tasks.c **** 	}
 684               	.LM63:
 685 0224 80E0      		ldi r24,lo8(pxReadyTasksLists)
 686 0226 90E0      		ldi r25,hi8(pxReadyTasksLists)
 687 0228 0E94 0000 		call vListInitialise
 688 022c 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 689 022e 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 690 0230 0E94 0000 		call vListInitialise
 691 0234 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 692 0236 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 693 0238 0E94 0000 		call vListInitialise
 694 023c 80E0      		ldi r24,lo8(pxReadyTasksLists+27)
 695 023e 90E0      		ldi r25,hi8(pxReadyTasksLists+27)
 696 0240 0E94 0000 		call vListInitialise
3616:../../Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 698               	.LM64:
 699 0244 80E0      		ldi r24,lo8(xDelayedTaskList1)
 700 0246 90E0      		ldi r25,hi8(xDelayedTaskList1)
 701 0248 0E94 0000 		call vListInitialise
3617:../../Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 703               	.LM65:
 704 024c 80E0      		ldi r24,lo8(xDelayedTaskList2)
 705 024e 90E0      		ldi r25,hi8(xDelayedTaskList2)
 706 0250 0E94 0000 		call vListInitialise
3618:../../Source/tasks.c **** 
 708               	.LM66:
 709 0254 80E0      		ldi r24,lo8(xPendingReadyList)
 710 0256 90E0      		ldi r25,hi8(xPendingReadyList)
 711 0258 0E94 0000 		call vListInitialise
3622:../../Source/tasks.c **** 	}
 713               	.LM67:
 714 025c 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 715 025e 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 716 0260 0E94 0000 		call vListInitialise
3634:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 718               	.LM68:
 719 0264 80E0      		ldi r24,lo8(xDelayedTaskList1)
 720 0266 90E0      		ldi r25,hi8(xDelayedTaskList1)
 721 0268 9093 0000 		sts pxDelayedTaskList+1,r25
 722 026c 8093 0000 		sts pxDelayedTaskList,r24
3635:../../Source/tasks.c **** }
 724               	.LM69:
 725 0270 80E0      		ldi r24,lo8(xDelayedTaskList2)
 726 0272 90E0      		ldi r25,hi8(xDelayedTaskList2)
 727 0274 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 728 0278 8093 0000 		sts pxOverflowDelayedTaskList,r24
 729 027c 00C0      		rjmp .L27
 730               	.L25:
 731               	.LBE43:
 732               	.LBE42:
1107:../../Source/tasks.c **** 			{
 734               	.LM70:
 735 027e 8091 0000 		lds r24,xSchedulerRunning
 736 0282 8111      		cpse r24,__zero_reg__
 737 0284 00C0      		rjmp .L27
1109:../../Source/tasks.c **** 				{
 739               	.LM71:
 740 0286 E091 0000 		lds r30,pxCurrentTCB
 741 028a F091 0000 		lds r31,pxCurrentTCB+1
 742 028e 9689      		ldd r25,Z+22
 743 0290 8E89      		ldd r24,Y+22
 744 0292 8917      		cp r24,r25
 745 0294 00F0      		brlo .L27
1111:../../Source/tasks.c **** 				}
 747               	.LM72:
 748 0296 D093 0000 		sts pxCurrentTCB+1,r29
 749 029a C093 0000 		sts pxCurrentTCB,r28
 750               	.L27:
1124:../../Source/tasks.c **** 
 752               	.LM73:
 753 029e 8091 0000 		lds r24,uxTaskNumber
 754 02a2 8F5F      		subi r24,lo8(-(1))
 755 02a4 8093 0000 		sts uxTaskNumber,r24
1134:../../Source/tasks.c **** 
 757               	.LM74:
 758 02a8 8E89      		ldd r24,Y+22
 759 02aa 9091 0000 		lds r25,uxTopReadyPriority
 760 02ae 9817      		cp r25,r24
 761 02b0 00F4      		brsh .L29
 762 02b2 8093 0000 		sts uxTopReadyPriority,r24
 763               	.L29:
 764 02b6 F9E0      		ldi r31,lo8(9)
 765 02b8 8F9F      		mul r24,r31
 766 02ba C001      		movw r24,r0
 767 02bc 1124      		clr __zero_reg__
 768 02be B601      		movw r22,r12
 769 02c0 8050      		subi r24,lo8(-(pxReadyTasksLists))
 770 02c2 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 771 02c4 0E94 0000 		call vListInsertEnd
1138:../../Source/tasks.c **** 
 773               	.LM75:
 774               	/* #APP */
 775               	 ;  1138 "../../Source/tasks.c" 1
 776 02c8 0F90      		pop		__tmp_reg__
 777               	 ;  0 "" 2
 778               	 ;  1138 "../../Source/tasks.c" 1
 779 02ca 0FBE      		out		__SREG__, __tmp_reg__
 780               	 ;  0 "" 2
1140:../../Source/tasks.c **** 	{
 782               	.LM76:
 783               	/* #NOAPP */
 784 02cc 8091 0000 		lds r24,xSchedulerRunning
 785 02d0 8823      		tst r24
 786 02d2 01F0      		breq .L32
1144:../../Source/tasks.c **** 		{
 788               	.LM77:
 789 02d4 E091 0000 		lds r30,pxCurrentTCB
 790 02d8 F091 0000 		lds r31,pxCurrentTCB+1
 791 02dc 9689      		ldd r25,Z+22
 792 02de 8E89      		ldd r24,Y+22
 793 02e0 9817      		cp r25,r24
 794 02e2 00F4      		brsh .L32
1146:../../Source/tasks.c **** 		}
 796               	.LM78:
 797 02e4 0E94 0000 		call vPortYield
 798               	.L32:
 799               	.LBE41:
 800               	.LBE40:
 811:../../Source/tasks.c **** 		}
 802               	.LM79:
 803 02e8 81E0      		ldi r24,lo8(1)
 804 02ea 00C0      		rjmp .L44
 805               	.L16:
 815:../../Source/tasks.c **** 		}
 807               	.LM80:
 808 02ec 8FEF      		ldi r24,lo8(-1)
 809               	.L44:
 810               	/* epilogue start */
 819:../../Source/tasks.c **** 
 812               	.LM81:
 813 02ee DF91      		pop r29
 814 02f0 CF91      		pop r28
 815 02f2 0F91      		pop r16
 816 02f4 FF90      		pop r15
 817 02f6 EF90      		pop r14
 818 02f8 DF90      		pop r13
 819 02fa CF90      		pop r12
 820 02fc BF90      		pop r11
 821 02fe AF90      		pop r10
 822 0300 9F90      		pop r9
 823 0302 8F90      		pop r8
 824 0304 7F90      		pop r7
 825 0306 6F90      		pop r6
 826 0308 5F90      		pop r5
 827 030a 4F90      		pop r4
 828 030c 0895      		ret
 846               	.Lscope4:
 848               		.stabd	78,0,0
 851               	.global	vTaskDelete
 853               	vTaskDelete:
 854               		.stabd	46,0,0
1163:../../Source/tasks.c **** 	TCB_t *pxTCB;
 856               	.LM82:
 857               	.LFBB5:
 858 030e 0F93      		push r16
 859 0310 1F93      		push r17
 860 0312 CF93      		push r28
 861 0314 DF93      		push r29
 862               	/* prologue: function */
 863               	/* frame size = 0 */
 864               	/* stack size = 4 */
 865               	.L__stack_usage = 4
 866 0316 EC01      		movw r28,r24
1166:../../Source/tasks.c **** 		{
 868               	.LM83:
 869               	/* #APP */
 870               	 ;  1166 "../../Source/tasks.c" 1
 871 0318 0FB6      		in		__tmp_reg__, __SREG__
 872               	 ;  0 "" 2
 873               	 ;  1166 "../../Source/tasks.c" 1
 874 031a F894      		cli
 875               	 ;  0 "" 2
 876               	 ;  1166 "../../Source/tasks.c" 1
 877 031c 0F92      		push	__tmp_reg__
 878               	 ;  0 "" 2
1170:../../Source/tasks.c **** 
 880               	.LM84:
 881               	/* #NOAPP */
 882 031e 892B      		or r24,r25
 883 0320 01F4      		brne .L48
1170:../../Source/tasks.c **** 
 885               	.LM85:
 886 0322 C091 0000 		lds r28,pxCurrentTCB
 887 0326 D091 0000 		lds r29,pxCurrentTCB+1
 888               	.L48:
1173:../../Source/tasks.c **** 			{
 890               	.LM86:
 891 032a 8E01      		movw r16,r28
 892 032c 0E5F      		subi r16,-2
 893 032e 1F4F      		sbci r17,-1
 894 0330 C801      		movw r24,r16
 895 0332 0E94 0000 		call uxListRemove
1183:../../Source/tasks.c **** 			{
 897               	.LM87:
 898 0336 8C89      		ldd r24,Y+20
 899 0338 9D89      		ldd r25,Y+21
 900 033a 892B      		or r24,r25
 901 033c 01F0      		breq .L49
1185:../../Source/tasks.c **** 			}
 903               	.LM88:
 904 033e CE01      		movw r24,r28
 905 0340 0C96      		adiw r24,12
 906 0342 0E94 0000 		call uxListRemove
 907               	.L49:
1196:../../Source/tasks.c **** 
 909               	.LM89:
 910 0346 8091 0000 		lds r24,uxTaskNumber
 911 034a 8F5F      		subi r24,lo8(-(1))
 912 034c 8093 0000 		sts uxTaskNumber,r24
1198:../../Source/tasks.c **** 			{
 914               	.LM90:
 915 0350 8091 0000 		lds r24,pxCurrentTCB
 916 0354 9091 0000 		lds r25,pxCurrentTCB+1
 917 0358 C817      		cp r28,r24
 918 035a D907      		cpc r29,r25
 919 035c 01F4      		brne .L50
1205:../../Source/tasks.c **** 
 921               	.LM91:
 922 035e B801      		movw r22,r16
 923 0360 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 924 0362 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 925 0364 0E94 0000 		call vListInsertEnd
1210:../../Source/tasks.c **** 
 927               	.LM92:
 928 0368 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 929 036c 8F5F      		subi r24,lo8(-(1))
 930 036e 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
 931 0372 00C0      		rjmp .L51
 932               	.L50:
1225:../../Source/tasks.c **** 				traceTASK_DELETE( pxTCB );
 934               	.LM93:
 935 0374 8091 0000 		lds r24,uxCurrentNumberOfTasks
 936 0378 8150      		subi r24,lo8(-(-1))
 937 037a 8093 0000 		sts uxCurrentNumberOfTasks,r24
 938               	.LBB46:
 939               	.LBB47:
3908:../../Source/tasks.c **** 			vPortFree( pxTCB );
 941               	.LM94:
 942 037e 8F89      		ldd r24,Y+23
 943 0380 988D      		ldd r25,Y+24
 944 0382 0E94 0000 		call vPortFree
3909:../../Source/tasks.c **** 		}
 946               	.LM95:
 947 0386 CE01      		movw r24,r28
 948 0388 0E94 0000 		call vPortFree
 949               	.LBE47:
 950               	.LBE46:
1231:../../Source/tasks.c **** 			}
 952               	.LM96:
 953 038c 0E94 0000 		call prvResetNextTaskUnblockTime
 954               	.L51:
1234:../../Source/tasks.c **** 
 956               	.LM97:
 957               	/* #APP */
 958               	 ;  1234 "../../Source/tasks.c" 1
 959 0390 0F90      		pop		__tmp_reg__
 960               	 ;  0 "" 2
 961               	 ;  1234 "../../Source/tasks.c" 1
 962 0392 0FBE      		out		__SREG__, __tmp_reg__
 963               	 ;  0 "" 2
1238:../../Source/tasks.c **** 		{
 965               	.LM98:
 966               	/* #NOAPP */
 967 0394 8091 0000 		lds r24,xSchedulerRunning
 968 0398 8823      		tst r24
 969 039a 01F0      		breq .L47
1240:../../Source/tasks.c **** 			{
 971               	.LM99:
 972 039c 8091 0000 		lds r24,pxCurrentTCB
 973 03a0 9091 0000 		lds r25,pxCurrentTCB+1
 974 03a4 C817      		cp r28,r24
 975 03a6 D907      		cpc r29,r25
 976 03a8 01F4      		brne .L47
1243:../../Source/tasks.c **** 			}
 978               	.LM100:
 979 03aa 0E94 0000 		call vPortYield
 980               	.L47:
 981               	/* epilogue start */
1250:../../Source/tasks.c **** 
 983               	.LM101:
 984 03ae DF91      		pop r29
 985 03b0 CF91      		pop r28
 986 03b2 1F91      		pop r17
 987 03b4 0F91      		pop r16
 988 03b6 0895      		ret
 990               	.Lscope5:
 992               		.stabd	78,0,0
 993               		.section	.rodata.str1.1,"aMS",@progbits,1
 994               	.LC0:
 995 0000 4944 4C45 		.string	"IDLE"
 995      00
 996               		.text
 998               	.global	vTaskStartScheduler
 1000               	vTaskStartScheduler:
 1001               		.stabd	46,0,0
1976:../../Source/tasks.c **** BaseType_t xReturn;
 1003               	.LM102:
 1004               	.LFBB6:
 1005 03b8 EF92      		push r14
 1006 03ba FF92      		push r15
 1007 03bc 0F93      		push r16
 1008               	/* prologue: function */
 1009               	/* frame size = 0 */
 1010               	/* stack size = 3 */
 1011               	.L__stack_usage = 3
2009:../../Source/tasks.c **** 								configIDLE_TASK_NAME,
 1013               	.LM103:
 1014 03be 80E0      		ldi r24,lo8(xIdleTaskHandle)
 1015 03c0 E82E      		mov r14,r24
 1016 03c2 80E0      		ldi r24,hi8(xIdleTaskHandle)
 1017 03c4 F82E      		mov r15,r24
 1018 03c6 00E0      		ldi r16,0
 1019 03c8 20E0      		ldi r18,0
 1020 03ca 30E0      		ldi r19,0
 1021 03cc 45E5      		ldi r20,lo8(85)
 1022 03ce 50E0      		ldi r21,0
 1023 03d0 60E0      		ldi r22,lo8(.LC0)
 1024 03d2 70E0      		ldi r23,hi8(.LC0)
 1025 03d4 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1026 03d6 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1027 03d8 0E94 0000 		call xTaskCreate
2031:../../Source/tasks.c **** 	{
 1029               	.LM104:
 1030 03dc 8130      		cpi r24,lo8(1)
 1031 03de 01F4      		brne .L59
2047:../../Source/tasks.c **** 
 1033               	.LM105:
 1034               	/* #APP */
 1035               	 ;  2047 "../../Source/tasks.c" 1
 1036 03e0 F894      		cli
 1037               	 ;  0 "" 2
2059:../../Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1039               	.LM106:
 1040               	/* #NOAPP */
 1041 03e2 2FEF      		ldi r18,lo8(-1)
 1042 03e4 3FEF      		ldi r19,lo8(-1)
 1043 03e6 3093 0000 		sts xNextTaskUnblockTime+1,r19
 1044 03ea 2093 0000 		sts xNextTaskUnblockTime,r18
2060:../../Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1046               	.LM107:
 1047 03ee 8093 0000 		sts xSchedulerRunning,r24
2061:../../Source/tasks.c **** 
 1049               	.LM108:
 1050 03f2 1092 0000 		sts xTickCount+1,__zero_reg__
 1051 03f6 1092 0000 		sts xTickCount,__zero_reg__
 1052               	/* epilogue start */
2096:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1054               	.LM109:
 1055 03fa 0F91      		pop r16
 1056 03fc FF90      		pop r15
 1057 03fe EF90      		pop r14
2075:../../Source/tasks.c **** 		{
 1059               	.LM110:
 1060 0400 0C94 0000 		jmp xPortStartScheduler
 1061               	.L59:
 1062               	/* epilogue start */
2096:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1064               	.LM111:
 1065 0404 0F91      		pop r16
 1066 0406 FF90      		pop r15
 1067 0408 EF90      		pop r14
 1068 040a 0895      		ret
 1073               	.Lscope6:
 1075               		.stabd	78,0,0
 1077               	.global	vTaskEndScheduler
 1079               	vTaskEndScheduler:
 1080               		.stabd	46,0,0
2100:../../Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1082               	.LM112:
 1083               	.LFBB7:
 1084               	/* prologue: function */
 1085               	/* frame size = 0 */
 1086               	/* stack size = 0 */
 1087               	.L__stack_usage = 0
2104:../../Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1089               	.LM113:
 1090               	/* #APP */
 1091               	 ;  2104 "../../Source/tasks.c" 1
 1092 040c F894      		cli
 1093               	 ;  0 "" 2
2105:../../Source/tasks.c **** 	vPortEndScheduler();
 1095               	.LM114:
 1096               	/* #NOAPP */
 1097 040e 1092 0000 		sts xSchedulerRunning,__zero_reg__
2106:../../Source/tasks.c **** }
 1099               	.LM115:
 1100 0412 0C94 0000 		jmp vPortEndScheduler
 1102               	.Lscope7:
 1104               		.stabd	78,0,0
 1106               	.global	vTaskSuspendAll
 1108               	vTaskSuspendAll:
 1109               		.stabd	46,0,0
2111:../../Source/tasks.c **** 	/* A critical section is not required as the variable is of type
 1111               	.LM116:
 1112               	.LFBB8:
 1113               	/* prologue: function */
 1114               	/* frame size = 0 */
 1115               	/* stack size = 0 */
 1116               	.L__stack_usage = 0
2123:../../Source/tasks.c **** 
 1118               	.LM117:
 1119 0416 8091 0000 		lds r24,uxSchedulerSuspended
 1120 041a 8F5F      		subi r24,lo8(-(1))
 1121 041c 8093 0000 		sts uxSchedulerSuspended,r24
 1122 0420 0895      		ret
 1124               	.Lscope8:
 1126               		.stabd	78,0,0
 1128               	.global	xTaskGetTickCount
 1130               	xTaskGetTickCount:
 1131               		.stabd	46,0,0
2305:../../Source/tasks.c **** TickType_t xTicks;
 1133               	.LM118:
 1134               	.LFBB9:
 1135               	/* prologue: function */
 1136               	/* frame size = 0 */
 1137               	/* stack size = 0 */
 1138               	.L__stack_usage = 0
2309:../../Source/tasks.c **** 	{
 1140               	.LM119:
 1141               	/* #APP */
 1142               	 ;  2309 "../../Source/tasks.c" 1
 1143 0422 0FB6      		in		__tmp_reg__, __SREG__
 1144               	 ;  0 "" 2
 1145               	 ;  2309 "../../Source/tasks.c" 1
 1146 0424 F894      		cli
 1147               	 ;  0 "" 2
 1148               	 ;  2309 "../../Source/tasks.c" 1
 1149 0426 0F92      		push	__tmp_reg__
 1150               	 ;  0 "" 2
2311:../../Source/tasks.c **** 	}
 1152               	.LM120:
 1153               	/* #NOAPP */
 1154 0428 8091 0000 		lds r24,xTickCount
 1155 042c 9091 0000 		lds r25,xTickCount+1
2313:../../Source/tasks.c **** 
 1157               	.LM121:
 1158               	/* #APP */
 1159               	 ;  2313 "../../Source/tasks.c" 1
 1160 0430 0F90      		pop		__tmp_reg__
 1161               	 ;  0 "" 2
 1162               	 ;  2313 "../../Source/tasks.c" 1
 1163 0432 0FBE      		out		__SREG__, __tmp_reg__
 1164               	 ;  0 "" 2
2316:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1166               	.LM122:
 1167               	/* #NOAPP */
 1168 0434 0895      		ret
 1173               	.Lscope9:
 1175               		.stabd	78,0,0
 1177               	.global	xTaskGetTickCountFromISR
 1179               	xTaskGetTickCountFromISR:
 1180               		.stabd	46,0,0
2320:../../Source/tasks.c **** TickType_t xReturn;
 1182               	.LM123:
 1183               	.LFBB10:
 1184               	/* prologue: function */
 1185               	/* frame size = 0 */
 1186               	/* stack size = 0 */
 1187               	.L__stack_usage = 0
2342:../../Source/tasks.c **** 	}
 1189               	.LM124:
 1190 0436 8091 0000 		lds r24,xTickCount
 1191 043a 9091 0000 		lds r25,xTickCount+1
2347:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1193               	.LM125:
 1194 043e 0895      		ret
 1199               	.Lscope10:
 1201               		.stabd	78,0,0
 1203               	.global	uxTaskGetNumberOfTasks
 1205               	uxTaskGetNumberOfTasks:
 1206               		.stabd	46,0,0
2351:../../Source/tasks.c **** 	/* A critical section is not required because the variables are of type
 1208               	.LM126:
 1209               	.LFBB11:
 1210               	/* prologue: function */
 1211               	/* frame size = 0 */
 1212               	/* stack size = 0 */
 1213               	.L__stack_usage = 0
2354:../../Source/tasks.c **** }
 1215               	.LM127:
 1216 0440 8091 0000 		lds r24,uxCurrentNumberOfTasks
2355:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1218               	.LM128:
 1219 0444 0895      		ret
 1221               	.Lscope11:
 1223               		.stabd	78,0,0
 1226               	.global	pcTaskGetName
 1228               	pcTaskGetName:
 1229               		.stabd	46,0,0
2359:../../Source/tasks.c **** TCB_t *pxTCB;
 1231               	.LM129:
 1232               	.LFBB12:
 1233               	/* prologue: function */
 1234               	/* frame size = 0 */
 1235               	/* stack size = 0 */
 1236               	.L__stack_usage = 0
2364:../../Source/tasks.c **** 	configASSERT( pxTCB );
 1238               	.LM130:
 1239 0446 0097      		sbiw r24,0
 1240 0448 01F4      		brne .L67
2364:../../Source/tasks.c **** 	configASSERT( pxTCB );
 1242               	.LM131:
 1243 044a 8091 0000 		lds r24,pxCurrentTCB
 1244 044e 9091 0000 		lds r25,pxCurrentTCB+1
 1245               	.L67:
2367:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1247               	.LM132:
 1248 0452 4996      		adiw r24,25
 1249 0454 0895      		ret
 1251               	.Lscope12:
 1253               		.stabd	78,0,0
 1255               	.global	xTaskIncrementTick
 1257               	xTaskIncrementTick:
 1258               		.stabd	46,0,0
2708:../../Source/tasks.c **** TCB_t * pxTCB;
 1260               	.LM133:
 1261               	.LFBB13:
 1262 0456 CF92      		push r12
 1263 0458 DF92      		push r13
 1264 045a EF92      		push r14
 1265 045c FF92      		push r15
 1266 045e 0F93      		push r16
 1267 0460 1F93      		push r17
 1268 0462 CF93      		push r28
 1269 0464 DF93      		push r29
 1270               	/* prologue: function */
 1271               	/* frame size = 0 */
 1272               	/* stack size = 8 */
 1273               	.L__stack_usage = 8
2717:../../Source/tasks.c **** 	{
 1275               	.LM134:
 1276 0466 8091 0000 		lds r24,uxSchedulerSuspended
 1277 046a 8111      		cpse r24,__zero_reg__
 1278 046c 00C0      		rjmp .L69
 1279               	.LBB52:
 1280               	.LBB53:
 1281               	.LBB54:
2721:../../Source/tasks.c **** 
 1283               	.LM135:
 1284 046e 0091 0000 		lds r16,xTickCount
 1285 0472 1091 0000 		lds r17,xTickCount+1
 1286 0476 0F5F      		subi r16,-1
 1287 0478 1F4F      		sbci r17,-1
2725:../../Source/tasks.c **** 
 1289               	.LM136:
 1290 047a 1093 0000 		sts xTickCount+1,r17
 1291 047e 0093 0000 		sts xTickCount,r16
2727:../../Source/tasks.c **** 		{
 1293               	.LM137:
 1294 0482 0115      		cp r16,__zero_reg__
 1295 0484 1105      		cpc r17,__zero_reg__
 1296 0486 01F4      		brne .L70
 1297               	.LBB55:
2729:../../Source/tasks.c **** 		}
 1299               	.LM138:
 1300 0488 8091 0000 		lds r24,pxDelayedTaskList
 1301 048c 9091 0000 		lds r25,pxDelayedTaskList+1
 1302 0490 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1303 0494 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1304 0498 3093 0000 		sts pxDelayedTaskList+1,r19
 1305 049c 2093 0000 		sts pxDelayedTaskList,r18
 1306 04a0 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1307 04a4 8093 0000 		sts pxOverflowDelayedTaskList,r24
 1308 04a8 8091 0000 		lds r24,xNumOfOverflows
 1309 04ac 8F5F      		subi r24,lo8(-(1))
 1310 04ae 8093 0000 		sts xNumOfOverflows,r24
 1311 04b2 0E94 0000 		call prvResetNextTaskUnblockTime
 1312               	.L70:
 1313               	.LBE55:
2740:../../Source/tasks.c **** 		{
 1315               	.LM139:
 1316 04b6 8091 0000 		lds r24,xNextTaskUnblockTime
 1317 04ba 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1318 04be C0E0      		ldi r28,0
 1319 04c0 0817      		cp r16,r24
 1320 04c2 1907      		cpc r17,r25
 1321 04c4 00F4      		brsh .+2
 1322 04c6 00C0      		rjmp .L71
2794:../../Source/tasks.c **** 
 1324               	.LM140:
 1325 04c8 D9E0      		ldi r29,lo8(9)
 1326               	.L72:
2744:../../Source/tasks.c **** 				{
 1328               	.LM141:
 1329 04ca E091 0000 		lds r30,pxDelayedTaskList
 1330 04ce F091 0000 		lds r31,pxDelayedTaskList+1
 1331 04d2 8081      		ld r24,Z
 1332 04d4 8111      		cpse r24,__zero_reg__
 1333 04d6 00C0      		rjmp .L73
2751:../../Source/tasks.c **** 					break;
 1335               	.LM142:
 1336 04d8 8FEF      		ldi r24,lo8(-1)
 1337 04da 9FEF      		ldi r25,lo8(-1)
 1338 04dc 00C0      		rjmp .L87
 1339               	.L73:
2760:../../Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1341               	.LM143:
 1342 04de E091 0000 		lds r30,pxDelayedTaskList
 1343 04e2 F091 0000 		lds r31,pxDelayedTaskList+1
 1344 04e6 0580      		ldd __tmp_reg__,Z+5
 1345 04e8 F681      		ldd r31,Z+6
 1346 04ea E02D      		mov r30,__tmp_reg__
 1347 04ec E680      		ldd r14,Z+6
 1348 04ee F780      		ldd r15,Z+7
2761:../../Source/tasks.c **** 
 1350               	.LM144:
 1351 04f0 D701      		movw r26,r14
 1352 04f2 1296      		adiw r26,2
 1353 04f4 8D91      		ld r24,X+
 1354 04f6 9C91      		ld r25,X
 1355 04f8 1397      		sbiw r26,2+1
2763:../../Source/tasks.c **** 					{
 1357               	.LM145:
 1358 04fa 0817      		cp r16,r24
 1359 04fc 1907      		cpc r17,r25
 1360 04fe 00F4      		brsh .L74
 1361               	.L87:
2770:../../Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
 1363               	.LM146:
 1364 0500 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1365 0504 8093 0000 		sts xNextTaskUnblockTime,r24
 1366 0508 00C0      		rjmp .L71
 1367               	.L74:
2779:../../Source/tasks.c **** 
 1369               	.LM147:
 1370 050a 6701      		movw r12,r14
 1371 050c B2E0      		ldi r27,2
 1372 050e CB0E      		add r12,r27
 1373 0510 D11C      		adc r13,__zero_reg__
 1374 0512 C601      		movw r24,r12
 1375 0514 0E94 0000 		call uxListRemove
2783:../../Source/tasks.c **** 					{
 1377               	.LM148:
 1378 0518 F701      		movw r30,r14
 1379 051a 8489      		ldd r24,Z+20
 1380 051c 9589      		ldd r25,Z+21
 1381 051e 892B      		or r24,r25
 1382 0520 01F0      		breq .L75
2785:../../Source/tasks.c **** 					}
 1384               	.LM149:
 1385 0522 C701      		movw r24,r14
 1386 0524 0C96      		adiw r24,12
 1387 0526 0E94 0000 		call uxListRemove
 1388               	.L75:
2794:../../Source/tasks.c **** 
 1390               	.LM150:
 1391 052a D701      		movw r26,r14
 1392 052c 5696      		adiw r26,22
 1393 052e 8C91      		ld r24,X
 1394 0530 9091 0000 		lds r25,uxTopReadyPriority
 1395 0534 9817      		cp r25,r24
 1396 0536 00F4      		brsh .L76
 1397 0538 8093 0000 		sts uxTopReadyPriority,r24
 1398               	.L76:
 1399 053c D89F      		mul r29,r24
 1400 053e C001      		movw r24,r0
 1401 0540 1124      		clr __zero_reg__
 1402 0542 B601      		movw r22,r12
 1403 0544 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1404 0546 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1405 0548 0E94 0000 		call vListInsertEnd
2804:../../Source/tasks.c **** 						{
 1407               	.LM151:
 1408 054c E091 0000 		lds r30,pxCurrentTCB
 1409 0550 F091 0000 		lds r31,pxCurrentTCB+1
 1410 0554 D701      		movw r26,r14
 1411 0556 5696      		adiw r26,22
 1412 0558 9C91      		ld r25,X
 1413 055a 8689      		ldd r24,Z+22
 1414 055c 9817      		cp r25,r24
 1415 055e 00F4      		brsh .+2
 1416 0560 00C0      		rjmp .L72
2806:../../Source/tasks.c **** 						}
 1418               	.LM152:
 1419 0562 C1E0      		ldi r28,lo8(1)
 1420 0564 00C0      		rjmp .L72
 1421               	.L71:
2823:../../Source/tasks.c **** 			{
 1423               	.LM153:
 1424 0566 E091 0000 		lds r30,pxCurrentTCB
 1425 056a F091 0000 		lds r31,pxCurrentTCB+1
 1426 056e E689      		ldd r30,Z+22
 1427 0570 B9E0      		ldi r27,lo8(9)
 1428 0572 EB9F      		mul r30,r27
 1429 0574 F001      		movw r30,r0
 1430 0576 1124      		clr __zero_reg__
 1431 0578 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1432 057a F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1433 057c 8081      		ld r24,Z
 1434 057e 8230      		cpi r24,lo8(2)
 1435 0580 00F0      		brlo .L78
2825:../../Source/tasks.c **** 			}
 1437               	.LM154:
 1438 0582 C1E0      		ldi r28,lo8(1)
 1439               	.L78:
2851:../../Source/tasks.c **** 			{
 1441               	.LM155:
 1442 0584 8091 0000 		lds r24,xYieldPending
 1443 0588 8823      		tst r24
 1444 058a 01F0      		breq .L79
2853:../../Source/tasks.c **** 			}
 1446               	.LM156:
 1447 058c C1E0      		ldi r28,lo8(1)
 1448 058e 00C0      		rjmp .L79
 1449               	.L69:
 1450               	.LBE54:
 1451               	.LBE53:
 1452               	.LBE52:
2864:../../Source/tasks.c **** 
 1454               	.LM157:
 1455 0590 8091 0000 		lds r24,xPendedTicks
 1456 0594 9091 0000 		lds r25,xPendedTicks+1
 1457 0598 0196      		adiw r24,1
 1458 059a 9093 0000 		sts xPendedTicks+1,r25
 1459 059e 8093 0000 		sts xPendedTicks,r24
2711:../../Source/tasks.c **** 
 1461               	.LM158:
 1462 05a2 C0E0      		ldi r28,0
 1463               	.L79:
2876:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1465               	.LM159:
 1466 05a4 8C2F      		mov r24,r28
 1467               	/* epilogue start */
 1468 05a6 DF91      		pop r29
 1469 05a8 CF91      		pop r28
 1470 05aa 1F91      		pop r17
 1471 05ac 0F91      		pop r16
 1472 05ae FF90      		pop r15
 1473 05b0 EF90      		pop r14
 1474 05b2 DF90      		pop r13
 1475 05b4 CF90      		pop r12
 1476 05b6 0895      		ret
 1491               	.Lscope13:
 1493               		.stabd	78,0,0
 1495               	.global	xTaskResumeAll
 1497               	xTaskResumeAll:
 1498               		.stabd	46,0,0
2195:../../Source/tasks.c **** TCB_t *pxTCB = NULL;
 1500               	.LM160:
 1501               	.LFBB14:
 1502 05b8 EF92      		push r14
 1503 05ba FF92      		push r15
 1504 05bc 0F93      		push r16
 1505 05be 1F93      		push r17
 1506 05c0 CF93      		push r28
 1507 05c2 DF93      		push r29
 1508               	/* prologue: function */
 1509               	/* frame size = 0 */
 1510               	/* stack size = 6 */
 1511               	.L__stack_usage = 6
2208:../../Source/tasks.c **** 	{
 1513               	.LM161:
 1514               	/* #APP */
 1515               	 ;  2208 "../../Source/tasks.c" 1
 1516 05c4 0FB6      		in		__tmp_reg__, __SREG__
 1517               	 ;  0 "" 2
 1518               	 ;  2208 "../../Source/tasks.c" 1
 1519 05c6 F894      		cli
 1520               	 ;  0 "" 2
 1521               	 ;  2208 "../../Source/tasks.c" 1
 1522 05c8 0F92      		push	__tmp_reg__
 1523               	 ;  0 "" 2
2210:../../Source/tasks.c **** 
 1525               	.LM162:
 1526               	/* #NOAPP */
 1527 05ca 8091 0000 		lds r24,uxSchedulerSuspended
 1528 05ce 8150      		subi r24,lo8(-(-1))
 1529 05d0 8093 0000 		sts uxSchedulerSuspended,r24
2212:../../Source/tasks.c **** 		{
 1531               	.LM163:
 1532 05d4 8091 0000 		lds r24,uxSchedulerSuspended
 1533 05d8 8823      		tst r24
 1534 05da 01F0      		breq .L89
 1535               	.L91:
2197:../../Source/tasks.c **** 
 1537               	.LM164:
 1538 05dc 80E0      		ldi r24,0
 1539 05de 00C0      		rjmp .L90
 1540               	.L89:
2214:../../Source/tasks.c **** 			{
 1542               	.LM165:
 1543 05e0 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1544 05e4 8823      		tst r24
 1545 05e6 01F0      		breq .L91
 1546 05e8 C0E0      		ldi r28,0
 1547 05ea D0E0      		ldi r29,0
2223:../../Source/tasks.c **** 
 1549               	.LM166:
 1550 05ec 89E0      		ldi r24,lo8(9)
 1551 05ee F82E      		mov r15,r24
2229:../../Source/tasks.c **** 					}
 1553               	.LM167:
 1554 05f0 EE24      		clr r14
 1555 05f2 E394      		inc r14
 1556               	.L92:
2218:../../Source/tasks.c **** 				{
 1558               	.LM168:
 1559 05f4 8091 0000 		lds r24,xPendingReadyList
 1560 05f8 8823      		tst r24
 1561 05fa 01F0      		breq .L116
2220:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1563               	.LM169:
 1564 05fc E091 0000 		lds r30,xPendingReadyList+5
 1565 0600 F091 0000 		lds r31,xPendingReadyList+5+1
 1566 0604 C681      		ldd r28,Z+6
 1567 0606 D781      		ldd r29,Z+7
2221:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1569               	.LM170:
 1570 0608 CE01      		movw r24,r28
 1571 060a 0C96      		adiw r24,12
 1572 060c 0E94 0000 		call uxListRemove
2222:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1574               	.LM171:
 1575 0610 8E01      		movw r16,r28
 1576 0612 0E5F      		subi r16,-2
 1577 0614 1F4F      		sbci r17,-1
 1578 0616 C801      		movw r24,r16
 1579 0618 0E94 0000 		call uxListRemove
2223:../../Source/tasks.c **** 
 1581               	.LM172:
 1582 061c 8E89      		ldd r24,Y+22
 1583 061e 9091 0000 		lds r25,uxTopReadyPriority
 1584 0622 9817      		cp r25,r24
 1585 0624 00F4      		brsh .L93
2223:../../Source/tasks.c **** 
 1587               	.LM173:
 1588 0626 8093 0000 		sts uxTopReadyPriority,r24
 1589               	.L93:
2223:../../Source/tasks.c **** 
 1591               	.LM174:
 1592 062a F89E      		mul r15,r24
 1593 062c C001      		movw r24,r0
 1594 062e 1124      		clr __zero_reg__
 1595 0630 B801      		movw r22,r16
 1596 0632 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1597 0634 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1598 0636 0E94 0000 		call vListInsertEnd
2227:../../Source/tasks.c **** 					{
 1600               	.LM175:
 1601 063a E091 0000 		lds r30,pxCurrentTCB
 1602 063e F091 0000 		lds r31,pxCurrentTCB+1
 1603 0642 9E89      		ldd r25,Y+22
 1604 0644 8689      		ldd r24,Z+22
 1605 0646 9817      		cp r25,r24
 1606 0648 00F0      		brlo .L92
2229:../../Source/tasks.c **** 					}
 1608               	.LM176:
 1609 064a E092 0000 		sts xYieldPending,r14
 1610 064e 00C0      		rjmp .L92
 1611               	.L116:
2237:../../Source/tasks.c **** 				{
 1613               	.LM177:
 1614 0650 CD2B      		or r28,r29
 1615 0652 01F0      		breq .L96
2245:../../Source/tasks.c **** 				}
 1617               	.LM178:
 1618 0654 0E94 0000 		call prvResetNextTaskUnblockTime
 1619               	.L96:
 1620               	.LBB56:
2253:../../Source/tasks.c **** 
 1622               	.LM179:
 1623 0658 C091 0000 		lds r28,xPendedTicks
 1624 065c D091 0000 		lds r29,xPendedTicks+1
2255:../../Source/tasks.c **** 					{
 1626               	.LM180:
 1627 0660 2097      		sbiw r28,0
 1628 0662 01F0      		breq .L97
2261:../../Source/tasks.c **** 							}
 1630               	.LM181:
 1631 0664 11E0      		ldi r17,lo8(1)
 1632               	.L99:
2259:../../Source/tasks.c **** 							{
 1634               	.LM182:
 1635 0666 0E94 0000 		call xTaskIncrementTick
 1636 066a 8111      		cpse r24,__zero_reg__
2261:../../Source/tasks.c **** 							}
 1638               	.LM183:
 1639 066c 1093 0000 		sts xYieldPending,r17
 1640               	.L98:
2267:../../Source/tasks.c **** 						} while( xPendedCounts > ( TickType_t ) 0U );
 1642               	.LM184:
 1643 0670 2197      		sbiw r28,1
2268:../../Source/tasks.c **** 
 1645               	.LM185:
 1646 0672 01F4      		brne .L99
2270:../../Source/tasks.c **** 					}
 1648               	.LM186:
 1649 0674 1092 0000 		sts xPendedTicks+1,__zero_reg__
 1650 0678 1092 0000 		sts xPendedTicks,__zero_reg__
 1651               	.L97:
 1652               	.LBE56:
2278:../../Source/tasks.c **** 				{
 1654               	.LM187:
 1655 067c 8091 0000 		lds r24,xYieldPending
 1656 0680 8823      		tst r24
 1657 0682 01F4      		brne .+2
 1658 0684 00C0      		rjmp .L91
2285:../../Source/tasks.c **** 				}
 1660               	.LM188:
 1661 0686 0E94 0000 		call vPortYield
2282:../../Source/tasks.c **** 					}
 1663               	.LM189:
 1664 068a 81E0      		ldi r24,lo8(1)
 1665               	.L90:
2298:../../Source/tasks.c **** 
 1667               	.LM190:
 1668               	/* #APP */
 1669               	 ;  2298 "../../Source/tasks.c" 1
 1670 068c 0F90      		pop		__tmp_reg__
 1671               	 ;  0 "" 2
 1672               	 ;  2298 "../../Source/tasks.c" 1
 1673 068e 0FBE      		out		__SREG__, __tmp_reg__
 1674               	 ;  0 "" 2
 1675               	/* epilogue start */
2301:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1677               	.LM191:
 1678               	/* #NOAPP */
 1679 0690 DF91      		pop r29
 1680 0692 CF91      		pop r28
 1681 0694 1F91      		pop r17
 1682 0696 0F91      		pop r16
 1683 0698 FF90      		pop r15
 1684 069a EF90      		pop r14
 1685 069c 0895      		ret
 1694               	.Lscope14:
 1696               		.stabd	78,0,0
 1700               	.global	vTaskDelayUntil
 1702               	vTaskDelayUntil:
 1703               		.stabd	46,0,0
1258:../../Source/tasks.c **** 	TickType_t xTimeToWake;
 1705               	.LM192:
 1706               	.LFBB15:
 1707 069e 0F93      		push r16
 1708 06a0 1F93      		push r17
 1709 06a2 CF93      		push r28
 1710 06a4 DF93      		push r29
 1711               	/* prologue: function */
 1712               	/* frame size = 0 */
 1713               	/* stack size = 4 */
 1714               	.L__stack_usage = 4
 1715 06a6 8C01      		movw r16,r24
 1716 06a8 EB01      		movw r28,r22
1266:../../Source/tasks.c **** 		{
 1718               	.LM193:
 1719 06aa 0E94 0000 		call vTaskSuspendAll
 1720               	.LBB57:
1270:../../Source/tasks.c **** 
 1722               	.LM194:
 1723 06ae 4091 0000 		lds r20,xTickCount
 1724 06b2 5091 0000 		lds r21,xTickCount+1
1273:../../Source/tasks.c **** 
 1726               	.LM195:
 1727 06b6 F801      		movw r30,r16
 1728 06b8 2081      		ld r18,Z
 1729 06ba 3181      		ldd r19,Z+1
 1730 06bc C901      		movw r24,r18
 1731 06be 8C0F      		add r24,r28
 1732 06c0 9D1F      		adc r25,r29
1275:../../Source/tasks.c **** 			{
 1734               	.LM196:
 1735 06c2 4217      		cp r20,r18
 1736 06c4 5307      		cpc r21,r19
 1737 06c6 00F4      		brsh .L118
1282:../../Source/tasks.c **** 				{
 1739               	.LM197:
 1740 06c8 8217      		cp r24,r18
 1741 06ca 9307      		cpc r25,r19
 1742 06cc 00F4      		brsh .L124
 1743 06ce 00C0      		rjmp .L131
 1744               	.L118:
1296:../../Source/tasks.c **** 				{
 1746               	.LM198:
 1747 06d0 8217      		cp r24,r18
 1748 06d2 9307      		cpc r25,r19
 1749 06d4 00F0      		brlo .L125
 1750               	.L131:
 1751               	.LBE57:
1260:../../Source/tasks.c **** 
 1753               	.LM199:
 1754 06d6 21E0      		ldi r18,lo8(1)
 1755 06d8 4817      		cp r20,r24
 1756 06da 5907      		cpc r21,r25
 1757 06dc 00F0      		brlo .L119
 1758               	.L124:
1260:../../Source/tasks.c **** 
 1760               	.LM200:
 1761 06de 20E0      		ldi r18,0
 1762 06e0 00C0      		rjmp .L119
 1763               	.L125:
 1764               	.LBB58:
1298:../../Source/tasks.c **** 				}
 1766               	.LM201:
 1767 06e2 21E0      		ldi r18,lo8(1)
 1768               	.L119:
1307:../../Source/tasks.c **** 
 1770               	.LM202:
 1771 06e4 F801      		movw r30,r16
 1772 06e6 9183      		std Z+1,r25
 1773 06e8 8083      		st Z,r24
1309:../../Source/tasks.c **** 			{
 1775               	.LM203:
 1776 06ea 2223      		tst r18
 1777 06ec 01F0      		breq .L122
1315:../../Source/tasks.c **** 			}
 1779               	.LM204:
 1780 06ee 841B      		sub r24,r20
 1781 06f0 950B      		sbc r25,r21
 1782 06f2 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
 1783               	.L122:
 1784               	.LBE58:
1322:../../Source/tasks.c **** 
 1786               	.LM205:
 1787 06f6 0E94 0000 		call xTaskResumeAll
1326:../../Source/tasks.c **** 		{
 1789               	.LM206:
 1790 06fa 8111      		cpse r24,__zero_reg__
 1791 06fc 00C0      		rjmp .L117
1328:../../Source/tasks.c **** 		}
 1793               	.LM207:
 1794 06fe 0E94 0000 		call vPortYield
 1795               	.L117:
 1796               	/* epilogue start */
1334:../../Source/tasks.c **** 
 1798               	.LM208:
 1799 0702 DF91      		pop r29
 1800 0704 CF91      		pop r28
 1801 0706 1F91      		pop r17
 1802 0708 0F91      		pop r16
 1803 070a 0895      		ret
 1815               	.Lscope15:
 1817               		.stabd	78,0,0
 1820               	.global	vTaskDelay
 1822               	vTaskDelay:
 1823               		.stabd	46,0,0
1342:../../Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 1825               	.LM209:
 1826               	.LFBB16:
 1827 070c CF93      		push r28
 1828 070e DF93      		push r29
 1829               	/* prologue: function */
 1830               	/* frame size = 0 */
 1831               	/* stack size = 2 */
 1832               	.L__stack_usage = 2
 1833 0710 EC01      		movw r28,r24
1346:../../Source/tasks.c **** 		{
 1835               	.LM210:
 1836 0712 892B      		or r24,r25
 1837 0714 01F4      		brne .L133
 1838               	.L135:
1373:../../Source/tasks.c **** 		}
 1840               	.LM211:
 1841 0716 0E94 0000 		call vPortYield
 1842 071a 00C0      		rjmp .L132
 1843               	.L133:
1349:../../Source/tasks.c **** 			{
 1845               	.LM212:
 1846 071c 0E94 0000 		call vTaskSuspendAll
1360:../../Source/tasks.c **** 			}
 1848               	.LM213:
 1849 0720 CE01      		movw r24,r28
 1850 0722 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
1362:../../Source/tasks.c **** 		}
 1852               	.LM214:
 1853 0726 0E94 0000 		call xTaskResumeAll
1371:../../Source/tasks.c **** 		{
 1855               	.LM215:
 1856 072a 8823      		tst r24
 1857 072c 01F0      		breq .L135
 1858               	.L132:
 1859               	/* epilogue start */
1379:../../Source/tasks.c **** 
 1861               	.LM216:
 1862 072e DF91      		pop r29
 1863 0730 CF91      		pop r28
 1864 0732 0895      		ret
 1866               	.Lscope16:
 1868               		.stabd	78,0,0
 1871               	.global	xTaskCatchUpTicks
 1873               	xTaskCatchUpTicks:
 1874               		.stabd	46,0,0
2610:../../Source/tasks.c **** BaseType_t xYieldRequired = pdFALSE;
 1876               	.LM217:
 1877               	.LFBB17:
 1878 0734 CF93      		push r28
 1879 0736 DF93      		push r29
 1880               	/* prologue: function */
 1881               	/* frame size = 0 */
 1882               	/* stack size = 2 */
 1883               	.L__stack_usage = 2
 1884 0738 EC01      		movw r28,r24
2619:../../Source/tasks.c **** 	xPendedTicks += xTicksToCatchUp;
 1886               	.LM218:
 1887 073a 0E94 0000 		call vTaskSuspendAll
2620:../../Source/tasks.c **** 	xYieldRequired = xTaskResumeAll();
 1889               	.LM219:
 1890 073e 8091 0000 		lds r24,xPendedTicks
 1891 0742 9091 0000 		lds r25,xPendedTicks+1
 1892 0746 C80F      		add r28,r24
 1893 0748 D91F      		adc r29,r25
 1894 074a D093 0000 		sts xPendedTicks+1,r29
 1895 074e C093 0000 		sts xPendedTicks,r28
 1896               	/* epilogue start */
2624:../../Source/tasks.c **** /*----------------------------------------------------------*/
 1898               	.LM220:
 1899 0752 DF91      		pop r29
 1900 0754 CF91      		pop r28
2621:../../Source/tasks.c **** 
 1902               	.LM221:
 1903 0756 0C94 0000 		jmp xTaskResumeAll
 1905               	.Lscope17:
 1907               		.stabd	78,0,0
 1909               	.global	vTaskSwitchContext
 1911               	vTaskSwitchContext:
 1912               		.stabd	46,0,0
2990:../../Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 1914               	.LM222:
 1915               	.LFBB18:
 1916               	/* prologue: function */
 1917               	/* frame size = 0 */
 1918               	/* stack size = 0 */
 1919               	.L__stack_usage = 0
2991:../../Source/tasks.c **** 	{
 1921               	.LM223:
 1922 075a 8091 0000 		lds r24,uxSchedulerSuspended
 1923 075e 8823      		tst r24
 1924 0760 01F0      		breq .L141
2995:../../Source/tasks.c **** 	}
 1926               	.LM224:
 1927 0762 81E0      		ldi r24,lo8(1)
 1928 0764 8093 0000 		sts xYieldPending,r24
 1929 0768 0895      		ret
 1930               	.L141:
2999:../../Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 1932               	.LM225:
 1933 076a 1092 0000 		sts xYieldPending,__zero_reg__
 1934               	.LBB59:
3041:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1936               	.LM226:
 1937 076e 8091 0000 		lds r24,uxTopReadyPriority
 1938 0772 69E0      		ldi r22,lo8(9)
 1939               	.L143:
3041:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1941               	.LM227:
 1942 0774 482F      		mov r20,r24
 1943 0776 50E0      		ldi r21,0
 1944 0778 649F      		mul r22,r20
 1945 077a 9001      		movw r18,r0
 1946 077c 659F      		mul r22,r21
 1947 077e 300D      		add r19,r0
 1948 0780 1124      		clr __zero_reg__
 1949 0782 F901      		movw r30,r18
 1950 0784 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1951 0786 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1952 0788 9081      		ld r25,Z
 1953 078a 9111      		cpse r25,__zero_reg__
 1954 078c 00C0      		rjmp .L146
3041:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1956               	.LM228:
 1957 078e 8150      		subi r24,lo8(-(-1))
 1958 0790 00C0      		rjmp .L143
 1959               	.L146:
 1960               	.LBB60:
3041:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1962               	.LM229:
 1963 0792 A181      		ldd r26,Z+1
 1964 0794 B281      		ldd r27,Z+2
 1965 0796 1296      		adiw r26,2
 1966 0798 0D90      		ld __tmp_reg__,X+
 1967 079a BC91      		ld r27,X
 1968 079c A02D      		mov r26,__tmp_reg__
 1969 079e B283      		std Z+2,r27
 1970 07a0 A183      		std Z+1,r26
 1971 07a2 2050      		subi r18,lo8(-(pxReadyTasksLists+3))
 1972 07a4 3040      		sbci r19,hi8(-(pxReadyTasksLists+3))
 1973 07a6 A217      		cp r26,r18
 1974 07a8 B307      		cpc r27,r19
 1975 07aa 01F4      		brne .L145
3041:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1977               	.LM230:
 1978 07ac 1296      		adiw r26,2
 1979 07ae 2D91      		ld r18,X+
 1980 07b0 3C91      		ld r19,X
 1981 07b2 1397      		sbiw r26,2+1
 1982 07b4 3283      		std Z+2,r19
 1983 07b6 2183      		std Z+1,r18
 1984               	.L145:
3041:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1986               	.LM231:
 1987 07b8 99E0      		ldi r25,lo8(9)
 1988 07ba 949F      		mul r25,r20
 1989 07bc F001      		movw r30,r0
 1990 07be 959F      		mul r25,r21
 1991 07c0 F00D      		add r31,r0
 1992 07c2 1124      		clr __zero_reg__
 1993 07c4 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1994 07c6 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1995 07c8 0180      		ldd __tmp_reg__,Z+1
 1996 07ca F281      		ldd r31,Z+2
 1997 07cc E02D      		mov r30,__tmp_reg__
 1998 07ce 2681      		ldd r18,Z+6
 1999 07d0 3781      		ldd r19,Z+7
 2000 07d2 3093 0000 		sts pxCurrentTCB+1,r19
 2001 07d6 2093 0000 		sts pxCurrentTCB,r18
 2002               	.LBE60:
 2003 07da 8093 0000 		sts uxTopReadyPriority,r24
 2004 07de 0895      		ret
 2005               	.LBE59:
 2010               	.Lscope18:
 2012               		.stabd	78,0,0
 2016               	.global	vTaskPlaceOnEventList
 2018               	vTaskPlaceOnEventList:
 2019               		.stabd	46,0,0
3065:../../Source/tasks.c **** 	configASSERT( pxEventList );
 2021               	.LM232:
 2022               	.LFBB19:
 2023 07e0 CF93      		push r28
 2024 07e2 DF93      		push r29
 2025               	/* prologue: function */
 2026               	/* frame size = 0 */
 2027               	/* stack size = 2 */
 2028               	.L__stack_usage = 2
 2029 07e4 EB01      		movw r28,r22
3075:../../Source/tasks.c **** 
 2031               	.LM233:
 2032 07e6 6091 0000 		lds r22,pxCurrentTCB
 2033 07ea 7091 0000 		lds r23,pxCurrentTCB+1
 2034 07ee 645F      		subi r22,-12
 2035 07f0 7F4F      		sbci r23,-1
 2036 07f2 0E94 0000 		call vListInsert
3077:../../Source/tasks.c **** }
 2038               	.LM234:
 2039 07f6 CE01      		movw r24,r28
 2040               	/* epilogue start */
3078:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 2042               	.LM235:
 2043 07f8 DF91      		pop r29
 2044 07fa CF91      		pop r28
3077:../../Source/tasks.c **** }
 2046               	.LM236:
 2047 07fc 0C94 0000 		jmp prvAddCurrentTaskToDelayedList.isra.2
 2049               	.Lscope19:
 2051               		.stabd	78,0,0
 2056               	.global	vTaskPlaceOnUnorderedEventList
 2058               	vTaskPlaceOnUnorderedEventList:
 2059               		.stabd	46,0,0
3082:../../Source/tasks.c **** 	configASSERT( pxEventList );
 2061               	.LM237:
 2062               	.LFBB20:
 2063 0800 CF93      		push r28
 2064 0802 DF93      		push r29
 2065               	/* prologue: function */
 2066               	/* frame size = 0 */
 2067               	/* stack size = 2 */
 2068               	.L__stack_usage = 2
 2069 0804 EA01      		movw r28,r20
3092:../../Source/tasks.c **** 
 2071               	.LM238:
 2072 0806 E091 0000 		lds r30,pxCurrentTCB
 2073 080a F091 0000 		lds r31,pxCurrentTCB+1
 2074 080e 7068      		ori r23,128
 2075 0810 7587      		std Z+13,r23
 2076 0812 6487      		std Z+12,r22
3099:../../Source/tasks.c **** 
 2078               	.LM239:
 2079 0814 6091 0000 		lds r22,pxCurrentTCB
 2080 0818 7091 0000 		lds r23,pxCurrentTCB+1
 2081 081c 645F      		subi r22,-12
 2082 081e 7F4F      		sbci r23,-1
 2083 0820 0E94 0000 		call vListInsertEnd
3101:../../Source/tasks.c **** }
 2085               	.LM240:
 2086 0824 CE01      		movw r24,r28
 2087               	/* epilogue start */
3102:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 2089               	.LM241:
 2090 0826 DF91      		pop r29
 2091 0828 CF91      		pop r28
3101:../../Source/tasks.c **** }
 2093               	.LM242:
 2094 082a 0C94 0000 		jmp prvAddCurrentTaskToDelayedList.isra.2
 2096               	.Lscope20:
 2098               		.stabd	78,0,0
 2101               	.global	xTaskRemoveFromEventList
 2103               	xTaskRemoveFromEventList:
 2104               		.stabd	46,0,0
3139:../../Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2106               	.LM243:
 2107               	.LFBB21:
 2108 082e 0F93      		push r16
 2109 0830 1F93      		push r17
 2110 0832 CF93      		push r28
 2111 0834 DF93      		push r29
 2112               	/* prologue: function */
 2113               	/* frame size = 0 */
 2114               	/* stack size = 4 */
 2115               	.L__stack_usage = 4
3156:../../Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2117               	.LM244:
 2118 0836 DC01      		movw r26,r24
 2119 0838 1596      		adiw r26,5
 2120 083a ED91      		ld r30,X+
 2121 083c FC91      		ld r31,X
 2122 083e 1697      		sbiw r26,5+1
 2123 0840 C681      		ldd r28,Z+6
 2124 0842 D781      		ldd r29,Z+7
3158:../../Source/tasks.c **** 
 2126               	.LM245:
 2127 0844 8E01      		movw r16,r28
 2128 0846 045F      		subi r16,-12
 2129 0848 1F4F      		sbci r17,-1
 2130 084a C801      		movw r24,r16
 2131 084c 0E94 0000 		call uxListRemove
3160:../../Source/tasks.c **** 	{
 2133               	.LM246:
 2134 0850 8091 0000 		lds r24,uxSchedulerSuspended
 2135 0854 8111      		cpse r24,__zero_reg__
 2136 0856 00C0      		rjmp .L150
3162:../../Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2138               	.LM247:
 2139 0858 0A50      		subi r16,10
 2140 085a 1109      		sbc r17,__zero_reg__
 2141 085c C801      		movw r24,r16
 2142 085e 0E94 0000 		call uxListRemove
3163:../../Source/tasks.c **** 
 2144               	.LM248:
 2145 0862 8E89      		ldd r24,Y+22
 2146 0864 9091 0000 		lds r25,uxTopReadyPriority
 2147 0868 9817      		cp r25,r24
 2148 086a 00F4      		brsh .L151
3163:../../Source/tasks.c **** 
 2150               	.LM249:
 2151 086c 8093 0000 		sts uxTopReadyPriority,r24
 2152               	.L151:
3163:../../Source/tasks.c **** 
 2154               	.LM250:
 2155 0870 B9E0      		ldi r27,lo8(9)
 2156 0872 8B9F      		mul r24,r27
 2157 0874 C001      		movw r24,r0
 2158 0876 1124      		clr __zero_reg__
 2159 0878 B801      		movw r22,r16
 2160 087a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2161 087c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2162 087e 00C0      		rjmp .L155
 2163               	.L150:
3183:../../Source/tasks.c **** 	}
 2165               	.LM251:
 2166 0880 B801      		movw r22,r16
 2167 0882 80E0      		ldi r24,lo8(xPendingReadyList)
 2168 0884 90E0      		ldi r25,hi8(xPendingReadyList)
 2169               	.L155:
 2170 0886 0E94 0000 		call vListInsertEnd
3186:../../Source/tasks.c **** 	{
 2172               	.LM252:
 2173 088a E091 0000 		lds r30,pxCurrentTCB
 2174 088e F091 0000 		lds r31,pxCurrentTCB+1
 2175 0892 9E89      		ldd r25,Y+22
 2176 0894 8689      		ldd r24,Z+22
 2177 0896 8917      		cp r24,r25
 2178 0898 00F4      		brsh .L154
3195:../../Source/tasks.c **** 	}
 2180               	.LM253:
 2181 089a 81E0      		ldi r24,lo8(1)
 2182 089c 8093 0000 		sts xYieldPending,r24
 2183 08a0 00C0      		rjmp .L153
 2184               	.L154:
3199:../../Source/tasks.c **** 	}
 2186               	.LM254:
 2187 08a2 80E0      		ldi r24,0
 2188               	.L153:
 2189               	/* epilogue start */
3203:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 2191               	.LM255:
 2192 08a4 DF91      		pop r29
 2193 08a6 CF91      		pop r28
 2194 08a8 1F91      		pop r17
 2195 08aa 0F91      		pop r16
 2196 08ac 0895      		ret
 2202               	.Lscope21:
 2204               		.stabd	78,0,0
 2208               	.global	vTaskRemoveFromUnorderedEventList
 2210               	vTaskRemoveFromUnorderedEventList:
 2211               		.stabd	46,0,0
3207:../../Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2213               	.LM256:
 2214               	.LFBB22:
 2215 08ae 0F93      		push r16
 2216 08b0 1F93      		push r17
 2217 08b2 CF93      		push r28
 2218 08b4 DF93      		push r29
 2219               	/* prologue: function */
 2220               	/* frame size = 0 */
 2221               	/* stack size = 4 */
 2222               	.L__stack_usage = 4
3215:../../Source/tasks.c **** 
 2224               	.LM257:
 2225 08b6 7068      		ori r23,128
 2226 08b8 FC01      		movw r30,r24
 2227 08ba 7183      		std Z+1,r23
 2228 08bc 6083      		st Z,r22
3219:../../Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2230               	.LM258:
 2231 08be C681      		ldd r28,Z+6
 2232 08c0 D781      		ldd r29,Z+7
3221:../../Source/tasks.c **** 
 2234               	.LM259:
 2235 08c2 0E94 0000 		call uxListRemove
3240:../../Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2237               	.LM260:
 2238 08c6 8E01      		movw r16,r28
 2239 08c8 0E5F      		subi r16,-2
 2240 08ca 1F4F      		sbci r17,-1
 2241 08cc C801      		movw r24,r16
 2242 08ce 0E94 0000 		call uxListRemove
3241:../../Source/tasks.c **** 
 2244               	.LM261:
 2245 08d2 8E89      		ldd r24,Y+22
 2246 08d4 9091 0000 		lds r25,uxTopReadyPriority
 2247 08d8 9817      		cp r25,r24
 2248 08da 00F4      		brsh .L157
3241:../../Source/tasks.c **** 
 2250               	.LM262:
 2251 08dc 8093 0000 		sts uxTopReadyPriority,r24
 2252               	.L157:
3241:../../Source/tasks.c **** 
 2254               	.LM263:
 2255 08e0 F9E0      		ldi r31,lo8(9)
 2256 08e2 8F9F      		mul r24,r31
 2257 08e4 C001      		movw r24,r0
 2258 08e6 1124      		clr __zero_reg__
 2259 08e8 B801      		movw r22,r16
 2260 08ea 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2261 08ec 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2262 08ee 0E94 0000 		call vListInsertEnd
3243:../../Source/tasks.c **** 	{
 2264               	.LM264:
 2265 08f2 E091 0000 		lds r30,pxCurrentTCB
 2266 08f6 F091 0000 		lds r31,pxCurrentTCB+1
 2267 08fa 9E89      		ldd r25,Y+22
 2268 08fc 8689      		ldd r24,Z+22
 2269 08fe 8917      		cp r24,r25
 2270 0900 00F4      		brsh .L156
3249:../../Source/tasks.c **** 	}
 2272               	.LM265:
 2273 0902 81E0      		ldi r24,lo8(1)
 2274 0904 8093 0000 		sts xYieldPending,r24
 2275               	.L156:
 2276               	/* epilogue start */
3251:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 2278               	.LM266:
 2279 0908 DF91      		pop r29
 2280 090a CF91      		pop r28
 2281 090c 1F91      		pop r17
 2282 090e 0F91      		pop r16
 2283 0910 0895      		ret
 2288               	.Lscope22:
 2290               		.stabd	78,0,0
 2293               	.global	vTaskSetTimeOutState
 2295               	vTaskSetTimeOutState:
 2296               		.stabd	46,0,0
3255:../../Source/tasks.c **** 	configASSERT( pxTimeOut );
 2298               	.LM267:
 2299               	.LFBB23:
 2300               	/* prologue: function */
 2301               	/* frame size = 0 */
 2302               	/* stack size = 0 */
 2303               	.L__stack_usage = 0
3257:../../Source/tasks.c **** 	{
 2305               	.LM268:
 2306               	/* #APP */
 2307               	 ;  3257 "../../Source/tasks.c" 1
 2308 0912 0FB6      		in		__tmp_reg__, __SREG__
 2309               	 ;  0 "" 2
 2310               	 ;  3257 "../../Source/tasks.c" 1
 2311 0914 F894      		cli
 2312               	 ;  0 "" 2
 2313               	 ;  3257 "../../Source/tasks.c" 1
 2314 0916 0F92      		push	__tmp_reg__
 2315               	 ;  0 "" 2
3259:../../Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 2317               	.LM269:
 2318               	/* #NOAPP */
 2319 0918 2091 0000 		lds r18,xNumOfOverflows
 2320 091c FC01      		movw r30,r24
 2321 091e 2083      		st Z,r18
3260:../../Source/tasks.c **** 	}
 2323               	.LM270:
 2324 0920 2091 0000 		lds r18,xTickCount
 2325 0924 3091 0000 		lds r19,xTickCount+1
 2326 0928 3283      		std Z+2,r19
 2327 092a 2183      		std Z+1,r18
3262:../../Source/tasks.c **** }
 2329               	.LM271:
 2330               	/* #APP */
 2331               	 ;  3262 "../../Source/tasks.c" 1
 2332 092c 0F90      		pop		__tmp_reg__
 2333               	 ;  0 "" 2
 2334               	 ;  3262 "../../Source/tasks.c" 1
 2335 092e 0FBE      		out		__SREG__, __tmp_reg__
 2336               	 ;  0 "" 2
 2337               	/* #NOAPP */
 2338 0930 0895      		ret
 2340               	.Lscope23:
 2342               		.stabd	78,0,0
 2345               	.global	vTaskInternalSetTimeOutState
 2347               	vTaskInternalSetTimeOutState:
 2348               		.stabd	46,0,0
3267:../../Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
 2350               	.LM272:
 2351               	.LFBB24:
 2352               	/* prologue: function */
 2353               	/* frame size = 0 */
 2354               	/* stack size = 0 */
 2355               	.L__stack_usage = 0
3269:../../Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2357               	.LM273:
 2358 0932 2091 0000 		lds r18,xNumOfOverflows
 2359 0936 FC01      		movw r30,r24
 2360 0938 2083      		st Z,r18
3270:../../Source/tasks.c **** }
 2362               	.LM274:
 2363 093a 2091 0000 		lds r18,xTickCount
 2364 093e 3091 0000 		lds r19,xTickCount+1
 2365 0942 3283      		std Z+2,r19
 2366 0944 2183      		std Z+1,r18
 2367 0946 0895      		ret
 2369               	.Lscope24:
 2371               		.stabd	78,0,0
 2375               	.global	xTaskCheckForTimeOut
 2377               	xTaskCheckForTimeOut:
 2378               		.stabd	46,0,0
3275:../../Source/tasks.c **** BaseType_t xReturn;
 2380               	.LM275:
 2381               	.LFBB25:
 2382               	/* prologue: function */
 2383               	/* frame size = 0 */
 2384               	/* stack size = 0 */
 2385               	.L__stack_usage = 0
3281:../../Source/tasks.c **** 	{
 2387               	.LM276:
 2388               	/* #APP */
 2389               	 ;  3281 "../../Source/tasks.c" 1
 2390 0948 0FB6      		in		__tmp_reg__, __SREG__
 2391               	 ;  0 "" 2
 2392               	 ;  3281 "../../Source/tasks.c" 1
 2393 094a F894      		cli
 2394               	 ;  0 "" 2
 2395               	 ;  3281 "../../Source/tasks.c" 1
 2396 094c 0F92      		push	__tmp_reg__
 2397               	 ;  0 "" 2
 2398               	/* #NOAPP */
 2399               	.LBB61:
3284:../../Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 2401               	.LM277:
 2402 094e 2091 0000 		lds r18,xTickCount
 2403 0952 3091 0000 		lds r19,xTickCount+1
3285:../../Source/tasks.c **** 
 2405               	.LM278:
 2406 0956 DC01      		movw r26,r24
 2407 0958 1196      		adiw r26,1
 2408 095a 4D91      		ld r20,X+
 2409 095c 5C91      		ld r21,X
 2410 095e 1297      		sbiw r26,1+1
3309:../../Source/tasks.c **** 		{
 2412               	.LM279:
 2413 0960 E091 0000 		lds r30,xNumOfOverflows
 2414 0964 FC91      		ld r31,X
 2415 0966 FE17      		cp r31,r30
 2416 0968 01F0      		breq .L162
3309:../../Source/tasks.c **** 		{
 2418               	.LM280:
 2419 096a 2417      		cp r18,r20
 2420 096c 3507      		cpc r19,r21
 2421 096e 00F4      		brsh .L165
 2422               	.L162:
3285:../../Source/tasks.c **** 
 2424               	.LM281:
 2425 0970 241B      		sub r18,r20
 2426 0972 350B      		sbc r19,r21
3318:../../Source/tasks.c **** 		{
 2428               	.LM282:
 2429 0974 FB01      		movw r30,r22
 2430 0976 4081      		ld r20,Z
 2431 0978 5181      		ldd r21,Z+1
 2432 097a 2417      		cp r18,r20
 2433 097c 3507      		cpc r19,r21
 2434 097e 00F4      		brsh .L164
3321:../../Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 2436               	.LM283:
 2437 0980 421B      		sub r20,r18
 2438 0982 530B      		sbc r21,r19
 2439 0984 5183      		std Z+1,r21
 2440 0986 4083      		st Z,r20
3322:../../Source/tasks.c **** 			xReturn = pdFALSE;
 2442               	.LM284:
 2443 0988 0E94 0000 		call vTaskInternalSetTimeOutState
3323:../../Source/tasks.c **** 		}
 2445               	.LM285:
 2446 098c 80E0      		ldi r24,0
 2447 098e 00C0      		rjmp .L163
 2448               	.L164:
3327:../../Source/tasks.c **** 			xReturn = pdTRUE;
 2450               	.LM286:
 2451 0990 1182      		std Z+1,__zero_reg__
 2452 0992 1082      		st Z,__zero_reg__
 2453               	.L165:
3316:../../Source/tasks.c **** 		}
 2455               	.LM287:
 2456 0994 81E0      		ldi r24,lo8(1)
 2457               	.L163:
 2458               	.LBE61:
3331:../../Source/tasks.c **** 
 2460               	.LM288:
 2461               	/* #APP */
 2462               	 ;  3331 "../../Source/tasks.c" 1
 2463 0996 0F90      		pop		__tmp_reg__
 2464               	 ;  0 "" 2
 2465               	 ;  3331 "../../Source/tasks.c" 1
 2466 0998 0FBE      		out		__SREG__, __tmp_reg__
 2467               	 ;  0 "" 2
3334:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 2469               	.LM289:
 2470               	/* #NOAPP */
 2471 099a 0895      		ret
 2480               	.Lscope25:
 2482               		.stabd	78,0,0
 2484               	.global	vTaskMissedYield
 2486               	vTaskMissedYield:
 2487               		.stabd	46,0,0
3338:../../Source/tasks.c **** 	xYieldPending = pdTRUE;
 2489               	.LM290:
 2490               	.LFBB26:
 2491               	/* prologue: function */
 2492               	/* frame size = 0 */
 2493               	/* stack size = 0 */
 2494               	.L__stack_usage = 0
3339:../../Source/tasks.c **** }
 2496               	.LM291:
 2497 099c 81E0      		ldi r24,lo8(1)
 2498 099e 8093 0000 		sts xYieldPending,r24
 2499 09a2 0895      		ret
 2501               	.Lscope26:
 2503               		.stabd	78,0,0
 2505               	.global	uxTaskResetEventItemValue
 2507               	uxTaskResetEventItemValue:
 2508               		.stabd	46,0,0
4603:../../Source/tasks.c **** TickType_t uxReturn;
 2510               	.LM292:
 2511               	.LFBB27:
 2512               	/* prologue: function */
 2513               	/* frame size = 0 */
 2514               	/* stack size = 0 */
 2515               	.L__stack_usage = 0
4606:../../Source/tasks.c **** 
 2517               	.LM293:
 2518 09a4 E091 0000 		lds r30,pxCurrentTCB
 2519 09a8 F091 0000 		lds r31,pxCurrentTCB+1
 2520 09ac 8485      		ldd r24,Z+12
 2521 09ae 9585      		ldd r25,Z+13
4610:../../Source/tasks.c **** 
 2523               	.LM294:
 2524 09b0 E091 0000 		lds r30,pxCurrentTCB
 2525 09b4 F091 0000 		lds r31,pxCurrentTCB+1
 2526 09b8 A091 0000 		lds r26,pxCurrentTCB
 2527 09bc B091 0000 		lds r27,pxCurrentTCB+1
 2528 09c0 5696      		adiw r26,22
 2529 09c2 4C91      		ld r20,X
 2530 09c4 24E0      		ldi r18,lo8(4)
 2531 09c6 30E0      		ldi r19,0
 2532 09c8 241B      		sub r18,r20
 2533 09ca 3109      		sbc r19,__zero_reg__
 2534 09cc 3587      		std Z+13,r19
 2535 09ce 2487      		std Z+12,r18
4613:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 2537               	.LM295:
 2538 09d0 0895      		ret
 2543               	.Lscope27:
 2545               		.stabd	78,0,0
 2549               	.global	ulTaskNotifyTake
 2551               	ulTaskNotifyTake:
 2552               		.stabd	46,0,0
4636:../../Source/tasks.c **** 	uint32_t ulReturn;
 2554               	.LM296:
 2555               	.LFBB28:
 2556 09d2 0F93      		push r16
 2557 09d4 1F93      		push r17
 2558               	/* prologue: function */
 2559               	/* frame size = 0 */
 2560               	/* stack size = 2 */
 2561               	.L__stack_usage = 2
 2562 09d6 182F      		mov r17,r24
 2563 09d8 CB01      		movw r24,r22
4639:../../Source/tasks.c **** 		{
 2565               	.LM297:
 2566               	/* #APP */
 2567               	 ;  4639 "../../Source/tasks.c" 1
 2568 09da 0FB6      		in		__tmp_reg__, __SREG__
 2569               	 ;  0 "" 2
 2570               	 ;  4639 "../../Source/tasks.c" 1
 2571 09dc F894      		cli
 2572               	 ;  0 "" 2
 2573               	 ;  4639 "../../Source/tasks.c" 1
 2574 09de 0F92      		push	__tmp_reg__
 2575               	 ;  0 "" 2
4642:../../Source/tasks.c **** 			{
 2577               	.LM298:
 2578               	/* #NOAPP */
 2579 09e0 E091 0000 		lds r30,pxCurrentTCB
 2580 09e4 F091 0000 		lds r31,pxCurrentTCB+1
 2581 09e8 41A1      		ldd r20,Z+33
 2582 09ea 52A1      		ldd r21,Z+34
 2583 09ec 63A1      		ldd r22,Z+35
 2584 09ee 74A1      		ldd r23,Z+36
 2585 09f0 452B      		or r20,r21
 2586 09f2 462B      		or r20,r22
 2587 09f4 472B      		or r20,r23
 2588 09f6 01F4      		brne .L170
4645:../../Source/tasks.c **** 
 2590               	.LM299:
 2591 09f8 E091 0000 		lds r30,pxCurrentTCB
 2592 09fc F091 0000 		lds r31,pxCurrentTCB+1
 2593 0a00 21E0      		ldi r18,lo8(1)
 2594 0a02 25A3      		std Z+37,r18
4647:../../Source/tasks.c **** 				{
 2596               	.LM300:
 2597 0a04 0097      		sbiw r24,0
 2598 0a06 01F0      		breq .L170
4649:../../Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
 2600               	.LM301:
 2601 0a08 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
4656:../../Source/tasks.c **** 				}
 2603               	.LM302:
 2604 0a0c 0E94 0000 		call vPortYield
 2605               	.L170:
4668:../../Source/tasks.c **** 
 2607               	.LM303:
 2608               	/* #APP */
 2609               	 ;  4668 "../../Source/tasks.c" 1
 2610 0a10 0F90      		pop		__tmp_reg__
 2611               	 ;  0 "" 2
 2612               	 ;  4668 "../../Source/tasks.c" 1
 2613 0a12 0FBE      		out		__SREG__, __tmp_reg__
 2614               	 ;  0 "" 2
4670:../../Source/tasks.c **** 		{
 2616               	.LM304:
 2617               	 ;  4670 "../../Source/tasks.c" 1
 2618 0a14 0FB6      		in		__tmp_reg__, __SREG__
 2619               	 ;  0 "" 2
 2620               	 ;  4670 "../../Source/tasks.c" 1
 2621 0a16 F894      		cli
 2622               	 ;  0 "" 2
 2623               	 ;  4670 "../../Source/tasks.c" 1
 2624 0a18 0F92      		push	__tmp_reg__
 2625               	 ;  0 "" 2
4673:../../Source/tasks.c **** 
 2627               	.LM305:
 2628               	/* #NOAPP */
 2629 0a1a E091 0000 		lds r30,pxCurrentTCB
 2630 0a1e F091 0000 		lds r31,pxCurrentTCB+1
 2631 0a22 61A1      		ldd r22,Z+33
 2632 0a24 72A1      		ldd r23,Z+34
 2633 0a26 83A1      		ldd r24,Z+35
 2634 0a28 94A1      		ldd r25,Z+36
4675:../../Source/tasks.c **** 			{
 2636               	.LM306:
 2637 0a2a 6115      		cp r22,__zero_reg__
 2638 0a2c 7105      		cpc r23,__zero_reg__
 2639 0a2e 8105      		cpc r24,__zero_reg__
 2640 0a30 9105      		cpc r25,__zero_reg__
 2641 0a32 01F0      		breq .L172
4679:../../Source/tasks.c **** 				}
 2643               	.LM307:
 2644 0a34 E091 0000 		lds r30,pxCurrentTCB
 2645 0a38 F091 0000 		lds r31,pxCurrentTCB+1
4677:../../Source/tasks.c **** 				{
 2647               	.LM308:
 2648 0a3c 1123      		tst r17
 2649 0a3e 01F0      		breq .L173
4679:../../Source/tasks.c **** 				}
 2651               	.LM309:
 2652 0a40 11A2      		std Z+33,__zero_reg__
 2653 0a42 12A2      		std Z+34,__zero_reg__
 2654 0a44 13A2      		std Z+35,__zero_reg__
 2655 0a46 14A2      		std Z+36,__zero_reg__
 2656 0a48 00C0      		rjmp .L172
 2657               	.L173:
4683:../../Source/tasks.c **** 				}
 2659               	.LM310:
 2660 0a4a 8B01      		movw r16,r22
 2661 0a4c 9C01      		movw r18,r24
 2662 0a4e 0150      		subi r16,1
 2663 0a50 1109      		sbc r17,__zero_reg__
 2664 0a52 2109      		sbc r18,__zero_reg__
 2665 0a54 3109      		sbc r19,__zero_reg__
 2666 0a56 01A3      		std Z+33,r16
 2667 0a58 12A3      		std Z+34,r17
 2668 0a5a 23A3      		std Z+35,r18
 2669 0a5c 34A3      		std Z+36,r19
 2670               	.L172:
4691:../../Source/tasks.c **** 		}
 2672               	.LM311:
 2673 0a5e E091 0000 		lds r30,pxCurrentTCB
 2674 0a62 F091 0000 		lds r31,pxCurrentTCB+1
 2675 0a66 15A2      		std Z+37,__zero_reg__
4693:../../Source/tasks.c **** 
 2677               	.LM312:
 2678               	/* #APP */
 2679               	 ;  4693 "../../Source/tasks.c" 1
 2680 0a68 0F90      		pop		__tmp_reg__
 2681               	 ;  0 "" 2
 2682               	 ;  4693 "../../Source/tasks.c" 1
 2683 0a6a 0FBE      		out		__SREG__, __tmp_reg__
 2684               	 ;  0 "" 2
 2685               	/* epilogue start */
4696:../../Source/tasks.c **** 
 2687               	.LM313:
 2688               	/* #NOAPP */
 2689 0a6c 1F91      		pop r17
 2690 0a6e 0F91      		pop r16
 2691 0a70 0895      		ret
 2696               	.Lscope28:
 2698               		.stabd	78,0,0
 2704               	.global	xTaskNotifyWait
 2706               	xTaskNotifyWait:
 2707               		.stabd	46,0,0
4704:../../Source/tasks.c **** 	BaseType_t xReturn;
 2709               	.LM314:
 2710               	.LFBB29:
 2711 0a72 4F92      		push r4
 2712 0a74 5F92      		push r5
 2713 0a76 6F92      		push r6
 2714 0a78 7F92      		push r7
 2715 0a7a 8F92      		push r8
 2716 0a7c 9F92      		push r9
 2717 0a7e AF92      		push r10
 2718 0a80 BF92      		push r11
 2719 0a82 EF92      		push r14
 2720 0a84 FF92      		push r15
 2721 0a86 0F93      		push r16
 2722 0a88 1F93      		push r17
 2723               	/* prologue: function */
 2724               	/* frame size = 0 */
 2725               	/* stack size = 12 */
 2726               	.L__stack_usage = 12
 2727 0a8a 4901      		movw r8,r18
 2728 0a8c 5A01      		movw r10,r20
4707:../../Source/tasks.c **** 		{
 2730               	.LM315:
 2731               	/* #APP */
 2732               	 ;  4707 "../../Source/tasks.c" 1
 2733 0a8e 0FB6      		in		__tmp_reg__, __SREG__
 2734               	 ;  0 "" 2
 2735               	 ;  4707 "../../Source/tasks.c" 1
 2736 0a90 F894      		cli
 2737               	 ;  0 "" 2
 2738               	 ;  4707 "../../Source/tasks.c" 1
 2739 0a92 0F92      		push	__tmp_reg__
 2740               	 ;  0 "" 2
4710:../../Source/tasks.c **** 			{
 2742               	.LM316:
 2743               	/* #NOAPP */
 2744 0a94 E091 0000 		lds r30,pxCurrentTCB
 2745 0a98 F091 0000 		lds r31,pxCurrentTCB+1
 2746 0a9c 25A1      		ldd r18,Z+37
 2747 0a9e 2230      		cpi r18,lo8(2)
 2748 0aa0 01F0      		breq .L182
4715:../../Source/tasks.c **** 
 2750               	.LM317:
 2751 0aa2 E091 0000 		lds r30,pxCurrentTCB
 2752 0aa6 F091 0000 		lds r31,pxCurrentTCB+1
 2753 0aaa 21A1      		ldd r18,Z+33
 2754 0aac 32A1      		ldd r19,Z+34
 2755 0aae 43A1      		ldd r20,Z+35
 2756 0ab0 54A1      		ldd r21,Z+36
 2757 0ab2 2B01      		movw r4,r22
 2758 0ab4 3C01      		movw r6,r24
 2759 0ab6 4094      		com r4
 2760 0ab8 5094      		com r5
 2761 0aba 6094      		com r6
 2762 0abc 7094      		com r7
 2763 0abe D301      		movw r26,r6
 2764 0ac0 C201      		movw r24,r4
 2765 0ac2 8223      		and r24,r18
 2766 0ac4 9323      		and r25,r19
 2767 0ac6 A423      		and r26,r20
 2768 0ac8 B523      		and r27,r21
 2769 0aca 81A3      		std Z+33,r24
 2770 0acc 92A3      		std Z+34,r25
 2771 0ace A3A3      		std Z+35,r26
 2772 0ad0 B4A3      		std Z+36,r27
4718:../../Source/tasks.c **** 
 2774               	.LM318:
 2775 0ad2 E091 0000 		lds r30,pxCurrentTCB
 2776 0ad6 F091 0000 		lds r31,pxCurrentTCB+1
 2777 0ada 81E0      		ldi r24,lo8(1)
 2778 0adc 85A3      		std Z+37,r24
4720:../../Source/tasks.c **** 				{
 2780               	.LM319:
 2781 0ade E114      		cp r14,__zero_reg__
 2782 0ae0 F104      		cpc r15,__zero_reg__
 2783 0ae2 01F0      		breq .L182
4722:../../Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
 2785               	.LM320:
 2786 0ae4 C701      		movw r24,r14
 2787 0ae6 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
4729:../../Source/tasks.c **** 				}
 2789               	.LM321:
 2790 0aea 0E94 0000 		call vPortYield
 2791               	.L182:
4741:../../Source/tasks.c **** 
 2793               	.LM322:
 2794               	/* #APP */
 2795               	 ;  4741 "../../Source/tasks.c" 1
 2796 0aee 0F90      		pop		__tmp_reg__
 2797               	 ;  0 "" 2
 2798               	 ;  4741 "../../Source/tasks.c" 1
 2799 0af0 0FBE      		out		__SREG__, __tmp_reg__
 2800               	 ;  0 "" 2
4743:../../Source/tasks.c **** 		{
 2802               	.LM323:
 2803               	 ;  4743 "../../Source/tasks.c" 1
 2804 0af2 0FB6      		in		__tmp_reg__, __SREG__
 2805               	 ;  0 "" 2
 2806               	 ;  4743 "../../Source/tasks.c" 1
 2807 0af4 F894      		cli
 2808               	 ;  0 "" 2
 2809               	 ;  4743 "../../Source/tasks.c" 1
 2810 0af6 0F92      		push	__tmp_reg__
 2811               	 ;  0 "" 2
4747:../../Source/tasks.c **** 			{
 2813               	.LM324:
 2814               	/* #NOAPP */
 2815 0af8 0115      		cp r16,__zero_reg__
 2816 0afa 1105      		cpc r17,__zero_reg__
 2817 0afc 01F0      		breq .L184
4751:../../Source/tasks.c **** 			}
 2819               	.LM325:
 2820 0afe E091 0000 		lds r30,pxCurrentTCB
 2821 0b02 F091 0000 		lds r31,pxCurrentTCB+1
 2822 0b06 81A1      		ldd r24,Z+33
 2823 0b08 92A1      		ldd r25,Z+34
 2824 0b0a A3A1      		ldd r26,Z+35
 2825 0b0c B4A1      		ldd r27,Z+36
 2826 0b0e F801      		movw r30,r16
 2827 0b10 8083      		st Z,r24
 2828 0b12 9183      		std Z+1,r25
 2829 0b14 A283      		std Z+2,r26
 2830 0b16 B383      		std Z+3,r27
 2831               	.L184:
4758:../../Source/tasks.c **** 			{
 2833               	.LM326:
 2834 0b18 E091 0000 		lds r30,pxCurrentTCB
 2835 0b1c F091 0000 		lds r31,pxCurrentTCB+1
 2836 0b20 85A1      		ldd r24,Z+37
 2837 0b22 8230      		cpi r24,lo8(2)
 2838 0b24 01F4      		brne .L186
4767:../../Source/tasks.c **** 				xReturn = pdTRUE;
 2840               	.LM327:
 2841 0b26 E091 0000 		lds r30,pxCurrentTCB
 2842 0b2a F091 0000 		lds r31,pxCurrentTCB+1
 2843 0b2e 41A1      		ldd r20,Z+33
 2844 0b30 52A1      		ldd r21,Z+34
 2845 0b32 63A1      		ldd r22,Z+35
 2846 0b34 74A1      		ldd r23,Z+36
 2847 0b36 D501      		movw r26,r10
 2848 0b38 C401      		movw r24,r8
 2849 0b3a 8095      		com r24
 2850 0b3c 9095      		com r25
 2851 0b3e A095      		com r26
 2852 0b40 B095      		com r27
 2853 0b42 8423      		and r24,r20
 2854 0b44 9523      		and r25,r21
 2855 0b46 A623      		and r26,r22
 2856 0b48 B723      		and r27,r23
 2857 0b4a 81A3      		std Z+33,r24
 2858 0b4c 92A3      		std Z+34,r25
 2859 0b4e A3A3      		std Z+35,r26
 2860 0b50 B4A3      		std Z+36,r27
4768:../../Source/tasks.c **** 			}
 2862               	.LM328:
 2863 0b52 81E0      		ldi r24,lo8(1)
 2864 0b54 00C0      		rjmp .L185
 2865               	.L186:
4761:../../Source/tasks.c **** 			}
 2867               	.LM329:
 2868 0b56 80E0      		ldi r24,0
 2869               	.L185:
4771:../../Source/tasks.c **** 		}
 2871               	.LM330:
 2872 0b58 E091 0000 		lds r30,pxCurrentTCB
 2873 0b5c F091 0000 		lds r31,pxCurrentTCB+1
 2874 0b60 15A2      		std Z+37,__zero_reg__
4773:../../Source/tasks.c **** 
 2876               	.LM331:
 2877               	/* #APP */
 2878               	 ;  4773 "../../Source/tasks.c" 1
 2879 0b62 0F90      		pop		__tmp_reg__
 2880               	 ;  0 "" 2
 2881               	 ;  4773 "../../Source/tasks.c" 1
 2882 0b64 0FBE      		out		__SREG__, __tmp_reg__
 2883               	 ;  0 "" 2
 2884               	/* epilogue start */
4776:../../Source/tasks.c **** 
 2886               	.LM332:
 2887               	/* #NOAPP */
 2888 0b66 1F91      		pop r17
 2889 0b68 0F91      		pop r16
 2890 0b6a FF90      		pop r15
 2891 0b6c EF90      		pop r14
 2892 0b6e BF90      		pop r11
 2893 0b70 AF90      		pop r10
 2894 0b72 9F90      		pop r9
 2895 0b74 8F90      		pop r8
 2896 0b76 7F90      		pop r7
 2897 0b78 6F90      		pop r6
 2898 0b7a 5F90      		pop r5
 2899 0b7c 4F90      		pop r4
 2900 0b7e 0895      		ret
 2905               	.Lscope29:
 2907               		.stabd	78,0,0
 2913               	.global	xTaskGenericNotify
 2915               	xTaskGenericNotify:
 2916               		.stabd	46,0,0
4784:../../Source/tasks.c **** 	TCB_t * pxTCB;
 2918               	.LM333:
 2919               	.LFBB30:
 2920 0b80 0F93      		push r16
 2921 0b82 1F93      		push r17
 2922 0b84 CF93      		push r28
 2923 0b86 DF93      		push r29
 2924               	/* prologue: function */
 2925               	/* frame size = 0 */
 2926               	/* stack size = 4 */
 2927               	.L__stack_usage = 4
 2928 0b88 FC01      		movw r30,r24
4792:../../Source/tasks.c **** 		{
 2930               	.LM334:
 2931               	/* #APP */
 2932               	 ;  4792 "../../Source/tasks.c" 1
 2933 0b8a 0FB6      		in		__tmp_reg__, __SREG__
 2934               	 ;  0 "" 2
 2935               	 ;  4792 "../../Source/tasks.c" 1
 2936 0b8c F894      		cli
 2937               	 ;  0 "" 2
 2938               	 ;  4792 "../../Source/tasks.c" 1
 2939 0b8e 0F92      		push	__tmp_reg__
 2940               	 ;  0 "" 2
4794:../../Source/tasks.c **** 			{
 2942               	.LM335:
 2943               	/* #NOAPP */
 2944 0b90 0115      		cp r16,__zero_reg__
 2945 0b92 1105      		cpc r17,__zero_reg__
 2946 0b94 01F0      		breq .L194
4796:../../Source/tasks.c **** 			}
 2948               	.LM336:
 2949 0b96 81A1      		ldd r24,Z+33
 2950 0b98 92A1      		ldd r25,Z+34
 2951 0b9a A3A1      		ldd r26,Z+35
 2952 0b9c B4A1      		ldd r27,Z+36
 2953 0b9e E801      		movw r28,r16
 2954 0ba0 8883      		st Y,r24
 2955 0ba2 9983      		std Y+1,r25
 2956 0ba4 AA83      		std Y+2,r26
 2957 0ba6 BB83      		std Y+3,r27
 2958               	.L194:
4799:../../Source/tasks.c **** 
 2960               	.LM337:
 2961 0ba8 35A1      		ldd r19,Z+37
4801:../../Source/tasks.c **** 
 2963               	.LM338:
 2964 0baa 82E0      		ldi r24,lo8(2)
 2965 0bac 85A3      		std Z+37,r24
4803:../../Source/tasks.c **** 			{
 2967               	.LM339:
 2968 0bae 2230      		cpi r18,lo8(2)
 2969 0bb0 01F0      		breq .L196
 2970 0bb2 00F4      		brsh .L197
 2971 0bb4 2130      		cpi r18,lo8(1)
 2972 0bb6 01F4      		brne .L195
4806:../../Source/tasks.c **** 					break;
 2974               	.LM340:
 2975 0bb8 81A1      		ldd r24,Z+33
 2976 0bba 92A1      		ldd r25,Z+34
 2977 0bbc A3A1      		ldd r26,Z+35
 2978 0bbe B4A1      		ldd r27,Z+36
 2979 0bc0 482B      		or r20,r24
 2980 0bc2 592B      		or r21,r25
 2981 0bc4 6A2B      		or r22,r26
 2982 0bc6 7B2B      		or r23,r27
 2983 0bc8 00C0      		rjmp .L209
 2984               	.L197:
4803:../../Source/tasks.c **** 			{
 2986               	.LM341:
 2987 0bca 2330      		cpi r18,lo8(3)
 2988 0bcc 01F0      		breq .L209
 2989 0bce 2430      		cpi r18,lo8(4)
 2990 0bd0 01F0      		breq .L200
 2991 0bd2 00C0      		rjmp .L195
 2992               	.L196:
4810:../../Source/tasks.c **** 					break;
 2994               	.LM342:
 2995 0bd4 81A1      		ldd r24,Z+33
 2996 0bd6 92A1      		ldd r25,Z+34
 2997 0bd8 A3A1      		ldd r26,Z+35
 2998 0bda B4A1      		ldd r27,Z+36
 2999 0bdc 0196      		adiw r24,1
 3000 0bde A11D      		adc r26,__zero_reg__
 3001 0be0 B11D      		adc r27,__zero_reg__
 3002 0be2 81A3      		std Z+33,r24
 3003 0be4 92A3      		std Z+34,r25
 3004 0be6 A3A3      		std Z+35,r26
 3005 0be8 B4A3      		std Z+36,r27
4811:../../Source/tasks.c **** 
 3007               	.LM343:
 3008 0bea 00C0      		rjmp .L195
 3009               	.L200:
4818:../../Source/tasks.c **** 					{
 3011               	.LM344:
 3012 0bec 3230      		cpi r19,lo8(2)
 3013 0bee 01F0      		breq .L205
 3014               	.L209:
4820:../../Source/tasks.c **** 					}
 3016               	.LM345:
 3017 0bf0 41A3      		std Z+33,r20
 3018 0bf2 52A3      		std Z+34,r21
 3019 0bf4 63A3      		std Z+35,r22
 3020 0bf6 74A3      		std Z+36,r23
 3021               	.L195:
4847:../../Source/tasks.c **** 			{
 3023               	.LM346:
 3024 0bf8 3130      		cpi r19,lo8(1)
 3025 0bfa 01F4      		brne .L210
 3026 0bfc EF01      		movw r28,r30
4849:../../Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 3028               	.LM347:
 3029 0bfe 8F01      		movw r16,r30
 3030 0c00 0E5F      		subi r16,-2
 3031 0c02 1F4F      		sbci r17,-1
 3032 0c04 C801      		movw r24,r16
 3033 0c06 0E94 0000 		call uxListRemove
4850:../../Source/tasks.c **** 
 3035               	.LM348:
 3036 0c0a 8E89      		ldd r24,Y+22
 3037 0c0c 9091 0000 		lds r25,uxTopReadyPriority
 3038 0c10 9817      		cp r25,r24
 3039 0c12 00F4      		brsh .L203
4850:../../Source/tasks.c **** 
 3041               	.LM349:
 3042 0c14 8093 0000 		sts uxTopReadyPriority,r24
 3043               	.L203:
4850:../../Source/tasks.c **** 
 3045               	.LM350:
 3046 0c18 29E0      		ldi r18,lo8(9)
 3047 0c1a 829F      		mul r24,r18
 3048 0c1c C001      		movw r24,r0
 3049 0c1e 1124      		clr __zero_reg__
 3050 0c20 B801      		movw r22,r16
 3051 0c22 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3052 0c24 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3053 0c26 0E94 0000 		call vListInsertEnd
4871:../../Source/tasks.c **** 				{
 3055               	.LM351:
 3056 0c2a E091 0000 		lds r30,pxCurrentTCB
 3057 0c2e F091 0000 		lds r31,pxCurrentTCB+1
 3058 0c32 9E89      		ldd r25,Y+22
 3059 0c34 8689      		ldd r24,Z+22
 3060 0c36 8917      		cp r24,r25
 3061 0c38 00F4      		brsh .L210
4875:../../Source/tasks.c **** 				}
 3063               	.LM352:
 3064 0c3a 0E94 0000 		call vPortYield
 3065               	.L210:
 3066 0c3e 81E0      		ldi r24,lo8(1)
 3067 0c40 00C0      		rjmp .L201
 3068               	.L205:
4825:../../Source/tasks.c **** 					}
 3070               	.LM353:
 3071 0c42 80E0      		ldi r24,0
 3072               	.L201:
4887:../../Source/tasks.c **** 
 3074               	.LM354:
 3075               	/* #APP */
 3076               	 ;  4887 "../../Source/tasks.c" 1
 3077 0c44 0F90      		pop		__tmp_reg__
 3078               	 ;  0 "" 2
 3079               	 ;  4887 "../../Source/tasks.c" 1
 3080 0c46 0FBE      		out		__SREG__, __tmp_reg__
 3081               	 ;  0 "" 2
 3082               	/* epilogue start */
4890:../../Source/tasks.c **** 
 3084               	.LM355:
 3085               	/* #NOAPP */
 3086 0c48 DF91      		pop r29
 3087 0c4a CF91      		pop r28
 3088 0c4c 1F91      		pop r17
 3089 0c4e 0F91      		pop r16
 3090 0c50 0895      		ret
 3096               	.Lscope30:
 3098               		.stabd	78,0,0
 3105               	.global	xTaskGenericNotifyFromISR
 3107               	xTaskGenericNotifyFromISR:
 3108               		.stabd	46,0,0
4898:../../Source/tasks.c **** 	TCB_t * pxTCB;
 3110               	.LM356:
 3111               	.LFBB31:
 3112 0c52 EF92      		push r14
 3113 0c54 FF92      		push r15
 3114 0c56 0F93      		push r16
 3115 0c58 1F93      		push r17
 3116 0c5a CF93      		push r28
 3117 0c5c DF93      		push r29
 3118               	/* prologue: function */
 3119               	/* frame size = 0 */
 3120               	/* stack size = 6 */
 3121               	.L__stack_usage = 6
 3122 0c5e FC01      		movw r30,r24
4928:../../Source/tasks.c **** 			{
 3124               	.LM357:
 3125 0c60 0115      		cp r16,__zero_reg__
 3126 0c62 1105      		cpc r17,__zero_reg__
 3127 0c64 01F0      		breq .L212
4930:../../Source/tasks.c **** 			}
 3129               	.LM358:
 3130 0c66 81A1      		ldd r24,Z+33
 3131 0c68 92A1      		ldd r25,Z+34
 3132 0c6a A3A1      		ldd r26,Z+35
 3133 0c6c B4A1      		ldd r27,Z+36
 3134 0c6e E801      		movw r28,r16
 3135 0c70 8883      		st Y,r24
 3136 0c72 9983      		std Y+1,r25
 3137 0c74 AA83      		std Y+2,r26
 3138 0c76 BB83      		std Y+3,r27
 3139               	.L212:
4933:../../Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3141               	.LM359:
 3142 0c78 35A1      		ldd r19,Z+37
4934:../../Source/tasks.c **** 
 3144               	.LM360:
 3145 0c7a 82E0      		ldi r24,lo8(2)
 3146 0c7c 85A3      		std Z+37,r24
4936:../../Source/tasks.c **** 			{
 3148               	.LM361:
 3149 0c7e 2230      		cpi r18,lo8(2)
 3150 0c80 01F0      		breq .L214
 3151 0c82 00F4      		brsh .L215
 3152 0c84 2130      		cpi r18,lo8(1)
 3153 0c86 01F4      		brne .L213
4939:../../Source/tasks.c **** 					break;
 3155               	.LM362:
 3156 0c88 81A1      		ldd r24,Z+33
 3157 0c8a 92A1      		ldd r25,Z+34
 3158 0c8c A3A1      		ldd r26,Z+35
 3159 0c8e B4A1      		ldd r27,Z+36
 3160 0c90 482B      		or r20,r24
 3161 0c92 592B      		or r21,r25
 3162 0c94 6A2B      		or r22,r26
 3163 0c96 7B2B      		or r23,r27
 3164 0c98 00C0      		rjmp .L233
 3165               	.L215:
4936:../../Source/tasks.c **** 			{
 3167               	.LM363:
 3168 0c9a 2330      		cpi r18,lo8(3)
 3169 0c9c 01F0      		breq .L233
 3170 0c9e 2430      		cpi r18,lo8(4)
 3171 0ca0 01F0      		breq .L218
 3172 0ca2 00C0      		rjmp .L213
 3173               	.L214:
4943:../../Source/tasks.c **** 					break;
 3175               	.LM364:
 3176 0ca4 81A1      		ldd r24,Z+33
 3177 0ca6 92A1      		ldd r25,Z+34
 3178 0ca8 A3A1      		ldd r26,Z+35
 3179 0caa B4A1      		ldd r27,Z+36
 3180 0cac 0196      		adiw r24,1
 3181 0cae A11D      		adc r26,__zero_reg__
 3182 0cb0 B11D      		adc r27,__zero_reg__
 3183 0cb2 81A3      		std Z+33,r24
 3184 0cb4 92A3      		std Z+34,r25
 3185 0cb6 A3A3      		std Z+35,r26
 3186 0cb8 B4A3      		std Z+36,r27
4944:../../Source/tasks.c **** 
 3188               	.LM365:
 3189 0cba 00C0      		rjmp .L213
 3190               	.L218:
4951:../../Source/tasks.c **** 					{
 3192               	.LM366:
 3193 0cbc 3230      		cpi r19,lo8(2)
 3194 0cbe 01F0      		breq .L226
 3195               	.L233:
4953:../../Source/tasks.c **** 					}
 3197               	.LM367:
 3198 0cc0 41A3      		std Z+33,r20
 3199 0cc2 52A3      		std Z+34,r21
 3200 0cc4 63A3      		std Z+35,r22
 3201 0cc6 74A3      		std Z+36,r23
 3202               	.L213:
4979:../../Source/tasks.c **** 			{
 3204               	.LM368:
 3205 0cc8 3130      		cpi r19,lo8(1)
 3206 0cca 01F0      		breq .L220
 3207               	.L224:
4898:../../Source/tasks.c **** 	TCB_t * pxTCB;
 3209               	.LM369:
 3210 0ccc 81E0      		ldi r24,lo8(1)
 3211 0cce 00C0      		rjmp .L219
 3212               	.L220:
 3213 0cd0 EF01      		movw r28,r30
4984:../../Source/tasks.c **** 				{
 3215               	.LM370:
 3216 0cd2 8091 0000 		lds r24,uxSchedulerSuspended
 3217 0cd6 8111      		cpse r24,__zero_reg__
 3218 0cd8 00C0      		rjmp .L221
4986:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3220               	.LM371:
 3221 0cda 8F01      		movw r16,r30
 3222 0cdc 0E5F      		subi r16,-2
 3223 0cde 1F4F      		sbci r17,-1
 3224 0ce0 C801      		movw r24,r16
 3225 0ce2 0E94 0000 		call uxListRemove
4987:../../Source/tasks.c **** 				}
 3227               	.LM372:
 3228 0ce6 8E89      		ldd r24,Y+22
 3229 0ce8 9091 0000 		lds r25,uxTopReadyPriority
 3230 0cec 9817      		cp r25,r24
 3231 0cee 00F4      		brsh .L222
4987:../../Source/tasks.c **** 				}
 3233               	.LM373:
 3234 0cf0 8093 0000 		sts uxTopReadyPriority,r24
 3235               	.L222:
4987:../../Source/tasks.c **** 				}
 3237               	.LM374:
 3238 0cf4 E9E0      		ldi r30,lo8(9)
 3239 0cf6 8E9F      		mul r24,r30
 3240 0cf8 C001      		movw r24,r0
 3241 0cfa 1124      		clr __zero_reg__
 3242 0cfc B801      		movw r22,r16
 3243 0cfe 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3244 0d00 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3245 0d02 00C0      		rjmp .L234
 3246               	.L221:
4993:../../Source/tasks.c **** 				}
 3248               	.LM375:
 3249 0d04 BF01      		movw r22,r30
 3250 0d06 645F      		subi r22,-12
 3251 0d08 7F4F      		sbci r23,-1
 3252 0d0a 80E0      		ldi r24,lo8(xPendingReadyList)
 3253 0d0c 90E0      		ldi r25,hi8(xPendingReadyList)
 3254               	.L234:
 3255 0d0e 0E94 0000 		call vListInsertEnd
4996:../../Source/tasks.c **** 				{
 3257               	.LM376:
 3258 0d12 E091 0000 		lds r30,pxCurrentTCB
 3259 0d16 F091 0000 		lds r31,pxCurrentTCB+1
 3260 0d1a 9E89      		ldd r25,Y+22
 3261 0d1c 8689      		ldd r24,Z+22
 3262 0d1e 8917      		cp r24,r25
 3263 0d20 00F4      		brsh .L224
5000:../../Source/tasks.c **** 					{
 3265               	.LM377:
 3266 0d22 E114      		cp r14,__zero_reg__
 3267 0d24 F104      		cpc r15,__zero_reg__
 3268 0d26 01F0      		breq .L225
5002:../../Source/tasks.c **** 					}
 3270               	.LM378:
 3271 0d28 81E0      		ldi r24,lo8(1)
 3272 0d2a E701      		movw r28,r14
 3273 0d2c 8883      		st Y,r24
 3274               	.L225:
5008:../../Source/tasks.c **** 				}
 3276               	.LM379:
 3277 0d2e 81E0      		ldi r24,lo8(1)
 3278 0d30 8093 0000 		sts xYieldPending,r24
 3279 0d34 00C0      		rjmp .L219
 3280               	.L226:
4958:../../Source/tasks.c **** 					}
 3282               	.LM380:
 3283 0d36 80E0      		ldi r24,0
 3284               	.L219:
 3285               	/* epilogue start */
5019:../../Source/tasks.c **** 
 3287               	.LM381:
 3288 0d38 DF91      		pop r29
 3289 0d3a CF91      		pop r28
 3290 0d3c 1F91      		pop r17
 3291 0d3e 0F91      		pop r16
 3292 0d40 FF90      		pop r15
 3293 0d42 EF90      		pop r14
 3294 0d44 0895      		ret
 3300               	.Lscope31:
 3302               		.stabd	78,0,0
 3306               	.global	vTaskNotifyGiveFromISR
 3308               	vTaskNotifyGiveFromISR:
 3309               		.stabd	46,0,0
5027:../../Source/tasks.c **** 	TCB_t * pxTCB;
 3311               	.LM382:
 3312               	.LFBB32:
 3313 0d46 EF92      		push r14
 3314 0d48 FF92      		push r15
 3315 0d4a 0F93      		push r16
 3316 0d4c 1F93      		push r17
 3317 0d4e CF93      		push r28
 3318 0d50 DF93      		push r29
 3319               	/* prologue: function */
 3320               	/* frame size = 0 */
 3321               	/* stack size = 6 */
 3322               	.L__stack_usage = 6
 3323 0d52 FC01      		movw r30,r24
5056:../../Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3325               	.LM383:
 3326 0d54 25A1      		ldd r18,Z+37
5057:../../Source/tasks.c **** 
 3328               	.LM384:
 3329 0d56 82E0      		ldi r24,lo8(2)
 3330 0d58 85A3      		std Z+37,r24
5061:../../Source/tasks.c **** 
 3332               	.LM385:
 3333 0d5a 81A1      		ldd r24,Z+33
 3334 0d5c 92A1      		ldd r25,Z+34
 3335 0d5e A3A1      		ldd r26,Z+35
 3336 0d60 B4A1      		ldd r27,Z+36
 3337 0d62 0196      		adiw r24,1
 3338 0d64 A11D      		adc r26,__zero_reg__
 3339 0d66 B11D      		adc r27,__zero_reg__
 3340 0d68 81A3      		std Z+33,r24
 3341 0d6a 92A3      		std Z+34,r25
 3342 0d6c A3A3      		std Z+35,r26
 3343 0d6e B4A3      		std Z+36,r27
5067:../../Source/tasks.c **** 			{
 3345               	.LM386:
 3346 0d70 2130      		cpi r18,lo8(1)
 3347 0d72 01F4      		brne .L235
 3348 0d74 8B01      		movw r16,r22
 3349 0d76 EF01      		movw r28,r30
5072:../../Source/tasks.c **** 				{
 3351               	.LM387:
 3352 0d78 8091 0000 		lds r24,uxSchedulerSuspended
 3353 0d7c 8111      		cpse r24,__zero_reg__
 3354 0d7e 00C0      		rjmp .L238
5074:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3356               	.LM388:
 3357 0d80 7F01      		movw r14,r30
 3358 0d82 22E0      		ldi r18,2
 3359 0d84 E20E      		add r14,r18
 3360 0d86 F11C      		adc r15,__zero_reg__
 3361 0d88 C701      		movw r24,r14
 3362 0d8a 0E94 0000 		call uxListRemove
5075:../../Source/tasks.c **** 				}
 3364               	.LM389:
 3365 0d8e 8E89      		ldd r24,Y+22
 3366 0d90 9091 0000 		lds r25,uxTopReadyPriority
 3367 0d94 9817      		cp r25,r24
 3368 0d96 00F4      		brsh .L239
5075:../../Source/tasks.c **** 				}
 3370               	.LM390:
 3371 0d98 8093 0000 		sts uxTopReadyPriority,r24
 3372               	.L239:
5075:../../Source/tasks.c **** 				}
 3374               	.LM391:
 3375 0d9c E9E0      		ldi r30,lo8(9)
 3376 0d9e 8E9F      		mul r24,r30
 3377 0da0 C001      		movw r24,r0
 3378 0da2 1124      		clr __zero_reg__
 3379 0da4 B701      		movw r22,r14
 3380 0da6 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3381 0da8 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3382 0daa 00C0      		rjmp .L246
 3383               	.L238:
5081:../../Source/tasks.c **** 				}
 3385               	.LM392:
 3386 0dac BF01      		movw r22,r30
 3387 0dae 645F      		subi r22,-12
 3388 0db0 7F4F      		sbci r23,-1
 3389 0db2 80E0      		ldi r24,lo8(xPendingReadyList)
 3390 0db4 90E0      		ldi r25,hi8(xPendingReadyList)
 3391               	.L246:
 3392 0db6 0E94 0000 		call vListInsertEnd
5084:../../Source/tasks.c **** 				{
 3394               	.LM393:
 3395 0dba E091 0000 		lds r30,pxCurrentTCB
 3396 0dbe F091 0000 		lds r31,pxCurrentTCB+1
 3397 0dc2 9E89      		ldd r25,Y+22
 3398 0dc4 8689      		ldd r24,Z+22
 3399 0dc6 8917      		cp r24,r25
 3400 0dc8 00F4      		brsh .L235
5088:../../Source/tasks.c **** 					{
 3402               	.LM394:
 3403 0dca 0115      		cp r16,__zero_reg__
 3404 0dcc 1105      		cpc r17,__zero_reg__
 3405 0dce 01F0      		breq .L242
5090:../../Source/tasks.c **** 					}
 3407               	.LM395:
 3408 0dd0 81E0      		ldi r24,lo8(1)
 3409 0dd2 F801      		movw r30,r16
 3410 0dd4 8083      		st Z,r24
 3411               	.L242:
5096:../../Source/tasks.c **** 				}
 3413               	.LM396:
 3414 0dd6 81E0      		ldi r24,lo8(1)
 3415 0dd8 8093 0000 		sts xYieldPending,r24
 3416               	.L235:
 3417               	/* epilogue start */
5105:../../Source/tasks.c **** 
 3419               	.LM397:
 3420 0ddc DF91      		pop r29
 3421 0dde CF91      		pop r28
 3422 0de0 1F91      		pop r17
 3423 0de2 0F91      		pop r16
 3424 0de4 FF90      		pop r15
 3425 0de6 EF90      		pop r14
 3426 0de8 0895      		ret
 3431               	.Lscope32:
 3433               		.stabd	78,0,0
 3436               	.global	xTaskNotifyStateClear
 3438               	xTaskNotifyStateClear:
 3439               		.stabd	46,0,0
5113:../../Source/tasks.c **** 	TCB_t *pxTCB;
 3441               	.LM398:
 3442               	.LFBB33:
 3443               	/* prologue: function */
 3444               	/* frame size = 0 */
 3445               	/* stack size = 0 */
 3446               	.L__stack_usage = 0
5119:../../Source/tasks.c **** 
 3448               	.LM399:
 3449 0dea 0097      		sbiw r24,0
 3450 0dec 01F4      		brne .L248
5119:../../Source/tasks.c **** 
 3452               	.LM400:
 3453 0dee 8091 0000 		lds r24,pxCurrentTCB
 3454 0df2 9091 0000 		lds r25,pxCurrentTCB+1
 3455               	.L248:
5121:../../Source/tasks.c **** 		{
 3457               	.LM401:
 3458               	/* #APP */
 3459               	 ;  5121 "../../Source/tasks.c" 1
 3460 0df6 0FB6      		in		__tmp_reg__, __SREG__
 3461               	 ;  0 "" 2
 3462               	 ;  5121 "../../Source/tasks.c" 1
 3463 0df8 F894      		cli
 3464               	 ;  0 "" 2
 3465               	 ;  5121 "../../Source/tasks.c" 1
 3466 0dfa 0F92      		push	__tmp_reg__
 3467               	 ;  0 "" 2
5123:../../Source/tasks.c **** 			{
 3469               	.LM402:
 3470               	/* #NOAPP */
 3471 0dfc FC01      		movw r30,r24
 3472 0dfe 25A1      		ldd r18,Z+37
 3473 0e00 2230      		cpi r18,lo8(2)
 3474 0e02 01F4      		brne .L250
5125:../../Source/tasks.c **** 				xReturn = pdPASS;
 3476               	.LM403:
 3477 0e04 15A2      		std Z+37,__zero_reg__
5126:../../Source/tasks.c **** 			}
 3479               	.LM404:
 3480 0e06 81E0      		ldi r24,lo8(1)
 3481 0e08 00C0      		rjmp .L249
 3482               	.L250:
5130:../../Source/tasks.c **** 			}
 3484               	.LM405:
 3485 0e0a 80E0      		ldi r24,0
 3486               	.L249:
5133:../../Source/tasks.c **** 
 3488               	.LM406:
 3489               	/* #APP */
 3490               	 ;  5133 "../../Source/tasks.c" 1
 3491 0e0c 0F90      		pop		__tmp_reg__
 3492               	 ;  0 "" 2
 3493               	 ;  5133 "../../Source/tasks.c" 1
 3494 0e0e 0FBE      		out		__SREG__, __tmp_reg__
 3495               	 ;  0 "" 2
5136:../../Source/tasks.c **** 
 3497               	.LM407:
 3498               	/* #NOAPP */
 3499 0e10 0895      		ret
 3504               	.Lscope33:
 3506               		.stabd	78,0,0
 3510               	.global	ulTaskNotifyValueClear
 3512               	ulTaskNotifyValueClear:
 3513               		.stabd	46,0,0
5144:../../Source/tasks.c **** 	TCB_t *pxTCB;
 3515               	.LM408:
 3516               	.LFBB34:
 3517 0e12 CF92      		push r12
 3518 0e14 DF92      		push r13
 3519 0e16 EF92      		push r14
 3520 0e18 FF92      		push r15
 3521 0e1a 0F93      		push r16
 3522 0e1c 1F93      		push r17
 3523               	/* prologue: function */
 3524               	/* frame size = 0 */
 3525               	/* stack size = 6 */
 3526               	.L__stack_usage = 6
5150:../../Source/tasks.c **** 
 3528               	.LM409:
 3529 0e1e 0097      		sbiw r24,0
 3530 0e20 01F4      		brne .L252
5150:../../Source/tasks.c **** 
 3532               	.LM410:
 3533 0e22 8091 0000 		lds r24,pxCurrentTCB
 3534 0e26 9091 0000 		lds r25,pxCurrentTCB+1
 3535               	.L252:
5152:../../Source/tasks.c **** 		{
 3537               	.LM411:
 3538               	/* #APP */
 3539               	 ;  5152 "../../Source/tasks.c" 1
 3540 0e2a 0FB6      		in		__tmp_reg__, __SREG__
 3541               	 ;  0 "" 2
 3542               	 ;  5152 "../../Source/tasks.c" 1
 3543 0e2c F894      		cli
 3544               	 ;  0 "" 2
 3545               	 ;  5152 "../../Source/tasks.c" 1
 3546 0e2e 0F92      		push	__tmp_reg__
 3547               	 ;  0 "" 2
5156:../../Source/tasks.c **** 			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
 3549               	.LM412:
 3550               	/* #NOAPP */
 3551 0e30 E091 0000 		lds r30,pxCurrentTCB
 3552 0e34 F091 0000 		lds r31,pxCurrentTCB+1
 3553 0e38 C1A0      		ldd r12,Z+33
 3554 0e3a D2A0      		ldd r13,Z+34
 3555 0e3c E3A0      		ldd r14,Z+35
 3556 0e3e F4A0      		ldd r15,Z+36
5157:../../Source/tasks.c **** 		}
 3558               	.LM413:
 3559 0e40 FC01      		movw r30,r24
 3560 0e42 01A1      		ldd r16,Z+33
 3561 0e44 12A1      		ldd r17,Z+34
 3562 0e46 23A1      		ldd r18,Z+35
 3563 0e48 34A1      		ldd r19,Z+36
 3564 0e4a 4095      		com r20
 3565 0e4c 5095      		com r21
 3566 0e4e 6095      		com r22
 3567 0e50 7095      		com r23
 3568 0e52 4023      		and r20,r16
 3569 0e54 5123      		and r21,r17
 3570 0e56 6223      		and r22,r18
 3571 0e58 7323      		and r23,r19
 3572 0e5a 41A3      		std Z+33,r20
 3573 0e5c 52A3      		std Z+34,r21
 3574 0e5e 63A3      		std Z+35,r22
 3575 0e60 74A3      		std Z+36,r23
5159:../../Source/tasks.c **** 
 3577               	.LM414:
 3578               	/* #APP */
 3579               	 ;  5159 "../../Source/tasks.c" 1
 3580 0e62 0F90      		pop		__tmp_reg__
 3581               	 ;  0 "" 2
 3582               	 ;  5159 "../../Source/tasks.c" 1
 3583 0e64 0FBE      		out		__SREG__, __tmp_reg__
 3584               	 ;  0 "" 2
5162:../../Source/tasks.c **** 
 3586               	.LM415:
 3587               	/* #NOAPP */
 3588 0e66 C701      		movw r24,r14
 3589 0e68 B601      		movw r22,r12
 3590               	/* epilogue start */
 3591 0e6a 1F91      		pop r17
 3592 0e6c 0F91      		pop r16
 3593 0e6e FF90      		pop r15
 3594 0e70 EF90      		pop r14
 3595 0e72 DF90      		pop r13
 3596 0e74 CF90      		pop r12
 3597 0e76 0895      		ret
 3602               	.Lscope34:
 3604               		.stabd	78,0,0
 3605               		.local	uxSchedulerSuspended
 3606               		.comm	uxSchedulerSuspended,1,1
 3607               		.local	xIdleTaskHandle
 3608               		.comm	xIdleTaskHandle,2,1
 3609               		.local	xNextTaskUnblockTime
 3610               		.comm	xNextTaskUnblockTime,2,1
 3611               		.local	uxTaskNumber
 3612               		.comm	uxTaskNumber,1,1
 3613               		.local	xNumOfOverflows
 3614               		.comm	xNumOfOverflows,1,1
 3615               		.local	xYieldPending
 3616               		.comm	xYieldPending,1,1
 3617               		.local	xPendedTicks
 3618               		.comm	xPendedTicks,2,1
 3619               		.local	xSchedulerRunning
 3620               		.comm	xSchedulerRunning,1,1
 3621               		.local	uxTopReadyPriority
 3622               		.comm	uxTopReadyPriority,1,1
 3623               		.local	xTickCount
 3624               		.comm	xTickCount,2,1
 3625               		.local	uxCurrentNumberOfTasks
 3626               		.comm	uxCurrentNumberOfTasks,1,1
 3627               		.local	uxDeletedTasksWaitingCleanUp
 3628               		.comm	uxDeletedTasksWaitingCleanUp,1,1
 3629               		.local	xTasksWaitingTermination
 3630               		.comm	xTasksWaitingTermination,9,1
 3631               		.local	xPendingReadyList
 3632               		.comm	xPendingReadyList,9,1
 3633               		.local	pxOverflowDelayedTaskList
 3634               		.comm	pxOverflowDelayedTaskList,2,1
 3635               		.local	pxDelayedTaskList
 3636               		.comm	pxDelayedTaskList,2,1
 3637               		.local	xDelayedTaskList2
 3638               		.comm	xDelayedTaskList2,9,1
 3639               		.local	xDelayedTaskList1
 3640               		.comm	xDelayedTaskList1,9,1
 3641               		.local	pxReadyTasksLists
 3642               		.comm	pxReadyTasksLists,36,1
 3643               	.global	pxCurrentTCB
 3644               		.section .bss
 3647               	pxCurrentTCB:
 3648 0000 0000      		.zero	2
 3669               		.text
 3671               	.Letext0:
 3672               		.ident	"GCC: (GNU) 5.4.0"
 3673               	.global __do_copy_data
 3674               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/ccwnwRwh.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccwnwRwh.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccwnwRwh.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccwnwRwh.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccwnwRwh.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccwnwRwh.s:191    .text:0000000000000000 prvResetNextTaskUnblockTime
     /tmp/ccwnwRwh.s:3634   .bss:0000000000000026 pxDelayedTaskList
     /tmp/ccwnwRwh.s:3608   .bss:0000000000000005 xNextTaskUnblockTime
     /tmp/ccwnwRwh.s:242    .text:0000000000000036 prvAddCurrentTaskToDelayedList.isra.2
     /tmp/ccwnwRwh.s:3622   .bss:000000000000000e xTickCount
     /tmp/ccwnwRwh.s:3647   .bss:0000000000000000 pxCurrentTCB
     /tmp/ccwnwRwh.s:3632   .bss:0000000000000024 pxOverflowDelayedTaskList
     /tmp/ccwnwRwh.s:352    .text:00000000000000bc prvIdleTask
     /tmp/ccwnwRwh.s:3626   .bss:0000000000000011 uxDeletedTasksWaitingCleanUp
     /tmp/ccwnwRwh.s:3628   .bss:0000000000000012 xTasksWaitingTermination
     /tmp/ccwnwRwh.s:3624   .bss:0000000000000010 uxCurrentNumberOfTasks
     /tmp/ccwnwRwh.s:3640   .bss:000000000000003a pxReadyTasksLists
     /tmp/ccwnwRwh.s:463    .text:0000000000000118 xTaskCreate
     /tmp/ccwnwRwh.s:3638   .bss:0000000000000031 xDelayedTaskList1
     /tmp/ccwnwRwh.s:3636   .bss:0000000000000028 xDelayedTaskList2
     /tmp/ccwnwRwh.s:3630   .bss:000000000000001b xPendingReadyList
     /tmp/ccwnwRwh.s:3618   .bss:000000000000000c xSchedulerRunning
     /tmp/ccwnwRwh.s:3610   .bss:0000000000000007 uxTaskNumber
     /tmp/ccwnwRwh.s:3620   .bss:000000000000000d uxTopReadyPriority
     /tmp/ccwnwRwh.s:853    .text:000000000000030e vTaskDelete
     /tmp/ccwnwRwh.s:1000   .text:00000000000003b8 vTaskStartScheduler
     /tmp/ccwnwRwh.s:3606   .bss:0000000000000003 xIdleTaskHandle
     /tmp/ccwnwRwh.s:1079   .text:000000000000040c vTaskEndScheduler
     /tmp/ccwnwRwh.s:1108   .text:0000000000000416 vTaskSuspendAll
                             .bss:0000000000000002 uxSchedulerSuspended
     /tmp/ccwnwRwh.s:1130   .text:0000000000000422 xTaskGetTickCount
     /tmp/ccwnwRwh.s:1179   .text:0000000000000436 xTaskGetTickCountFromISR
     /tmp/ccwnwRwh.s:1205   .text:0000000000000440 uxTaskGetNumberOfTasks
     /tmp/ccwnwRwh.s:1228   .text:0000000000000446 pcTaskGetName
     /tmp/ccwnwRwh.s:1257   .text:0000000000000456 xTaskIncrementTick
     /tmp/ccwnwRwh.s:3612   .bss:0000000000000008 xNumOfOverflows
     /tmp/ccwnwRwh.s:3614   .bss:0000000000000009 xYieldPending
     /tmp/ccwnwRwh.s:3616   .bss:000000000000000a xPendedTicks
     /tmp/ccwnwRwh.s:1497   .text:00000000000005b8 xTaskResumeAll
     /tmp/ccwnwRwh.s:1702   .text:000000000000069e vTaskDelayUntil
     /tmp/ccwnwRwh.s:1822   .text:000000000000070c vTaskDelay
     /tmp/ccwnwRwh.s:1873   .text:0000000000000734 xTaskCatchUpTicks
     /tmp/ccwnwRwh.s:1911   .text:000000000000075a vTaskSwitchContext
     /tmp/ccwnwRwh.s:2018   .text:00000000000007e0 vTaskPlaceOnEventList
     /tmp/ccwnwRwh.s:2058   .text:0000000000000800 vTaskPlaceOnUnorderedEventList
     /tmp/ccwnwRwh.s:2103   .text:000000000000082e xTaskRemoveFromEventList
     /tmp/ccwnwRwh.s:2210   .text:00000000000008ae vTaskRemoveFromUnorderedEventList
     /tmp/ccwnwRwh.s:2295   .text:0000000000000912 vTaskSetTimeOutState
     /tmp/ccwnwRwh.s:2347   .text:0000000000000932 vTaskInternalSetTimeOutState
     /tmp/ccwnwRwh.s:2377   .text:0000000000000948 xTaskCheckForTimeOut
     /tmp/ccwnwRwh.s:2486   .text:000000000000099c vTaskMissedYield
     /tmp/ccwnwRwh.s:2507   .text:00000000000009a4 uxTaskResetEventItemValue
     /tmp/ccwnwRwh.s:2551   .text:00000000000009d2 ulTaskNotifyTake
     /tmp/ccwnwRwh.s:2706   .text:0000000000000a72 xTaskNotifyWait
     /tmp/ccwnwRwh.s:2915   .text:0000000000000b80 xTaskGenericNotify
     /tmp/ccwnwRwh.s:3107   .text:0000000000000c52 xTaskGenericNotifyFromISR
     /tmp/ccwnwRwh.s:3308   .text:0000000000000d46 vTaskNotifyGiveFromISR
     /tmp/ccwnwRwh.s:3438   .text:0000000000000dea xTaskNotifyStateClear
     /tmp/ccwnwRwh.s:3512   .text:0000000000000e12 ulTaskNotifyValueClear

UNDEFINED SYMBOLS
uxListRemove
vListInsert
vPortFree
vPortYield
vApplicationIdleHook
pvPortMalloc
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vListInsertEnd
xPortStartScheduler
vPortEndScheduler
__do_copy_data
__do_clear_bss
